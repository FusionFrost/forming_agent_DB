






























                             По договору между издательством «СимволПлюс» и Интернетмага
                             зином «Books.Ru  Книги  России» единственный легальный способ
                             получения данного файла с книгой ISBN 593286060X, название
                             «UML. Основы, 3е издание» – покупка в Интернетмагазине «Books.Ru
                              Книги России». Если Вы получили данный файл какимлибо другим
                             образом, Вы нарушили международное законодательство и законода
                             тельство Российской Федерации об охране авторского права. Вам необ
                             ходимо удалить данный файл, а также сообщить издательству «Сим
                             волПлюс» (piracy@symbol.ru), где именно Вы получили данный файл.




































                               UML Distilled







                                       A Brief Guide to the Standard

                                         Object Modeling Language




                                                   Third Edition










                                                  Martin Fowler




































                               UML Основы







                                           Краткое руководство

                                        по стандартному языку
                                      объектного моделирования




                                                 Третье издание








                                               Мартин Фаулер














                                                  СанктПетербург

                                                         2005



















                                                     Мартин Фаулер

                                           UML. Основы, 3е издание

                                                    Перевод А. Петухова

                                          Главный редактор                  А. Галунов
                                          Зав. редакцией                  Н. Макарова
                                          Научный редактор                 В. Шальнев
                                          Редактор                      В. Овчинников
                                          Корректура                      О. Макарова
                                          Верстка                         Н. Гриценко

                             Фаулер M.
                             UML. Основы, 3е издание. – Пер. с англ. – СПб: СимволПлюс, 2004. – 192 с.,
                             ил.
                             ISBN 593286060Х
                             Третье издание бестселлера Фаулера «UML. Основы» охватывает UML 2 – вер
                             сию, которая существенно отличается от всех предыдущих. Но основная фор
                             мула успеха этой книги не претерпела изменений. До сих пор она, бесспорно,
                             остается лучшим кратким и точным руководством по применению UML.
                             Главное достоинство книги заключается в кратком и сжатом изложении сути
                             UML и особенностей применения этого языка в современном процессе разра
                             ботки ПО. В книге описаны все главные типы диаграмм UML, рассказано, для
                             чего они предназначены и какие нотации применяются при их создании и чте
                             нии. Это диаграммы классов, последовательности, объектов, пакетов, развер
                             тывания, прецедентов, состояний, деятельности, составных структур, компо
                             нентов, обзора взаимодействия, коммуникационные и временные.
                             Фаулер не только в ясной и доступной манере описывает ключевые аспекты
                             языка UML, но и четко показывает ту роль, которую UML играет в процессе
                             разработки. Замечательные примеры  моделирования являются  результатом
                             многолетнего опыта работы автора в области проектирования и моделирования.

                        ISBN 593286060Х
                        ISBN 0321193687 (англ)
                             © Издательство СимволПлюс, 2004
                             Original English language title: UML Distilled: A Brief Guide to the Standard Object
                             Modeling Language, Third Edition by Martin Fowler, Copyright © 2004 by Pearson
                             Education, Inc. All Rights Reserved. Published by arrangement with the original pub
                             lisher, Pearson Education, Inc., publishing as ADDISON WESLEY.
                             Все права на данное издание защищены Законодательством РФ, включая право на полное или час
                             тичное воспроизведение в любой форме. Все товарные знаки или зарегистрированные товарные зна
                             ки, упоминаемые в настоящем издании, являются собственностью соответствующих фирм.
                                    Издательство «СимволПлюс». 199034, СанктПетербург, 16 линия, 7,
                                   тел. (812) 3245353, edit@symbol.ru. Лицензия ЛП N 000054 от 25.12.98.
                                       Налоговая льгота – общероссийский классификатор продукции
                                              ОК 00593, том 2; 953000 – книги и брошюры.
                                     Подписано в печать 9.12.2004. Формат 70х100  1 /16 .  Печать офсетная.
                                               Объем 12 печ. л. Тираж 2000 экз. Заказ N
                                      Отпечатано с готовых диапозитивов в ГУП «Типография «Наука»
                                                199034, СанктПетербург, 9 линия, 12.




































                                                 Посвящается Синди



























                                                                           Оглавление





                           Отзывы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
                           Предисловие к третьему изданию. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
                           Предисловие к первому изданию  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
                           От автора . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
                        1.  Введение  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
                            Что такое UML? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
                            Способы применения UML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
                            Как мы пришли к UML  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
                            Нотации и метамодели. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
                            Диаграммы UML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
                            Что такое допустимый UML? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
                            Смысл UML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
                            UML не достаточно . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
                            С чего начать. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

                        2. Процесс разработки. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
                            Процессы итеративные и водопадные . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
                            Прогнозирующее и адаптивное планирование  . . . . . . . . . . . . . . . . . . . . . . . . . 49
                            Гибкие процессы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
                            Унифицированный процесс от Rational  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
                            Настройка процесса под проект. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
                            Настройка UML под процесс. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
                            Выбор процесса разработки  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

                        3. Диаграммы классов: основы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
                            Свойства. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
                            Атрибуты. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
                            Кратность  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
                            Программная интерпретация свойств . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66















                        8                                                               Оглавление


                            Двунаправленные ассоциации. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
                            Операции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
                            Обобщение. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
                            Примечания и комментарии  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
                            Зависимость . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
                            Правила ограничений  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
                            Когда применяются диаграммы классов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

                        4. Диаграммы последовательности. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
                            Создание и удаление участников. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
                            Циклы, условия и тому подобное . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
                            Синхронные и асинхронные вызовы  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
                            Когда применяются диаграммы последовательности . . . . . . . . . . . . . . . . . . . 89
                        5. Диаграммы классов: дополнительные понятия. . . . . . . . . . . . . . . . . . . . . . 92
                            Ключевые слова . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
                            Ответственности  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
                            Статические операции и атрибуты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
                            Агрегация и композиция  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
                            Производные свойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
                            Интерфейсы и абстрактные классы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
                            ReadOnly и Frozen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .100
                            Объектыссылки и объектызначения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .100
                            Квалифицированные ассоциации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101
                            Классификация и обобщение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .102
                            Множественная и динамическая классификация  . . . . . . . . . . . . . . . . . . . . .103
                            Классассоциация . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .105
                            Шаблон класса (параметризованный класс)  . . . . . . . . . . . . . . . . . . . . . . . . . .108
                            Перечисления. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .109
                            Активный класс. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .110
                            Видимость . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .110
                            Сообщения. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111

                        6. Диаграммы объектов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .112
                            Когда применяются диаграммы объектов  . . . . . . . . . . . . . . . . . . . . . . . . . . . .113
                        7. Диаграммы пакетов  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .114
                            Пакеты и зависимости . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .116
                            Аспекты пакетов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .118
                            Реализация пакетов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .119















                        Оглавление                                                              9


                            Когда применяются диаграммы пакетов  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120

                        8. Диаграммы развертывания . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .121
                            Когда применяются диаграммы развертывания. . . . . . . . . . . . . . . . . . . . . . .122

                        9. Прецеденты. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123
                            Содержимое прецедентов  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .124
                            Диаграммы прецедентов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .126
                            Уровни прецедентов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .127
                            Прецеденты и возможности (или пожелания). . . . . . . . . . . . . . . . . . . . . . . . .128
                            Когда применяются прецеденты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .128
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . .129
                        10. Диаграммы состояний . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .130
                            Внутренние активности. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .132
                            Состояния активности . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133
                            Суперсостояния . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133
                            Параллельные состояния  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .134
                            Реализация диаграмм состояний  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .135
                            Когда применяются диаграммы состояний  . . . . . . . . . . . . . . . . . . . . . . . . . . .137
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . .138

                        11. Диаграммы деятельности. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .139
                            Декомпозиция операции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .141
                            Разделы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .143
                            Сигналы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .144
                            Маркеры  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .145
                            Потоки и ребра . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .145
                            Контакты и преобразования. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .146
                            Области расширения  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .147
                            Окончание потока . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .148
                            Описания объединений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .149
                            И еще немного  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .150
                            Когда применяются диаграммы деятельности  . . . . . . . . . . . . . . . . . . . . . . . .150
                            Где найти дополнительную информацию . . . . . . . . . . . . . . . . . . . . . . . . . . . . .151

                        12. Коммуникационные диаграммы. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .152
                            Когда применяются коммуникационные диаграммы . . . . . . . . . . . . . . . . . .154

                        13. Составные структуры  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .155
                            Когда применяются составные структуры . . . . . . . . . . . . . . . . . . . . . . . . . . . .157















                        10                                                              Оглавление


                        14. Диаграммы компонентов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .158
                            Когда применяются диаграммы компонентов. . . . . . . . . . . . . . . . . . . . . . . . .160
                        15. Кооперации. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .161
                            Когда применяются кооперации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .163

                        16. Диаграммы обзора взаимодействия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .164
                            Когда применяются диаграммы обзора взаимодействия . . . . . . . . . . . . . . .164
                        17. Временные диаграммы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .166
                            Когда применяются временные диаграммы. . . . . . . . . . . . . . . . . . . . . . . . . . .167

                        A. Отличия версий языка UML  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .168

                           Библиография . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .177
                           Алфавитный указатель  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .180



























                                                          Список иллюстраций




                             Рис. 1.1.  Фрагмент метамодели UML. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
                             Рис. 1.2.  Классификация типов диаграмм UML . . . . . . . . . . . . . . . . . . . . . . . 39
                             Рис. 1.3.  Неформальная диаграмма потока экранов . . . . . . . . . . . . . . . . . . . 42
                             Рис. 3.1.  Простая диаграмма класса  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
                             Рис. 3.2.  Представление свойств заказа в виде атрибутов  . . . . . . . . . . . . . . 64
                             Рис. 3.3.  Представление свойств заказа в виде ассоциаций. . . . . . . . . . . . . 64
                             Рис. 3.4.  Двунаправленная ассоциация  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
                             Рис. 3.5.  Использование глаголав имени ассоциации . . . . . . . . . . . . . . . . . . 69
                             Рис. 3.6.  Примечание используется как комментарий
                                      к одному или более элементам диаграммы . . . . . . . . . . . . . . . . . . . 73
                             Рис. 3.7.  Пример зависимостей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
                             Рис. 4.1.  Диаграмма последовательности централизованного
                                      управления  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
                             Рис. 4.2.  Диаграмма последовательности распределенного
                                      управления  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
                             Рис. 4.3.  Создание и удаление участников . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
                             Рис. 4.4.  Фреймы взаимодействия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
                             Рис. 4.5.  Старые соглашения для условной логики . . . . . . . . . . . . . . . . . . . . 87
                             Рис. 4.6.  Пример CRCкарточки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
                             Рис. 5.1.  Представление обязанностей на диаграмме классов. . . . . . . . . . . 94
                             Рис. 5.2.  Статическая нотация. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
                             Рис. 5.3.  Агрегация. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
                             Рис. 5.4.  Композиция. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
                             Рис. 5.5.  Производный атрибут для временного интервала. . . . . . . . . . . . . 96
                             Рис. 5.6.  Пример интерфейсов и абстрактного класса
                                      на языке Java  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
                             Рис. 5.7.  Шаровогнездовая нотация . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
                             Рис. 5.8.  Более старое обозначение зависимостей с помощью
                                      «леденцов на палочке» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
                             Рис. 5.9.  Представление полиморфизма на диаграммах
                                      последовательности с помощью нотации леденцов. . . . . . . . . . . . 99















                        12


                             Рис. 5.10.  Квалифицированная ассоциация  . . . . . . . . . . . . . . . . . . . . . . . . .102
                             Рис. 5.11.  Множественная классификация . . . . . . . . . . . . . . . . . . . . . . . . . .104
                             Рис. 5.12.  Классассоциация  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .105
                             Рис. 5.13.  Развитие классаассоциации до обычного класса . . . . . . . . . . .105
                             Рис. 5.14.  Хитрости классаассоциации . . . . . . . . . . . . . . . . . . . . . . . . . . . . .106
                             Рис. 5.15.  Использование класса для временного отношения. . . . . . . . . .107
                             Рис. 5.16.  Ключевое слово «temporal» для ассоциаций. . . . . . . . . . . . . . . .107
                             Рис. 5.17.  Классшаблон . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .108
                             Рис. 5.18.  Связанный элемент (вариант 1) . . . . . . . . . . . . . . . . . . . . . . . . . . .108
                             Рис. 5.19.  Связанный элемент (вариант 2) . . . . . . . . . . . . . . . . . . . . . . . . . . .109
                             Рис. 5.20.  Перечисление . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .109
                             Рис. 5.21.  Активный класс . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .110
                             Рис. 5.22.  Классы с сообщениями. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111
                             Рис. 6.1.  Диаграмма классов, показывающая структуру
                                      класса Party. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .112
                             Рис. 6.2.  Диаграмма объектов с примером экземпляра
                                      класса Party. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .113
                             Рис. 7.1.  Способы изображения пакетов на диаграммах  . . . . . . . . . . . . . .115
                             Рис. 7.2.  Диаграмма пакетов для промышленного предприятия. . . . . . .117
                             Рис. 7.3.  Разделение рис. 7.2 на два аспекта . . . . . . . . . . . . . . . . . . . . . . . . .118
                             Рис. 7.4.  Пакет, реализованный другими пакетами  . . . . . . . . . . . . . . . . . .119
                             Рис. 7.5.  Определение затребованного интерфейса
                                      в клиентском пакете . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120
                             Рис. 8.1.  Пример диаграммы развертывания  . . . . . . . . . . . . . . . . . . . . . . . .122
                             Рис. 9.1.  Пример текста прецедента. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .125
                             Рис. 9.2.  Диаграмма прецедентов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .127
                             Рис. 10.1.  Простая диаграмма состояний . . . . . . . . . . . . . . . . . . . . . . . . . . . .131
                             Рис. 10.2.  Внутренние события, показанные в состоянии
                                       набора текста в текстовом поле  . . . . . . . . . . . . . . . . . . . . . . . . . . .132
                             Рис. 10.3.  Состояние с активностью. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133
                             Рис. 10.4.  Суперсостояние с вложенными подсостояниями  . . . . . . . . . . .134
                             Рис. 10.5.  Параллельные состояния. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .134
                             Рис. 10.6.  Вложенный оператор switch на языке C#
                                       для обработки перехода состояний . . . . . . . . . . . . . . . . . . . . . . . .135
                             Рис. 10.7.  Паттерн «Состояние», реализующий диаграмму
                                       на рис. 10.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .136
                             Рис. 11.1.  Простая диаграмма деятельности . . . . . . . . . . . . . . . . . . . . . . . . .140
                             Рис. 11.2.  Дополнительная диаграмма деятельности . . . . . . . . . . . . . . . . .142















                                                                                               13


                             Рис. 11.3.  Деятельность из рис. 11.1 модифицирована
                                       для вызова деятельности из рис. 11.2  . . . . . . . . . . . . . . . . . . . . .142
                             Рис. 11.4.  Разбиение диаграммы деятельности на разделы. . . . . . . . . . . .143
                             Рис. 11.5.  Сигналы в диаграмме деятельности . . . . . . . . . . . . . . . . . . . . . . .144
                             Рис. 11.6.  Отправка и прием сигналов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .145
                             Рис. 11.7.  Четыре способа представления ребер . . . . . . . . . . . . . . . . . . . . . .146
                             Рис. 11.8.  Преобразование потока  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .147
                             Рис. 11.9.  Область расширения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .148
                             Рис. 11.10.  Нотация для единственной процедуры
                                        в области расширения  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .148
                             Рис. 11.11.  Окончание потока в активности  . . . . . . . . . . . . . . . . . . . . . . . . .149
                             Рис. 11.12.  Описание объединения. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .150
                             Рис. 12.1.  Коммуникационная диаграмма системы
                                       централизованного управления. . . . . . . . . . . . . . . . . . . . . . . . . . .153
                             Рис. 12.2.  Коммуникационная диаграмма с вложенной
                                       десятичной нумерацией. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .153
                             Рис. 13.1.  Два способа представления объекта TV Viewer
                                       и его интерфейсов  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .155
                             Рис. 13.2.  Внутренний вид компонента (пример, предложенный
                                       Джимом Рамбо)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .156
                             Рис. 13.3.  Компонент с несколькими портами  . . . . . . . . . . . . . . . . . . . . . . .156
                             Рис. 14.1.  Нотация для компонентов. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .158
                             Рис. 14.2.  Пример диаграммы компонентов  . . . . . . . . . . . . . . . . . . . . . . . . .159
                             Рис. 15.1.  Кооперация вместе с ее классами и ролями  . . . . . . . . . . . . . . . .161
                             Рис. 15.2.  Диаграмма последовательности для аукционной
                                       кооперации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .162
                             Рис. 15.3.  Наличие кооперации. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .163
                             Рис. 15.4.  Необычный способ показа применения паттерна в JUnit   . . .163
                             Рис. 16.1.  Диаграмма обзора взаимодействий. . . . . . . . . . . . . . . . . . . . . . . .165
                             Рис. 17.1.  Временная диаграмма, на которой состояния
                                       представлены в виде линий. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .167
                             Рис. 17.2.  Временная диаграмма, на которой состояния
                                       представлены в виде областей  . . . . . . . . . . . . . . . . . . . . . . . . . . . .167



























                             Отзывы





                             «Книга  UML Distilled остается лучшим введением в нотации UML.  Живой
                             и прагматичный стиль Мартина прекрасно воспринимается, и я искренне ре
                             комендую эту книгу».
                                                                      – Крэйг Ларман (Craig Larman),
                                                             автор книги «Applying UML and Patterns»
                             «Фаулер пробивает путь сквозь сложности UML, помогая пользователям быст
                             ро познакомиться с UML».
                                                                      – Джим Рамбо (Jim Rambaugh),
                                                                      автор и один из создателей UML
                             «UML Distilled Мартина Фаулера – это прекрасный способ познакомиться с
                             UML. Большинство пользователей найдут в этой книге все необходимое для
                             успешного применения UML. С точки зрения Мартина, UML можно использо
                             вать различными путями, но наибольшее признание он получил как инстру
                             мент эскизного моделирования. Эта книга прекрасно выполняет работу по вы
                             явлению сущности UML. Настоятельно рекомендую».
                                                     – Стив Кук (Steve Cook), разработчик ПО, Microsoft
                             «Небольшие книги по UML лучше, чем большие. До сих пор эта книга остает
                             ся лучшим кратким  изданием по  UML. Фактически это лучшая  небольшая
                             книга по многим темам».
                                                               – Алистер Кокборн (Alistair Cockburn),
                                                             автор и президент Humans and Technology
                             «Эта книга  исключительно полезна, легко  читается и – одно  из  главных ее
                             достоинств – в восхитительно краткой манере охватывает значительное коли
                             чество тем.  Если  вы собираетесь приобрести только  одну книгу по UML, то
                             должны купить именно эту».
                                                                 – Энди Кармайкл (Andy Carmichael),
                                                                          BetterSoftwareFaster, Ltd.
                             «Если вы используете UML, то эта книга всегда должна быть рядом».
                                                         – Джон Крупи (John Crupi), Sun Microsystems,
                                                                  соавтор книги «Core J2EE Patterns»























                             «Все, кто занимается моделированием с применением UML, изучает UML, чи
                             тает про UML или разрабатывает UMLинструменты, должны иметь последнее
                             издание этой книги (у меня есть все издания). В ней много хорошей, полезной
                             информации. В общем, информации достаточно, чтобы быть полезной, но не
                             слишком много, чтобы стать скучной».
                                                         – Джон Керн (Jon Kern), разработчик моделей
                             «Это прекрасная отправная точка для изучения основ UML».
                                                                 – Скотт В. Амблер (Scott W. Ambler),
                                                                        автор книги «Agile Modeling»

                             «В высшей степени практичное описание языка UML и его применения, с дос
                             таточной степенью юмора, позволяющего удерживать внимание читателя. Во
                             истину, «В плавательной метафоре больше нет воды».
                                                                 – Стефан Меллор (Stephen J. Mellor),
                                                                     соавтор книги «Executable UML»

                             «Это идеальная книга для тех, кто хочет использовать UML, но не желает чи
                             тать толстые справочники по UML и исследовательские статьи. Мартин Фау
                             лер отбирает все важные технологии, необходимые для использования UML
                             при разработке эскизов, освобождая читателя от сложных и редко используе
                             мых возможностей UML. У читателей не будет недостатка в предложениях по
                             дальнейшему изучению. Читатель получает советы, основанные на опыте. Это
                             краткая и легко читаемая книга, посвященная основным аспектам UML и свя
                             занным с ними понятиями объектноориентированных технологий».
                                                                        – Павел Хруби (Pavel Hruby),
                                                                         Microsoft Business Solutions

                             «Подобно всем хорошим разработчикам программного  обеспечения, Фаулер
                             улучшает свой продукт с каждой итерацией. Это единственная книга, которой
                             я пользуюсь, когда даю уроки UML, и которую рекомендую для изучения».
                                                               – Чарльз Ашбахер (Charles Ashbacher),
                                                        президент/CEO, Charles Ashbacher Technologies

                             «Должно быть больше книг, подобных UML Distilled, – кратких и легко читае
                             мых. Мартин Фаулер выбирает разделы UML, которые вам нужны, и представ
                             ляет их в удобной для чтения форме. Авторский опыт применения языка моде
                             лирования для документирования проекта имеет бульшую ценность, чем про
                             стое описание этой технологии».
                                                     – Роб Персер (Rob Purser), Purser Consulting, LLC.



























                             Предисловие

                             к третьему изданию




                             С древних времен большинству талантливых архитекторов и одарен
                             ных дизайнеров известен закон экономии. Независимо от формы, то
                             ли в виде парадокса («чем меньше, тем больше»), то ли в виде коэна
                             (разум дзэна – это разум новичка), он имеет непреходящее значение:
                             Сократи все до его сути, так чтобы форма пребывала в гармонии с со
                             держанием. Лучшие архитекторы и дизайнеры – от пирамид до Опер
                             ного театра в Сиднее, от построений Неймана до UNIX и языка Small
                             talk – старались следовать этому универсальному и вечному правилу.

                             Я понимаю, что значит бриться Бритвой Оккама, поэтому когда я со
                             бираюсь вести разработку или читать, то ищу проекты и книги, в кото
                             рых соблюдается закон экономии.  Следовательно, я одобряю книгу,
                             которую вы сейчас читаете.
                             Это мое замечание может удивить вас на первых порах. Я часто загля
                             дывал в объемные и компактные спецификации, которые определяют
                             UML (Unified Modeling Language – унифицированный язык моделиро
                             вания). Эти спецификации позволяют инструментам поставщиков ре
                             ализовывать UML, а методологам применять его. За семь лет мне дове
                             лось руководить большими международными командами по стандар
                             тизации, которые занимались спецификациями версий UML 1.1 и 2.0,
                             а также нескольких менее важных промежуточных версий. В течение
                             этого времени UML добавил  в выразительности и точности, а также
                             приобрел никому не нужную сложность как результат процесса стан
                             дартизации. Печально, что процесс стандартизации  лучше известен
                             компромиссами в области дизайна со стороны комитета, нежели своей
                             расчетливой элегантностью.

                             Что может извлечь из книги Мартина, посвященной основам UML 2.0,
                             специалист, хорошо знающий разные скрытые мелочи спецификации
                             UML? Вполне достаточно, то же можете и вы. Мартин умело сократил
                             большой и сложный язык до практичного подмножества, эффектив
                             ность которого он доказал на практике. При подготовке нового изда
                             ния своей книги он не пошел по легкому пути, который диктовала так
                             тика простого добавления страниц. Когда язык разросся, Мартин по
                             прежнему придерживался своей цели, ища  «наиболее полезную со















                        Предисловие к третьему изданию                                         17


                             ставляющую языка UML» и рассказывая вам именно о ней. Составля
                             ющая, на  которую он ссылается, – это те мистические 20% языка
                             UML, которые помогают выполнять 80% работы. Поймать  и приру
                             чить этого иллюзорного зверя – значительный успех!
                             Это тем более поразительно, что Мартин достигает своей цели, излагая
                             материал в удивительной, притягательной разговорной манере. Доно
                             ся до нас свою точку зрения и рассказывая при этом анекдоты, он де
                             лает свою книгу приятной для чтения и тем самым напоминает нам,
                             что системы архитектуры и дизайна должны быть продуктивными и
                             в то же время оригинальными.  Если  мы  следуем коэну экономии  до
                             конца, то нужно признать, что моделирование проектов с помощью
                             языка UML должно быть таким же приятным, какими были для нас
                             уроки рисования и живописи в средней школе. UML должен стать гро
                             моотводом наших творческих способностей, а также лазером для вы
                             жигания четко определяющих систему планов, которые третья сторо
                             на могла бы запросить и построить по ним такую же систему. Послед
                             нее является серьезным  испытанием  для любого настоящего языка
                             проектирования.
                             Для такой тонкой книжки это нетривиальная задача. Вы можете по
                             лучить от изучения подхода Мартина к моделированию столь же мно
                             го, как от его описания UML 2.0.
                             Мне  было  приятно работать с  Мартином над улучшением подбора и
                             точности возможностей языка UML 2.0, объясняемых в этой версии.
                             Мы должны иметь в виду, что все современные языки, как естествен
                             ные, так и искусственные, должны развиваться или исчезнуть. Выбор
                             Мартином новых свойств языка в соответствии с его предпочтениями
                             и в соответствии с предпочтениями других профессионалов – это реша
                             ющий момент процесса пересмотра UML. Они поддерживают язык в
                             жизнеспособном состоянии и помогают ему эволюционировать в про
                             цессе естественного отбора на рынке.
                             Значительное количество многообещающих работ остаются вне управ
                             ляемого моделями способа разработки, который становится ведущим,
                             но меня поддерживают книги, подобные этой, которые понятно объяс
                             няют основы моделирования на языке UML и показывают его исполь
                             зование на практике. Я надеюсь, что вы, как и я, с ее помощью полу
                             чите новые знания и используете приобретенные вами навыки для по
                             вышения качества моделирования программного обеспечения.

                             Крис Кобрин (Cris Kobryn)
                             Chair, U2 Partners’ UML 2.0 Submission Team
                             Chief Technologist, Telelogic



























                             Предисловие

                             к первому изданию




                             Когда мы приступили к созданию унифицированного языка моделиро
                             вания (Unified  Modeling Language, UML), то надеялись, что  сможем
                             разработать стандартное средство для спецификации проектов, кото
                             рое будет не только отражать наилучший практический опыт в инду
                             стрии программного обеспечения, но и поможет снять ореол мистики
                             с процесса моделирования программных систем. Мы полагали, что на
                             личие стандартного языка моделирования побудит большее число раз
                             работчиков моделировать программные системы еще до начала их по
                             строения. Быстрое и широкое распространение языка UML демонст
                             рирует все большее признание преимуществ моделирования в сообще
                             стве разработчиков.
                             Само создание языка UML представляло собой итеративный и расши
                             ряющийся процесс,  очень похожий на моделирование большой  про
                             граммной системы. Конечным результатом этой работы является некий
                             стандарт, построенный на основе многих идей и при участии большого
                             количества людей и компаний из объектноориентированного сообще
                             ства. Мы начали разработку языка UML, однако многие последовате
                             ли помогли довести ее до успешного завершения, и мы благодарны им
                             за их вклад в общее дело.
                             Создание и согласование стандартного языка моделирования само по
                             себе является серьезной задачей. Обучение сообщества разработчиков
                             языку  UML  и представление его таким способом,  который одновре
                             менно был бы доступен и соответствовал контексту процесса разработ
                             ки программных систем, также является серьезной проблемой. В этой
                             обманчиво краткой книге, дополненной с целью отразить самые  по
                             следние изменения в языке UML, Мартин Фаулер оказался, как никто
                             другой, ближе к решению поставленной задачи.

                             Мартин не только в ясной и доступной манере описывает ключевые ас
                             пекты языка UML, но также четко показывает ту роль, которую язык
                             UML играет в процессе разработки. При прочтении книги мы получи
                             ли истинное удовольствие от тех замечательных примеров моделиро
                             вания, которые являются результатом более чем 12летнего опыта ра
                             боты Мартина в области проектирования и моделирования.















                        Предисловие к первому изданию                                          19


                             Данная книга служит введением в язык UML для многих тысяч разра
                             ботчиков, пробуждая у них интерес к дальнейшему изучению преиму
                             ществ моделирования на основе теперь уже стандартного языка моде
                             лирования.
                             Мы рекомендуем эту книгу всем разработчикам, желающим познако
                             миться с языком UML и оценить перспективы той ключевой роли, ко
                             торую он играет в процессе разработки.
                             Гради Буч
                             Айвар Джекобсон
                             Джеймс Рамбо



























                             От автора





                             На протяжении жизни мне много раз улыбалась удача; одним из боль
                             ших подарков фортуны было то, что я оказался в нужном месте, воору
                             женный необходимыми знаниями, в результате чего в 1997 году было
                             написано первое издание этой книги. В то время в хаотическом мире
                             объектноориентированного (ОО)  моделирования только начинался
                             процесс объединения под эгидой унифицированного языка моделиро
                             вания (Unified Modeling Language, UML). С тех пор UML стал стандар
                             том графического моделирования не только объектов, но и программ
                             ного обеспечения в целом. Мне повезло, что эта книга была самой по
                             пулярной по языку UML, разойдясь тиражом более четверти миллио
                             на экземпляров.
                             Конечно, мне это очень приятно, но зачем вам покупать мою книгу?

                             Я люблю подчеркивать, что это тонкая книжка. Ее цель не в том, что
                             бы детально  осветить каждый аспект языка UML, растущего с каж
                             дым годом. Я стремлюсь найти наиболее полезную часть языка и рас
                             сказать вам именно о ней. Хотя более объемная книга дает более де
                             тальное описание, но и читать ее нужно дольше. А время – самый цен
                             ный капитал, который вы вкладываете при чтении книги. Сохраняя
                             небольшой размер книги, я сэкономил вам время, выбирая самое луч
                             шее, и избавил вас от необходимости самостоятельно выполнить эту
                             работу. (К сожалению, «меньше» не означает пропорционально дешев
                             ле; существует определенная фиксированная стоимость издания высо
                             кокачественной технической книги.)
                             Один из мотивов, побуждающих приобрести данную книгу, – желание
                             получить начальные сведения по UML. Это маленькая книжка, и с ее
                             помощью можно быстро постичь основы языка. Что касается профес
                             сионального освоения, то более подробную информацию можно найти
                             в книге «User Guide» [6] или «Reference Manual» [40].
                             Эта книга может также служить удобным справочником по наиболее
                             общим разделам языка UML. В ней есть не все, зато она много легче
                             большинства других книг по UML и ее можно носить с собой повсюду.
                             Это книга с ярко выраженным мнением. Я долгое  время имел дело
                             с объектами и точно знаю, что работает, а что – нет. Любая книга отра
                             жает мнение автора, и я также не стараюсь скрывать свое. Поэтому ес















                        От автора                                                              21


                             ли  вы  ищете нечто, имеющее оттенок объективности, то,  возможно,
                             вам потребуется еще чтонибудь.
                             Многие разработчики говорили мне, что эта книга является хорошим
                             введением в объекты, однако при ее написании у меня не было такой
                             мысли. Если вам требуется введение в ОО, я бы рекомендовал книгу
                             К. Лармана (Craig Larman) [29].
                             Многие разработчики, интересующиеся UML, используют некоторый
                             инструментарий. Эта книга посвящена стандартному применению
                             UML в рамках принятых соглашений, и в ней не рассматриваются по
                             дробности поддержки языка различными инструментами. Несмотря
                             на то что UML справился с Вавилонской башней нотаций, существо
                             вавших до UML, осталось множество досадных различий между тем,
                             что показывают инструменты, и тем, что они позволяют делать в про
                             цессе рисования UMLдиаграмм.
                             Я не рассказываю в этой книге об MDA (Model Driven Architecture) –
                             архитектуре, основанной на модели. Распространено мнение, что это
                             одно и то же, но многие разработчики применяют язык UML, совер
                             шенно не  интересуясь MDA. Тем,  кто  хочет узнать об MDA  больше,
                             я бы посоветовал начать с данной книги, чтобы сначала познакомить
                             ся с UML, а затем перейти к книге, посвященной MDA.
                             Хотя главной темой этой книги является язык UML, я включил в нее
                             дополнительный материал о приемах, которые очень полезны в объ
                             ектноориентированном  проектировании, например, приведена ин
                             формация о CRCкарточках. UML – это только часть того, что необхо
                             димо знать для успешной работы с объектами, и я думаю, что он игра
                             ет важную роль при подготовке к освоению других приемов.
                             В такой небольшой книге, как эта, невозможно детально объяснить,
                             как UML соотносится с исходным кодом, в частности потому, что не
                             существует стандартного способа проведения такого соответствия. Од
                             нако я демонстрирую некоторые приемы программирования для реа
                             лизации элементов UML. Мои примеры написаны на Java и C#, по
                             скольку я обнаружил, что они понятны более широкой аудитории. Не
                             надо думать, что они мне больше нравятся. Для этого я слишком мно
                             го написал на Smalltalk!

                        Почему нужно заниматься UML?

                             Нотации визуального  проектирования применяются  уже довольно
                             долго. На мой взгляд, они играют основную роль для взаимопонима
                             ния. Хорошая диаграмма часто помогает обмениваться идеями о про
                             екте, особенно когда вы хотите избежать излишне подробного объяс
                             нения. Диаграммы также помогают понять и программную систему,
                             и бизнесплан. Когда группа разработчиков пытается в чемто  разо
                             браться, диаграммы помогают установлению взаимопонимания и рас
                             пространению такого понимания в команде. Диаграммы, по крайней















                        22                                                               От автора


                             мере пока, не заменяют текстовые языки программирования, но спо
                             собны оказать существенную помощь.
                             Многие уверены, что в будущем приемы визуального моделирования
                             выйдут на  ведущие роли  при создании программного обеспечения.
                             Я отношусь  к  этому  более скептически, но определенно полезно  по
                             нять, что можно сделать с помощью этих нотаций, а что нельзя. Наря
                             ду с графическими элементами значимость UML основана на его широ
                             ком распространении и стандартизации в рамках сообщества разработ
                             чиков, применяющих объектноориентированные  технологии. Язык
                             UML стал не только доминирующим визуальным инструментом в ми
                             ре объектноориентированного моделирования, но также  получил
                             признание и за его пределами.

                        Структура книги


                             Глава 1 представляет собой введение в UML: в ней описывается собст
                             венно язык,  рассказано, что  он означает  для разных разработчиков
                             и откуда он появился.
                             В  главе 2 обсуждается процесс создания  программного  обеспечения.
                             Хотя это совершенно не зависит от UML, я считаю, что необходимо по
                             нять этот процесс, чтобы увидеть контекст, подобный UML. В частно
                             сти, важно оценить роль итеративной разработки, лежащей в основе
                             подхода к процессу в большинстве ООсообществ.
                             В оставшейся части книги рассмотрены диаграммы UML различных ти
                             пов. Главы 3 и 4 посвящены двум наиболее полезным разделам UML –
                             диаграммам классов (основная часть) и диаграммам последовательно
                             стей. Это тонкая книжка, но я уверен, что приемы, о которых я рас
                             сказываю в этих главах, позволят вам оценить значимость этого язы
                             ка. UML велик и продолжает расти, но весь UML вам не потребуется.
                             В главе 5 подробно рассмотрены менее важные, но все же полезные эле
                             менты диаграмм классов. В главах с 6 по 8 описываются три полезные
                             диаграммы, которые еще более проясняют структуру системы: диа
                             граммы объектов, диаграммы пакетов и диаграммы развертывания.
                             В главах с 9 по 11 рассматриваются другие полезные поведенческие
                             приемы: прецеденты, диаграммы состояний (хотя официально они из
                             вестны как диаграммы конечных автоматов, чаще всего их называют
                             диаграммами состояний) и диаграммы деятельности. Главы с 12 по 17
                             очень короткие и посвящены диаграммам, в большинстве случаев
                             имеющим менее важное значение, поэтому для них я привел неболь
                             шие примеры и краткие объяснения.
                             Изложение включает обзор наиболее полезных элементов каждой но
                             тации. Я часто слышал от читателей, что это наиболее ценная часть
                             книги.  Возможно, вы найдете удобным  обращаться к ним во  время
                             чтения других разделов книги.















                        От автора                                                              23


                        Изменения в третьем издании

                             Обладатели  более раннего издания  этой книги, возможно, зададутся
                             вопросом об отличиях или, что важнее, о необходимости приобрести
                             новое издание.
                             Главным толчком к написанию  третьего издания было появление
                             UML 2. В него было добавлено множество новых элементов, в том чис
                             ле несколько новых типов диаграмм. Даже в знакомых диаграммах
                             применяется много новых нотаций, таких как фреймы взаимодейст
                             вия в диаграммах последовательностей. Тем, кто хочет быть в курсе
                             происходящего, но не желает утомлять себя чтением спецификации
                             (я определенно не рекомендовал бы этого делать!), эта книга может
                             предложить хороший обзор.
                             Кроме того,  я воспользовался этой возможностью, чтобы полностью
                             переписать бтльшую часть книги, обновив примеры и текст многим из
                             того, что я изучил, преподавая и применяя UML в течение последних
                             пяти лет. Поэтому, несмотря на то что дух этой сверхтонкой книги ос
                             тался нетронутым, большинство слов в ней новые.
                             Все эти годы я усердно работал, пытаясь по мере сил сохранить акту
                             альность материала. Пока UML изменялся, я изо всех сил старался не
                             отстать от него. В основе этой книги лежит проект UML 2, который был
                             принят соответствующим комитетом в июне 2003 года. Маловероятно,
                             что между этим голосованием и другими, более формальными голосо
                             ваниями произойдут дальнейшие изменения, поэтому я чувствую, что
                             UML 2 теперь достаточно стабилен, чтобы отдать книгу в печать. Я бу
                             ду размещать информацию  об обновлениях  на вебсайте  http://mar'
                             tinfowler.com.

                        Благодарности

                             Долгие годы усилия многих людей составляли успех этой книги. Пер
                             выми хочу поблагодарить Картера Шанклина (Carter Shanklin) и Кен
                             далла Скотта (Kendall Scott). Картер был тем самым редактором изда
                             тельства AddisonWesley, кто предложил мне написать эту книгу. Кен
                             далл Скотт помогал мне объединять первые два издания, работая над
                             текстом  и графикой. Вместе  они справились с  чрезвычайно трудной
                             задачей подготовки первого издания в исключительно короткие сро
                             ки, сохраняя то высокое качество, которое читатели ожидают от изда
                             тельства AddisonWesley. Они также отслеживали изменения в первое
                             время существования языка UML, когда все казалось нестабильным.
                             Джим Оделл был моим наставником и гидом в начале моей карьеры. Он
                             также глубоко вникал в технические и личные споры упрямых методо
                             логов, высказывавших свое несогласие или  сходство во  взглядах во
                             время становления единого стандарта. Его основательный вклад в эту















                        24                                                               От автора


                             книгу трудно измерить, и я готов поспорить, что его вклад в UML не
                             меньше.
                             UML – это порождение стандартов, а у меня на стандарты аллергия.
                             Поэтому, чтобы  знать, как идут дела, мне необходимо  иметь сеть
                             шпионов, которые держали бы меня в курсе всех происков комитетов.
                             Без этих шпионов, включая Конрада Бока (Conrad Bock), Стива Кука
                             (Steve Cook), Криса Кобрина (Cris Kobryn), Джима Одела (Jim Odell),
                             Гуса Ремакерса (Guus Ramackers) и Джима Рамбо (Jim Rumbaugh),
                             я оказался бы в затруднительном положении. Все они давали мне по
                             лезные советы и отвечали на глупые вопросы.
                             Гради  Буч (Grady  Booch), Айвар Джекобсон  (Ivar  Jacobson) и Джим
                             Рамбо (Jim Rumbaugh) известны как «трое друзей». Они много лет не
                             обращали внимания на мои выходки,  поддерживали и ободряли меня
                             во время работы над книгой. Помните, что мои колкости обычно вы
                             растают из нежной признательности.
                             Ключ к качеству книги – рецензенты, и от Картера я узнал, что их ни
                             когда не бывает слишком много. Рецензентами предыдущих изданий
                             этой книги  были Симми Коччар Баргава  (Simmi Kochhar Bhargava),
                             Гради Буч (Grady Booch), Эрик Эванс (Eric Evans), Том Хэдфилд (Tom
                             Hadfield), Айвар Джекобсон (Ivar Jacobson),  Рональд Джеффрис
                             (Ronald  E. Jeffries), Джошуа Кериевски (Joshua Kerievsky), Хелен
                             Клейн (Helen Klein), Джим Оделл (Jim Odell), Джим Рамбо (Jim Rum
                             baugh) и Вивек Салгар (Vivek Salgar).
                             У третьего издания также были прекрасные рецензенты:
                                Конрад Бок (Conrad Bock)
                                Энди Кармайкл (Andy Carmichael)
                                Алистер Кокбурн (Alistair Cockburn)
                                Стив Кук (Steve Cook)
                                Люк Гохман (Luke Hohmann)
                                Павел Хруби (Pavel Hruby)
                                Джон Керн (Jon Kern)
                                Крис Кобрин (Cris Kobryn)
                                Крейг Ларман (Craig Larman)
                                Стив Меллор (Steve Mellor)
                                Джим Оделл (Jim Odell)
                                Алан О’Каллахан (Alan O’Callaghan)
                                Гус Рамакерс (Guus Ramackers)
                                Джим Рамбо (Jim Rumbaugh)
                                Тим Зельтцер (Tim Seltzer)
                             Все рецензенты потратили  время  на чтение рукописи, и  каждый  из
                             них нашел по крайней мере по одной постыдной грубой ошибке. Мои
                             искренние благодарности им всем. Все оставшиеся грубые ошибки це
                             ликом на моей совести. Когда я их обнаружу, я помещу список исправ
                             лений в разделе книг сайта martinfowler.com.















                        От автора                                                              25


                             В основной состав команды, разработавшей и написавшей специфика
                             цию языка UML, входят Дон Бейсли (Don Baisley), Морган Бьеркандер
                             (Morgan Bjцrkander), Конрад Бок  (Conrad  Bock), Стив Кук (Steve
                             Cook), Филипп Десфрай (Philippe Desfray), Натан Дикман (Nathan
                             Dykman), Андерс Ек (Anders Ek), Дэвид Франкел (David Frankel), Еран
                             Гери (Eran  Gery), Ойстен Хаген  (Шystein Haugen), Шридхар Йенгар
                             (Sridhar Iyengar), Крис Кобрин (Cris Kobryn), Биргер МеллерПедер
                             сен (Birger MшllerPedersen), Джеймс Оделл (James Odell), Гуннар
                             Овергард (Gunnar  Цvergaard),  Карин Палмквист (Karin Palmkvist),
                             Гус Рамакерс (Guus Ramackers), Джим Рамбо (Jim Rumbaugh), Бран
                             Селик (Bran Selic), Томас Вейгерт (Thomas Weigert) и Ларри Вильямс
                             (Larry Williams). Без них я бы вряд ли чтонибудь написал.
                             Павел Хруби (Pavel Hruby) разработал несколько прекрасных шабло
                             нов для Visio, которые я использовал во многих диаграммах UML; их
                             можно найти на http://phruby.com.
                             Многие обращались ко мне по Сети и лично с предложениями и вопро
                             сами и с указаниями на ошибки. Я не смог ответить всем вам, но мои
                             благодарности не менее искренни.
                             Сотрудники моего любимого книжного магазина SoftPro в Верлингто
                             не, штат Массачусетс, предоставили возможность  наблюдать за  их
                             складом, что позволило мне узнать, как на практике люди используют
                             UML. Они угощали меня хорошим кофе, пока я был у них в гостях.
                             Ведущим редактором третьего  издания был Майк Хендриксон (Mike
                             Hendrickson). Ким Арни Малкахи (Kim Arney Mulcahy) руководил про
                             ектом, а также делал планировку и подчистку диаграмм. Джон Фул
                             лер из издательства AddisonWesley был выпускающим редактором, а
                             Эвелин Пиле (Evelyn Pyle) и Ребекка Райдер (Rebecca Rider) помогали
                             в редактировании и чтении корректуры книги. Я благодарю их всех.
                             Синди оставалась со мной все время, пока я упорно писал книгу. А по
                             том закапывала полученный гонорар в саду. Мои родители дали мне
                             хорошее образование – источник всего остального.

                             Мартин Фаулер
                             Мелроуз, Массачусетс
                             http://martinfowler.com






















                                                                                         1









                                                                                 Введение




                             Что такое UML?


                             Унифицированный язык моделирования (UML) – это семейство гра
                             фических нотаций, в основе которого  лежит единая метамодель. Он
                             помогает в описании и  проектировании программных систем, в осо
                             бенности систем, построенных с использованием объектноориентиро
                             ванных (ОО) технологий. Это определение в чемто упрощенное. В дей
                             ствительности разные люди могут видеть в UML разные вещи. Это яв
                             ляется следствием как собственной  истории развития языка, так
                             и различных точек зрения специалистов на то, что делает процесс раз
                             работки программного обеспечения эффективным. Поэтому моя зада
                             ча в этой главе во многом заключается в построении общей картины
                             книги и в объяснении различного видения и разнообразных способов
                             применения UML разработчиками.
                             Графические языки моделирования уже продолжительное время ши
                             роко используются в программной индустрии. Основная причина их
                             появления состоит в том, что языки программирования не обеспечива
                             ют нужный уровень абстракции, способный облегчить процесс проек
                             тирования.
                             Несмотря на то что графические языки моделирования существуют уже
                             достаточно давно, в  среде разработчиков программного обеспечения
                             очень много спорят об их роли. Эти споры оказывают непосредственное
                             влияние на восприятие разработчиками самого языка UML.
                             UML представляет  собой относительно открытый  стандарт,  находя
                             щийся под управлением группы OMG (Object Management  Group  –
                             группа управления объектами),  открытого консорциума  компаний.
                             Группа OMG была сформирована для создания стандартов, поддержи
                             вающих межсистемное взаимодействие, в частности взаимодействие
                             объектноориентированных систем. Возможно, группа OMG более из
                             вестна по стандартам CORBA (Common Object Request Broker Architec
                             ture – общая архитектура посредников запросов к объектам).















                        28                                                         Глава 1. Введение


                             UML появился в результате процесса унификации множества объектно
                             ориентированных языков графического моделирования, процветавших
                             в конце 80х и в начале 90х годов. Появившись в 1997 году, он отпра
                             вил эту Вавилонскую башню в вечность, за что я и многие другие разра
                             ботчики испытываем по отношению к нему глубокую благодарность.

                        Способы применения UML

                             Основу роли UML в разработке программного обеспечения составляют
                             разнообразные способы использования языка, те различия, которые
                             были перенесены из других языков графического моделирования. Эти
                             отличия вызывают долгие и  трудные дискуссии  о  том, как следует
                             применять UML.
                             Чтобы разрешить эту сложную ситуацию, Стив Меллор (Steve Mellor)
                             и я независимо пришли к определению трех режимов использования
                             UML разработчиками: режим эскиза, режим проектирования и режим
                             языка программирования. Безусловно, самый  главный из трех, по
                             крайней мере, на мой пристрастный взгляд, – это режим использова
                             ния UML для эскизирования. В этом режиме разработчики использу
                             ют UML для обмена информацией о различных аспектах системы. В
                             режиме проектирования можно использовать эскизы при прямой и об
                             ратной разработке. При прямой разработке (forward'engineering) диа
                             граммы рисуются до написания кода, а при обратной разработке (re'
                             verse'engineering) диаграммы строятся на основании исходного кода,
                             чтобы лучше понять его.
                             Сущность эскизирования, или эскизного моделирования, в избиратель
                             ности. В процессе прямой разработки вы делаете наброски отдельных
                             элементов программы, которую собираетесь написать, и обычно обсуж
                             даете их с некоторыми разработчиками из вашей команды. При этом
                             с помощью эскизов вы хотите облегчить обмен идеями и вариантами
                             того, что вы собираетесь делать. Вы обсуждаете не всю программу, над
                             которой намереваетесь работать, а только самые важные ее моменты,
                             которые вы хотите донести до коллег в первую очередь, или разделы
                             проекта, которые вы хотите визуализировать до начала программиро
                             вания. Такие совещания могут быть очень короткими: 10минутное со
                             вещание по нескольким часам программирования или однодневное со
                             вещание, посвященное обсуждению двухнедельной итерации.
                             При обратной разработке вы  используете  эскизы, чтобы  объяснить,
                             как работает некоторая часть системы. Вы показываете не все классы,
                             а только те, которые представляют интерес и которые стоит обсудить
                             перед тем, как погрузиться в код. Поскольку эскизирование носит не
                             формальный и динамичный характер и вам нужно делать это быстро
                             и совместно, то наилучшим средством отображения является доска.
                             Эскизы полезны также и в документации, при этом главную роль иг
                             рает процесс передачи информации, а не полнота. Инструментами эс
                             кизного моделирования служат облегченные  средства рисования, и















                        Способы применения UML                                                 29


                             часто разработчики не  очень  придерживаются всех строгих  правил
                             UML. Большинство диаграмм UML, показанных в этой книге, как и в
                             других моих книгах, представляют собой эскизы. Их сила в избира
                             тельности передачи информации, а не в полноте описания.
                             Напротив, язык UML как средство проектирования нацелен на пол
                             ноту. В  процессе  прямой  разработки  идея состоит в том, что проект
                             разрабатывается дизайнером,  чья  работа заключается в построении
                             детальной модели для программиста, который будет выполнять коди
                             рование. Такая модель должна быть достаточно полной в части зало
                             женных проектных  решений, а  программист  должен иметь возмож
                             ность следовать им прямо и не особо задумываясь. Дизайнером модели
                             может быть тот же самый программист, но, как правило, в качестве
                             дизайнера выступает старший  программист,  который разрабатывает
                             модели для команды программистов. Причина такого подхода лежит
                             в аналогии  с другими видами инженерной деятельности,  когда про
                             фессиональные инженеры создают чертежи, которые затем передают
                             ся строительным компаниям.
                             Проектирование может быть использовано для всех деталей системы
                             либо дизайнер может нарисовать модель какойто конкретной части.
                             Общий подход состоит в том, чтобы дизайнер разработал модели про
                             ектного уровня в виде интерфейсов подсистем, а затем дал возмож
                             ность разработчикам поработать над реализацией подробностей.
                             При обратной разработке цель моделей состоит в представлении по
                             дробной информации о программе или в виде бумажных документов,
                             или в виде, пригодном для интерактивного просмотра с помощью гра
                             фического броузера. В такой модели можно показать все детали класса
                             в графическом виде, который разработчикам проще понять.
                             При разработке моделей требуется более сложный инструментарий, чем
                             при составлении эскизов, так как необходимо поддерживать деталь
                             ность, соответствующую требованиям поставленной задачи. Специали
                             зированные CASEсредства (computeraided software engineering – авто
                             матизированная разработка программного обеспечения) попадают в эту
                             категорию, хотя сам этот термин стал почти ругательным, и поставщи
                             ки стараются его избегать. Инструменты прямой разработки поддержи
                             вают рисование диаграмм и копирование их в репозиторий с целью со
                             хранения информации. Инструменты обратного проектирования чита
                             ют исходный код, записывают его интерпретацию в репозиторий и гене
                             рируют диаграммы. Инструменты,  позволяющие  выполнять как
                             прямую, так и обратную разработку,  называются  двухсторонними
                             (round'trip).
                             Некоторые средства используют исходный код  в качестве  репозито
                             рия, а диаграммы используют его для  графического представления.
                             Такие инструменты более тесно связаны с программированием и часто
                             встраиваются прямо в средства редактирования исходного кода. Мне
                             нравится называть их «тройными» инструментами.















                        30                                                         Глава 1. Введение


                             Граница между моделями и эскизами довольно размыта, но я думаю,
                             что различия остаются в  том, что  эскизы  сознательно выполняются
                             неполными, подчеркивая важную информацию, в то время как моде
                             ли нацелены на полноту, часто имея целью свести программирование
                             к простым и до некоторой степени механическим действиям. Короче
                             говоря, я бы определил эскизы как пробные элементы, а модели – как
                             окончательные.
                             Чем дольше вы работаете с UML, а программирование становится все
                             более механическим, тем очевиднее становится необходимость перехо
                             да к автоматизированному созданию программ. Действительно многие
                             CASEсредства так или иначе генерируют код, что позволяет автома
                             тизировать построение значительной части системы. В конце концов,
                             вы  достигнете  такой точки, когда сможете  описать с помощью  UML
                             всю систему и перейдете в режим использования UML в качестве язы'
                             ка программирования.  В такой среде разработчики рисуют диаграм
                             мы, которые компилируются прямо в исполняемый код, а UML стано
                             вится исходным кодом. Очевидно, что такое применение UML требует
                             особенно сложных инструментов. (Кроме того, нотации прямой и об
                             ратной разработки теряют всякий смысл, поскольку UML и исходный
                             код становятся одним и тем же.)
                             Один из интересных вопросов, касающихся UML как языка програм
                             мирования, – это вопрос о моделировании логики поведения. UML 2
                             предлагает три способа моделирования поведения: диаграммы взаимо
                             действия, диаграммы состояний и диаграммы деятельности. Все они
                             имеют своих сторонников в сфере программирования. Если UML добь
                             ется популярности как  язык программирования, то будет интересно
                             посмотреть, какой из этих способов будет иметь успех.
                             Другая точка зрения  разработчиков на  UML находится гдето между
                             его применением для концептуального моделирования и его примене
                             нием для моделирования программного обеспечения. Большинство
                             разработчиков  используют UML для моделирования  программного
                             обеспечения. С точки зрения программного обеспечения элементы UML
                             практически непосредственно отображаются в элементы программной
                             системы. Как мы увидим впоследствии, отображение отнюдь не озна
                             чает следование инструкциям, но когда мы используем UML, мы гово
                             рим об элементах программного обеспечения.
                             С концептуальной точки зрения UML представляет описание концеп
                             ций предметной области. Здесь мы не столько говорим об элементах
                             программного обеспечения,  сколько занимаемся созданием  словаря
                             для обсуждения конкретной предметной области.
                             Нет строгих правил выбора точки зрения. Поскольку проблему можно
                             рассматривать под разными углами зрения, то и способов применения
                             существует довольно много. Некоторые инструменты автоматически
                             преобразуют исходный код в диаграммы, трактуя UML как альтерна
                             тивный вид исходного кода. Это в большей степени программный ра
                             курс. Если же диаграммы UML применяются для того, чтобы проверить















                        Способы применения UML                                                 31


                                         Архитектура, управляемая моделью,
                                                   и исполняемый UML
                               Когда говорят о UML, часто упоминают об MDA (Model Driven Ar
                               chitecture – архитектура, управляемая моделью) [27]. По сути де
                               ла, MDA представляет собой стандартный подход к использованию
                               UML в качестве языка программирования; этот стандарт находит
                               ся под управлением группы OMG, как и сам UML. Создавая систе
                               му моделирования, соответствующую MDA, поставщики могут
                               разработать модели, способные работать и в MDAсовместимом ок
                               ружении.
                               Говоря об MDA, часто подразумевают и UML, поскольку MDA ис
                               пользует UML в качестве основного языка моделирования. Но, ко
                               нечно, вы не обязаны следовать MDA, применяя UML.
                               MDA разделяет процесс разработки на две основные части. Разра
                               ботчики  моделей представляют конкретное приложение, создавая
                               PIM (Platform Independent Model – модель, не зависящая от плат
                               формы). PIM – это модель UML, не зависящая от какойто конкрет
                               ной технологии. Затем инструменты могут превратить PIM в PSM
                               (Platform Specific Model – модель, зависящая от платформы). PSM –
                               это модель системы, нацеленная на определенную среду выполне
                               ния. Другие инструменты  берут  PSM и генерируют код для  этой
                               платформы. В качестве PSM можно использовать UML, но это не
                               обязательно.
                               Поэтому если вы хотите  создать  систему складского учета  с ис
                               пользованием MDA, вам придется начать с единой модели PIM ва
                               шей системы. Затем при желании запустить эту систему складско
                               го учета в J2EE или .NET вы должны будете использовать инстру
                               менты какихлибо  производителей для создания  двух  моделей
                               PSM – по одной на каждую из этих двух платформ.
                               Если процесс перехода от модели PIM к модели PSM и окончатель
                               ной программе полностью автоматизирован, то мы используем
                               UML в качестве языка программирования. Если на какомнибудь
                               этапе присутствует ручная обработка, то мы используем UML в ре
                               жиме проектирования.
                               Стив Меллор (Steve Mellor) долгое время активно работал в этой об
                               ласти и с недавнего времени  стал употреблять термин  исполняе'
                               мый UML (Executable  UML)  [32]. Исполняемый  UML похож  на
                               MDA, но использует немного другую терминологию. Точно так же
                               вы начинаете с модели, не зависящей от платформы, которая экви
                               валентна MDAмодели PIM. Однако на следующем этапе применя
                               ется компилятор модели (Model Compiler), для того чтобы за один
                               прием превратить UMLмодель в готовую к развертыванию систе
                               му;  поэтому модель PSM не нужна.  Как и  предполагает термин
                               компилятор, этот этап полностью автоматизирован.















                        32                                                         Глава 1. Введение


                               Компиляторы модели основаны на повторно используемых прото
                               типах.  Прототип  (archetype) описывает способ превращения ис
                               полняемого UML в соответствующую программную платформу.
                               Поэтому в случае с  системой  складского учета придется  купить
                               компилятор модели и два прототипа (J2EE и .NET). Примените эти
                               прототипы к вашему исполняемому UML, и у вас будет две версии
                               системы складского учета.
                               Исполняемый UML не использует полный стандарт UML; многие
                               конструкции языка считаются ненужными и не применяются. По
                               этому исполняемый UML проще, чем полный.
                               Все это звучит  хорошо,  но  насколько  это реалистично?  На  мой
                               взгляд, здесь есть два аспекта. Вопервых,  вопрос  об  инструмен
                               тах: достаточно ли они развиты, чтобы выполнить поставленную
                               задачу. Этот фактор со временем меняется; определенно, как я уже
                               писал, они не слишком широко применяются, и я не многие из них
                               видел в действии.
                               Более фундаментальным аспектом является сама идея применения
                               UML в качестве языка программирования. С моей точки зрения,
                               использовать UML как язык программирования стоит, только если
                               в  результате получается нечто  более продуктивное, чем в случае
                               применения другого языка программирования. Однако исходя из
                               своего опыта работы в различных графических средах разработки,
                               я не стал бы это утверждать. Даже если UML и более продуктивен,
                               надо еще накопить критическую массу пользователей, чтобы при
                               нять его в качестве основного направления. UML сам по себе пред
                               ставляет большое препятствие.  Подобно многим пользователям,
                               имеющим опыт работы с языком Smalltalk, я считаю его более про
                               дуктивным, чем многие современные основные языки. Но в настоя
                               щее время Smalltalk представляет только небольшую нишу в про
                               странстве языков, и я не наблюдаю большого количества проектов,
                               написанных на нем. Чтобы избежать судьбы языка Smalltalk, UML
                               должен быть счастливчиком, даже если он самый лучший.


                             и понять различные значения терминов «пул активов» (asset pool)
                             с группой бухгалтеров, то следует принять точку зрения значительно
                             более близкую к концептуальной.
                             В предыдущем издании  этой книги я разделил программную  точку
                             зрения на спецификацию (specification) и реализацию (implementa
                             tion). Сейчас я понял, что на практике довольно трудно провести меж
                             ду ними точную границу, поэтому чувствую, что не нужно больше бес
                             покоиться о различиях между ними. Однако я всегда был склонен в
                             своих диаграммах делать ударение на интерфейсе, а не на реализации.
                             Следствием различных способов применения UML является масса спо
                             ров о том, что означают диаграммы UML и как они связаны с осталь















                        Способы применения UML                                                 33


                             ным миром. Особенно это влияет на отношение между UML и исходным
                             кодом. Некоторые разработчики считают, что UML нужно применять
                             для создания модели, не зависящей от языка программирования, кото
                             рый используется для реализации проекта. Другие убеждены в том, что
                             модель, не зависимая от языка, – это оксюморон с выраженным ударе
                             нием на слово «морон» (moron – идиот).
                             Другое различие  во взглядах  относится  к  вопросу о сущности UML.
                             Помоему, большинство пользователей UML, особенно  создателей
                             эскизов, видят сущность UML в его диаграммах. Однако авторы UML
                             считают диаграммы вторичным, а  первичным признают метамодель
                             UML. Диаграммы же – лишь представление метамодели. Такая точка
                             зрения имеет  смысл также для  разработчиков, использующих  UML
                             в режиме проектирования и в режиме языка программирования.
                             Итак, всякий раз когда  вы читаете чтонибудь, относящееся к UML,
                             важно понимать точку  зрения автора.  Только тогда вы  сможете пра
                             вильно оценить эти часто горячие дискуссии, которые вызывает UML.
                             Написав это, я должен пояснить свои пристрастия. Практически вся
                             моя работа с UML посвящена созданию эскизов. Я считаю, что эскизы
                             UML полезны и в процессе прямой, и в процессе обратной разработки,
                             а также и с концептуальной точки зрения, и в программном ракурсе.
                             Я не любитель детальных моделей, созданных в процессе прямого про
                             ектирования, поскольку убежден, что они слишком трудно реализу
                             ются и замедляют процесс разработки. Создание моделей уровня ин
                             терфейсов подсистем вполне разумно, но даже в этом случае вы долж
                             ны быть готовы к изменению этих интерфейсов, когда разработчики
                             будут реализовывать взаимодействие интерфейсов. Значение моделей
                             в процессе обратной разработки зависит от того, как работает инстру
                             ментарий. Если он применяется в качестве динамического броузера,
                             то он может быть очень полезным; если же он генерирует большой до
                             кумент, то вся его работа сводится к пустому переводу бумаги.
                             Я считаю, что применение UML в качестве языка программирования –
                             удачная идея, но сомневаюсь, что он когданибудь будет широко ис
                             пользоваться в этом качестве. Я не уверен, что для большинства про
                             граммных задач графическое  представление  более продуктивно,  чем
                             текстовое, и даже если это так, то вряд ли такой язык получит широ
                             кое распространение.

                             В соответствии с моими пристрастиями эта книга посвящена, главным
                             образом, использованию  UML  для создания  эскизов. К счастью, это
                             имеет смысл при написании краткого руководства. Я не в состоянии
                             показать все возможности других режимов работы UML в книге тако
                             го объема, но эта небольшая книга является хорошим введением в дру
                             гие книги, которые могут решить эту задачу. Поэтому если вас интере
                             суют другие  режимы использования UML, я предлагаю считать  эту
                             книгу введением и обратиться к другим книгам, когда это будет необ















                        34                                                         Глава 1. Введение


                             ходимо. Для тех же, кого интересуют только эскизы, данное издание
                             может оказаться именно тем, что нужно.

                        Как мы пришли к UML

                             Надо признать, что я люблю историю. Мое любимое легкое чтение –
                             это хорошая историческая книга. Но я понимаю, что это нравится не
                             всем. Я говорю здесь об истории, поскольку считаю, что во многих от
                             ношениях трудно оценить место, занимаемое UML, не зная истории
                             его развития.
                             В 80х годах объекты начали выходить из исследовательских лабора
                             торий и  делать свои  первые шаги  в направлении «реального»  мира.
                             Язык Smalltalk был реализован на платформе, пригодной для практи
                             ческого использования; появился на свет и C++. В то же время разра
                             ботчики начали задумываться об объектноориентированных языках
                             графического моделирования.
                             Основные книги по объектноориентированным языкам графического
                             моделирования появились между 1988 и 1992 годами. Ведущими фи
                             гурами в этом деле были Гради Буч (Grady Booch) [5]; Питер Коуд (Pe
                             ter Coad)  [7],  [8]; Айвар Джекобсон (Ivar  Jacobson) (Objectory)  [24];
                             Джим Оделл (Jim Odell) [34]; Джим Рамбо (Jim Rumbaugh) (OMT) [38],
                             [39];  Салли Шлаер  (Sally Shlaer) и  Стив Mеллор (Steve  Mellor)  [41],
                             [42]; Ребекка ВирфсБрок (Rebecca WirfsBrock) (Responsibility Driven
                             Design) [44].
                             Каждый из перечисленных авторов в то время был неформальным ли
                             дером группы профессионалов, приверженцев этих идей. Все эти мето
                             ды были очень похожи, хотя между ними и существовали небольшие,
                             но нередко раздражающие отличия. Идентичные базовые концепции
                             обязательно проявлялись в самых разнообразных нотациях, которые
                             вызывали путаницу в головах моих клиентов.
                             В это горячее время о стандартизации говорили в той же степени, в ка
                             кой ее игнорировали. Команда из группы OMG пыталась разбираться
                             со стандартизацией, но в результате получала только письма с протес
                             тами от всех ведущих методологов. (Есть такой старый анекдот. Во
                             прос: В чем разница между методологом и террористом? Ответ: С тер
                             рористом можно вести переговоры.)
                             Катастрофическим событием, инициировавшим появление UML, ста
                             ли уход Джима Рамбо из GE и его встреча с Гради Бучем в Rational (те
                             перь  это  подразделение  IBM). С самого начала было ясно, что  союз
                                                                          1
                             Буч/Рамбо может создать критическую массу  этого бизнеса. Гради и
                             Джим провозгласили, что «война методов завершена – мы победили»,

                             1  Критическая масса (в маркетинге) – обязательный набор новшеств, кото
                                рые должны  быть присущи товару, чтобы он считался современным. –
                                Примеч. ред.















                        Как мы пришли к UML                                                    35


                             по существу заявляя, что они собираются достигнуть стандартизации,
                             пойдя по «пути Microsoft». Некоторые методологи проектирования
                             предложили создать антиБучевскую коалицию.
                             К  конференции  OOPSLA ’95 Гради и  Джим подготовили  свое первое
                             публичное описание их совместного метода – версию 0.8 документации
                             по  Унифицированному методу  (Unified Method). И что более сущест
                             венно, они объявили, что фирма Rational Software купила Objectory и
                             что Айвар Джекобсон должен присоединиться к Унифицированной ко
                             манде. Rational устроила шикарный прием, празднуя выход версии 0.8.
                             (Гвоздем программы  стало первое публичное выступление  поющего
                             Джима Рамбо; мы все надеемся, что оно также было и последним.)
                             На следующий год процесс стал более открытым. Группа OMG, кото
                             рая раньше в основном стояла в стороне, теперь стала играть активную
                             роль. Rational вынуждена была принять идеи Айвара, а также рабо
                             тать с другими партнерами. Более существенно то, что группа OMG ре
                             шила взять на себя ведущую роль.
                             Важно понять, почему вступила в дело группа OMG. Методологи про
                             ектирования, как и авторы книг, любят думать, что они важные пер
                             соны. Но я не думаю, что вопли авторов книг могут быть хотя бы услы
                             шаны группой OMG. Причиной участия группы OMG стали крики по
                             ставщиков программных средств. Поставщики испугались, что стан
                             дарт, контролируемый фирмой Rational, даст продуктам фирмы
                             неоправданное конкурентное преимущество. В результате производи
                             тели побудили группу OMG к действиям под флагом необходимости
                             взаимодействия CASEсистем. Это  был очень важный  аргумент,  по
                             скольку для группы OMG взаимодействие значило  очень  много. По
                             явилась идея создать язык UML, который бы позволил CASEсредст
                             вам свободно обмениваться моделями.
                             Мэри Лумис (Mary Loomis) и Джим Оделл возглавили инициативную
                             группу, созданную для решения поставленной задачи. Оделл дал ясно
                             понять, что готов предоставить свой метод для стандарта, но не желает
                             поддерживать стандарт, продиктованный фирмой Rational. В январе
                             1997 года различные организации представили на рассмотрение свои
                             предложения по стандартизации методов, которые бы способствовали
                             обмену моделями. Фирма Rational сотрудничала с несколькими орга
                             низациями и в соответствии со своим планом представила версию 1.0
                             документации по UML – первое создание, соответствующее имени
                             Унифицированный язык моделирования (Unified Modeling Language).
                             Затем последовал короткий период выкручивания рук, когда объеди
                             нялись различные предложения. Группа OMG приняла окончатель
                             ную версию 1.1 в качестве официального стандарта OMG. Позднее бы
                             ли созданы другие версии. Версия 1.2 была целиком косметическая,
                             версия 1.3 – более значимой. В версию 1.4 было введено множество де
                             тализированных понятий о компонентах и профилях, а в версию 1.5
                             добавили семантику действия.















                        36                                                         Глава 1. Введение


                             Когда  специалисты  говорят  о UML, они называют его  создателями
                             главным образом Гради Буча, Айвара  Джекобсона и Джима Рамбо.
                             Чаще всего их называют «Трое друзей» (Three Amigos), хотя шутники
                             любят опускать первый слог второго слова. Несмотря на то что они за
                             работали свое доброе имя в основном в связи с UML, я думаю, что не
                             совсем справедливо отдавать им всю славу. Нотация UML впервые бы
                             ла сформирована в Унифицированном методе Буча/Рамбо. С тех пор
                             была проведена большая работа в комитетах группы OMG. На этой ста
                             дии Джим Рамбо был лишь одним из тройки, которая выполнила свои
                             тяжелые обязательства. Я считаю, что основную благодарность за соз
                             дание UML заслужили именно члены комитета UML.

                        Нотации и метамодели

                             Язык UML в своем нынешнем состоянии определяет нотацию и мета
                             модель. Нотация представляет собой совокупность графических эле
                             ментов, которые применяются в моделях; она и есть синтаксис данно
                             го языка моделирования. Например, нотация диаграммы классов оп
                             ределяет способ представления таких элементов и понятий, как класс,
                             ассоциация и кратность.
                             Конечно, при этом возникает вопрос точного определения смысла ас
                             социации, кратности и даже класса. Общепринятое употребление этих
                             понятий предполагает некоторые неформальные определения, однако
                             многие разработчики испытывают потребность в более строгом опреде
                             лении.
                             Идея строгой спецификации и языков проектирования наиболее рас
                             пространена в области формальных методов. В таких методах модели
                             и спецификации представляются с помощью некоторых производных
                             средств исчисления предикатов. Соответствующие определения мате
                             матически строги и исключают неоднозначность. Однако эти опреде
                             ления нельзя считать универсальными. Даже если вы сможете дока
                             зать, что программа соответствует математической спецификации, не
                             существует способа доказать, что эта математическая спецификация
                             действительно удовлетворяет реальным требованиям системы.
                             Большинство графических языков моделирования являются отнюдь
                             не строгими; их нотация в большей степени апеллирует к интуиции,
                             чем к формальному определению. В целом это не выглядит таким уж
                             большим недостатком. Хотя подобные методы могут быть неформаль
                             ными, многие разработчики попрежнему считают их полезными, и
                             это нельзя не принимать во внимание.
                             Однако  методологи ищут способы  добиться большей строгости мето
                             дов, не жертвуя при этом их практической полезностью. Один из спо
                             собов заключается в определении некоторой метамодели – диаграммы
                             (как правило, диаграммы классов), определяющей понятия языка.















                        Нотации и метамодели                                                   37


                             На рис. 1.1 изображена небольшая часть метамодели языка UML, ко
                             торая показывает отношение между свойствами. (Этот фрагмент при
                             веден с единственной целью – дать лишь общее представление о том,
                             что такое метамодель. Я даже не буду пытаться давать здесь какиели
                             бо дополнительные пояснения.)


                                                     Свойство







                               Структурное                                 Свойство
                                 свойство                                  поведения
                                                                                0..1


                                                                        {ordered}  *

                                                                           Параметр

                             Рис. 1.1. Фрагмент метамодели UML

                             Насколько велико влияние метамодели на того, кто применяет соот
                             ветствующую нотацию при моделировании? Ответ зависит, главным
                             образом, от режима работы с языком. Создателя эскизов обычно это не
                             слишком волнует; проектировщика это должно беспокоить значитель
                             но больше. И это жизнено важно для тех, кто использует UML в каче
                             стве языка  программирования, поскольку метамодель определяет
                             абстрактный синтаксис данного языка.
                             В настоящее время многие люди, вовлеченные в разработку UML, ин
                             тересуются в основном метамоделью, в частности потому, что она важ
                             на при использовании UML и языка программирования. Вопросы но
                             тации часто стоят на втором месте, что важно помнить, если вы соби
                             раетесь поближе познакомиться с документацией по стандарту.
                             Когда вы глубже погрузитесь в изучение UML, то поймете, что  вам
                             требуется значительно больше, чем просто графическая нотация. Вот
                             почему инструменты UML так сложны.
                             В этой книге я не слишком строг. Я предпочитаю традиционные пути
                             и обращаюсь к вашей интуиции. Это естественно для такой маленькой
                             книжки, написанной автором, склонным, в основном, работать в ре
                             жиме эскизного моделирования.  Приверженцам большей строгости
                             следует обратиться к более обстоятельным трудам.















                        38                                                         Глава 1. Введение


                        Диаграммы UML

                             UML 2 описывает 13 официальных  типов диаграмм, перечисленных
                             в табл. 1.1,  классификация которых приведена на рис. 1.2. Хотя  эти
                             виды  диаграмм отражают  различные подходы многих специалистов
                             к UML и способ организации моей книги, авторы UML не считают диа
                             граммы центральной составляющей языка. Поэтому диаграммы опре
                             делены не очень строго. Часто вполне допустимо присутствие элемен
                             тов диаграммы одного типа в другой диаграмме. Стандарт UML указы
                             вает, что определенные элементы обычно рисуются в диаграммах соот
                             ветствующего типа, но это не догма.
                             Таблица 1.1. Официальные типы диаграмм UML
                              Диаграмма       Глава Цель                          Происхождение
                                              книги
                              Деятельности    11    Процедурное и параллельное    В UML 1
                                                    поведение
                              Классов         3, 5  Классы, свойства и отношения  В UML 1
                              Взаимодействия 12     Взаимодействие между объекта Диаграмма коопе
                                                    ми; акцент на связях          раций в UML 1
                              Компонентов     14    Структура и взаимосвязи между В UML 1
                                                    компонентами
                              Составных       13    Декомпозиция класса во время Новое в UML 2
                              структур              выполнения
                              Развертывания   8     Развертывание артефактов в узлы В UML 1
                              Обзора          16    Комбинация диаграммы после Новое в UML 2
                              взаимодействий        довательности и диаграммы дея
                                                    тельности
                              Объектов        6     Вариант конфигурации экземп Неофициально
                                                    ляров                         в UML 1
                              Пакетов         7     Иерархическая структура време Неофициально
                                                    ни компиляции                 в UML 1
                              Последователь  4     Взаимодействие между объекта В UML 1
                              ности                 ми; акцент на последовательно
                                                    сти
                              Конечных        10    Как  события изменяют объект В UML 1
                              автоматов             в течение его жизни
                              Временная       17    Взаимодействие между объекта Новое в UML 2
                                                    ми; акцент на синхронизации
                              Прецедентов     9     Как пользователи взаимодейст В UML 1
                                                    вуют с системой















                        Что такое допустимый UML?                                              39



                                                                  Диаграмма
                                                                    классов
                                                                                 Диаграмма
                                                                                 компонентов
                                              Диаграмма           Диаграмма
                                               структуры           составных
                                                                   структур
                                                                                 Диаграмма
                                                                                развертывания
                                                                  Диаграмма
                                                                   объектов
                                Диаграмма
                                                                                 Диаграмма
                                                                                   пакетов


                                                                   Диаграмма
                                                                  деятельности


                                                                   Диаграмма
                                                                  прецедентов


                                                                   Диаграмма
                                              Диаграмма
                                              поведения            конечных
                                                                   автоматов
                                                                                   Диаграмма
                                                                                последовательности



                                                                                Коммуникационная
                                                                                   диаграмма
                                                                Диаграмма
                                                               взаимодействия
                                                                                Диаграмма обзора
                                                                                 взаимодействий


                                                                                   Временная
                                                                                   диаграмма

                             Рис. 1.2. Классификация типов диаграмм UML

                        Что такое допустимый UML?

                             На первый взгляд, ответить на этот вопрос легко: допустимый UML –
                             это язык, определенный в соответствии со спецификацией. Однако на
                             практике ответ несколько сложнее.















                        40                                                         Глава 1. Введение


                             Существенным в вопросе является то, на каких правилах базируется
                             UML: описательных или предписывающих. Язык с предписывающи
                             ми правилами (prescriptive rules) управляется официальной основой,
                             которая устанавливает, что является, а что не является допустимым
                             языком, и какое значение вкладывается в понятие высказывания язы
                             ка. Язык с описательными правилами (descriptive rules) – это язык,
                             правила которого распознаются по тому, как люди применяют его на
                             практике. Языки программирования в основном имеют предписываю
                             щие правила, установленные комитетом по стандартам или основны
                             ми поставщиками, тогда как естественные языки, такие как англий
                             ский, в основном имеют описательные правила, смысл которых уста
                             навливается по соглашению.

                             UML – точный язык, поэтому можно было бы ожидать, что он основан
                             на предписывающих правилах. Но UML часто рассматривают как про
                             граммный эквивалент чертежей  из других инженерных дисциплин,
                             а эти чертежи основаны не на  предписывающих  нотациях. Никакой
                             комитет не говорит, какие символы являются законными в строитель
                             ной технической документации; эти нотации были приняты по согла
                             шению, как и в естественном языке. Стандарты сами по себе еще ниче
                             го не решают, поскольку те, кто работает в этой области, не смогут сле
                             довать всему, что указывают стандарты; это то же самое, что спраши
                             вать французов о французской академии наук. К тому же язык UML
                             настолько сложен, что стандарты часто можно трактовать поразному.
                             Даже ведущие специалисты по UML, которые рецензировали эту кни
                             гу, не согласились бы интерпретировать стандарты.
                             Этот вопрос важен и для меня, пишущего эту книгу, и для вас, приме
                             няющих язык UML. Если вы хотите понять диаграммы UML, важно
                             уяснить, что понимание стандартов – это еще не вся картина. Люди
                             принимают соглашения и в индустрии в целом, и в какихто конкрет
                             ных проектах. Поэтому, хотя стандарт UML и может быть первичным
                             источником информации по UML, он не должен быть единственным.
                             Моя позиция состоит  в том, что  для большинства людей UML имеет
                             описательные правила. Стандарт UML оказывает наибольшее влияние
                             на содержание UML, но это делает не только он. Я думаю, что особенно
                             верным это станет для UML 2, который вводит некоторые соглашения
                             по обозначениям, конфликтующие или с определениями UML 1, или
                             с использованием по соглашению, а также еще больше усложняет
                             язык. Поэтому в данной книге я стараюсь обобщить UML так, как я его
                             вижу: и стандарты, и применение  по соглашению.  Когда мне  прихо
                             дится указывать на некоторое отличие в этой книге, я буду употреб
                             лять термин применение по соглашению (conventional use), чтобы обо
                             значить то, чего нет в стандарте, но, как я думаю, широко применяет
                             ся. В случае если чтото соответствует стандарту, я буду употреблять
                             термин  стандартный  (standard) или  нормативный  (normative). (Нор
                             мативный – это термин, посредством которого люди обозначают утвер















                        Смысл UML                                                              41


                             ждение, которое вы должны подтвердить, чтобы оно соответствовало
                             стандарту. Поэтому выражение ненормативный UML – это своеобраз
                             ный способ сказать, что нечто совершенно неприемлемо с точки зре
                             ния стандарта UML.)
                             Рассматривая диаграмму UML, необходимо помнить, что основной
                             принцип UML заключается в том, что любая информация на конкрет
                             ной диаграмме может быть подавлена. Это подавление может носить
                             глобальный характер – скрыть все атрибуты – или локальный – не по
                             казывать какиенибудь конкретные классы. Поэтому по диаграмме вы
                             никогда не можете судить о чемнибудь по его отсутствию. Даже если
                             метамодель UML имеет поведение по умолчанию, например [1] для ат
                             рибутов, когда вы не видите эту информацию на диаграмме, это может
                             быть обусловлено либо поведением по умолчанию, либо тем, что она
                             просто подавлена.
                             Говоря это, следует  упомянуть,  что  существуют основные соглаше
                             ния, например о том, что многозначные свойства должны быть множе
                             ствами.
                             Не надо слишком зацикливаться на допустимом UML, если вы зани
                             маетесь эскизами или моделями.  Важнее составить хороший проект
                             системы, и  я предпочитаю иметь  хороший дизайн в недопустимом
                             UML, чем допустимый UML, но плохой дизайн. Очевидно, хороший
                             и допустимый предпочтительнее,  но лучше направить  свою энергию
                             на разработку хорошего проекта, чем беспокоиться о секретах UML.
                             (Конечно, в случае применения UML в качестве языка программиро
                             вания необходимо соблюдать стандарты, иначе программа будет рабо
                             тать неправильно!)


                        Смысл UML

                             Одним из затруднений в UML является то, что хотя спецификация по
                             дробно описывает определение правильно сформированного UML, но
                             этого недостаточно, чтобы определить значение UML вне сферы изы
                             сканного выражения «метамодель UML». Не существует формальных
                             описаний того, как UML отображается на конкретные языки програм
                             мирования. Вы не можете посмотреть на диаграмму UML и точно ска
                             зать, как будет выглядеть соответствующий код. Однако у вас может
                             быть приблизительное представление о виде программы. На практи
                             ке этого достаточно. Команды разработчиков часто формируют собст
                             венные локальные соглашения, и, чтобы их использовать, вам придет
                             ся с ними познакомиться.

                        UML не достаточно

                             UML предоставляет  довольно  большое количество различных  диа
                             грамм, помогающих описать  приложение, но это отнюдь  не полный















                        42                                                         Глава 1. Введение


                             список всех полезных диаграмм, с которыми вам, возможно, придется
                             работать. Во многих случаях полезными могут оказаться различные
                             диаграммы, и не надо избегать диаграмм, не имеющих отношения к
                             UML, если не нашлось диаграмм UML, подходящих для ваших целей.
                             На диаграмме потока экранов (рис. 1.3) показаны различные экраны
                             интерфейса пользователя  и способы перемещения по ним.  Я изучал
                             и использовал диаграммы потока экранов многие годы и не встречал
                             ничего, кроме очень приблизительных определений того, что они оз
                             начают. В UML нет ничего подобного этим диаграммам, но я попреж
                             нему считаю их очень полезными.


                                                                  WelcomeVisitors


                                                                                       !
                                                                                    ненор
                                                      навигация                    мативный


                                    RecentChanges                            Find Page




                                                                     подтверждение поиска

                                          для недавно измененных страниц
                                                                              SomeWikiPage


                                                             экран
                                                                                  кнопка сохранения


                                               Visual Tour                     Edit Page

                             Рис. 1.3. Неформальная диаграмма потока экранов для части wiki
                                     (http://c2.com/cgi/wiki)


                             В табл. 1.2 представлен другой мой любимец – таблица решений. Таб
                             лица решений – это хороший способ показать сложные логические ус
                             ловия.  Это можно реализовать  с  помощью диаграммы деятельности,
                             но как только вы выходите за рамки простых случаев, таблица реше
                             ний становится компактнее и проще для понимания. Как и диаграм
                             мы потока экранов, многие виды таблиц решений не представлены в
                             языке. Таблица 1.2 разделена на две части: логические условия, рас
                             положенные выше двойной черты,  и их результаты внизу таблицы.















                        С чего начать                                                          43


                             Каждый столбец  показывает,  как конкретная комбинация  условий
                             приводит к определенному множеству результатов.
                             Таблица 1.2. Таблица решений

                              Специальный клиент   X      X      Y       Y      N      N
                              Приоритетный заказ   Y      N      Y       N      Y      N
                              Международный заказYYNNNN
                              Плата                $150   $100   $70     $50    $80    $60
                              Предупредительный
                              сигнал               •••

                             В  разных книгах вы встретите различные варианты  таких вещей. Не
                             стесняйтесь пробовать приемы, которые кажутся вам подходящими для
                             вашего проекта. Если они работают, пользуйтесь  ими. Если нет – за
                             будьте о них. (Этот же совет, конечно, относится и к диаграммам UML.)

                        С чего начать

                             Никто, даже создатели UML, не понимают всего UML и не используют
                             все его возможности. Большинство разработчиков при работе задейст
                             вуют лишь небольшое подмножество  UML. Вы должны найти свое
                             подмножество, которое бы подходило для решения задач, стоящих пе
                             ред вами и вашими коллегами.
                             Тем, кто только начинает, я советую на первых порах сконцентриро
                             ваться на основных формах диаграмм классов и диаграмм последова
                             тельности. На мой взгляд, это наиболее общие и самые полезные типы
                             диаграмм.
                             Постигнув их суть, вы сможете приступить к применению более про
                             двинутых нотаций диаграмм классов и взглянуть на другие типы диа
                             грамм. Экспериментируйте с диаграммами и выясните, насколько они
                             полезны для вас. Не бойтесь отбросить любые из них, которые не ка
                             жутся вам полезными для вашей работы.

                        Где найти дополнительную информацию

                             Эта книга вовсе не является полным и окончательным справочным ру
                             ководством по языку UML, не говоря уже об объектноориентирован
                             ном анализе и проектировании. Существует много такого, о чем здесь
                             не говорится, и много полезного, что следует дополнительно прочесть.
                             По ходу рассмотрения отдельных  тем будут  упоминаться и другие
                             книги, к которым следует обратиться для получения более подробной
                             информации. Будут упомянуты некоторые основные книги о  языке
                             UML и объектноориентированном проектировании.















                        44                                                         Глава 1. Введение


                             Рассматривая рекомендации всех книг, необходимо проверять версии
                             UML, для которых они написаны. Что касается июня 2003 года, то на
                             этот момент нет опубликованных книг, использующих UML 2.0, что
                             вряд ли может удивить, поскольку едваедва высохли чернила на тек
                             сте стандарта. Предлагаемые мной книги хороши, но я не могу утвер
                             ждать, что они будут обновлены в соответствии со стандартом UML 2.
                             Если вы новичок в обращении с объектами, то я рекомендую обратить
                             ся к моей любимой книге – [29]. Стоит принять на вооружение подход
                             автора к проектированию, который основан на строгом управлении от
                             ветственностями.
                             И в качестве  заключительного  источника  информации по UML по
                             смотрите официальные документы по стандартам, но помните, что они
                             написаны в соответствии с представлениями методологов в уединении
                             их личных каморок. Более удобоваримую версию стандарта можно по
                             смотреть в книге Рамбо [40].
                             Если вам нужна более подробная информация по объектноориентиро
                             ванному проектированию, то много  интересного вы найдете в книге
                             Мартина [30].
                             Я также  предлагаю  почитать  книги по  шаблонам, что позволит вам
                             выйти за пределы основ. Теперь, когда война методов закончена,
                             именно в области шаблонов (стр. 54) появляются интересные материа
                             лы по анализу и дизайну.






















                                                                                         2









                                                               Процесс разработки





                             Как я уже говорил, UML вырос из группы методов объектноориенти
                             рованного анализа и дизайна. До некоторой степени все они представ
                             ляют собой  комбинацию графического языка моделирования и  про
                             цесса, в котором определяются  подходы  к  разработке программного
                             обеспечения.
                             Интересно, что когда UML сформировался, многие участники обнару
                             жили, что хотя они и могут принять язык моделирования, но опреде
                             ленно не могут согласиться с процессом. В результате они согласились
                             перенести все соглашения по процессу на более позднее время и огра
                             ничить применение UML областью языка моделирования.
                             Эта книга называется «UML. Основы», поэтому я могу оставить в по
                             кое проигнорированный процесс. Однако я не думаю, что приемы мо
                             делирования имеют смысл без понимания того, как они соответствуют
                             процессу. Способы применения UML в значительной степени зависят
                             от типа процесса, с которым вы работаете.
                             Таким образом, я считаю, что необходимо сначала поговорить о про
                             цессе, чтобы вы смогли увидеть контекст использования UML. Я не со
                             бираюсь подробно описывать какойлибо конкретный процесс; я про
                             сто хочу дать вам достаточно информации, чтобы вы смогли увидеть
                             этот контекст, и показать, где вы можете узнать больше.
                             В беседах о UML можно часто услышать упоминание о RUP (Rational
                             Unified Process – унифицированный процесс,  созданный компанией
                             Rational). RUP – это один из процессов, точнее говоря, процессструк
                             тура, который вы можете использовать с UML. Но кроме общего уча
                             стия различных сотрудников фирмы Rational и названия «унифици
                             рованный», он не имеет  особенного  отношения к UML. Язык UML
                             можно использовать с любым процессом. RUP является популярным
                             подходом; он обсуждается на стр. 52.















                        46                                                Глава 2. Процесс разработки


                        Процессы итеративные и водопадные

                             Самая бурная дискуссия о процессах разворачивается вокруг выбора
                             между итеративной и водопадной моделями. Часто эти термины упо
                             требляются неправильно, в частности потому, что применение итера
                             тивного процесса вошло в моду, а водопадный процесс считается чем
                             то вроде брюк в  клеточку. В  результате процесс разработки многих
                             проектов объявляется итеративным, хотя в действительности он явля
                             ется процессом водопадного типа.
                             Существенная разница между двумя этими типами проявляется в том,
                             каким образом проект делится на более мелкие части. Если предпола
                             гается, что разработка проекта займет год, то мало кто сможет с лег
                             ким сердцем сказать людям, что им надо уйти на год и вернуться, ко
                             гда все будет сделано. Необходимо некоторое разделение, чтобы разра
                             ботчики смогли найти подход к решению проблемы и наладить работу.
                             При организации работы в стиле водопада проект делится на основа
                             нии вида работ. Чтобы создать программное обеспечение, необходимо
                             предпринять определенные действия: проанализировать требования,
                             создать проект, выполнить кодирование и тестирование. Наш годич
                             ный проект может включать двухмесячную фазу анализа, за которой
                             следует  четырехмесячная фаза дизайна, а  затем трехмесячная фаза
                             кодирования и, наконец, трехмесячная фаза тестирования.
                             Итеративный стиль делит проект по принципу функциональности про
                             дукта. Можно взять год и разделить  его на трехмесячные  итерации.
                             В первой итерации берется четверть требований  и выполняется  пол
                             ный цикл разработки  программного обеспечения  для этой  четверти:
                             анализ, дизайн, кодирование и тестирование. К концу первой итера
                             ции у вас есть система, обладающая четвертью необходимой функцио
                             нальности. Затем вы приступаете ко второй итерации и через шесть ме
                             сяцев получаете систему, делающую половину того, что ей положено.
                             Естественно, приведенное выше описание упрощено, но в этом состоит
                             суть различия. Конечно, на практике к течению процесса добавляются
                             непредвиденные вредные ручейки.
                             При разработке способом водопада после каждого этапа обычно в ка
                             комлибо виде выполняется формальная сдача, но часто имеет место
                             возвращение назад. В процессе кодирования могут выясниться обстоя
                             тельства, вынуждающие снова вернуться к этапам анализа и дизайна.
                             Конечно, в начале кодирования не следует думать, что анализ завер
                             шен. И решения, принятые на стадии анализа и дизайна, неизбежно
                             будут пересматриваться позднее. Однако эти обратные потоки пред
                             ставляют собой исключения и должны быть по возможности сведены
                             к минимуму.
                             При итеративном процессе разработки перед началом реальной итера
                             ции обычно  наблюдается некоторая исследовательская активность.















                        Процессы итеративные и водопадные                                      47


                             Как минимум на требования будет брошен поверхностный взгляд, до
                             статочный, по крайней мере, для разделения требований на итерации
                             для последующего выполнения. В процессе такого исследования могут
                             быть приняты некоторые решения по дизайну самого высшего уровня.
                             С другой стороны, несмотря на то что в результате каждой итерации
                             должно появиться  интегрированное  программное обеспечение, гото
                             вое к поставке, часто бывает, что оно еще не готово и нужен некоторый
                             стабилизационный период для исправления последних ошибок. Кро
                             ме того, некоторые виды работ, такие как тренировка пользователей,
                             оставляются на конец.
                             Конечно, вы вполне можете не  передавать систему на реализацию
                             в конце каждой итерации, но она должна находиться в состоянии про
                             изводственной готовности. Однако часто бывает, что система сдается
                             на регулярной основе; это хорошо, поскольку вы оцениваете работо
                             способность системы и получаете более качественную обратную реак
                             цию.  В этой ситуации часто говорят о проекте, имеющем несколько
                             версий, каждая из которых делится на несколько итераций.

                             Итеративную разработку называют  поразному: инкрементной, спи
                             ральной, эволюционной и  постепенной. Разные  люди вкладывают
                             в эти термины  разный смысл, но  эти различия не имеют широкого
                             признания и не так важны, как противостояние итеративного метода
                             и метода водопада.
                             Возможен и смешанный подход. В книге МакКоннелла [31] описыва
                             ется жизненный цикл поэтапной доставки (staged delivery), в соответ
                             ствии с которым сначала выполняются анализ и проектирование верх
                             него уровня в  стиле водопада,  а  затем кодирование и тестирование,
                             разделенные на итерации. В таком проекте может быть четырехмесяч
                             ный этап анализа и дизайна, а затем четыре двухмесячные итерации
                             построения системы.
                             Большинство авторов публикаций по процессу создания программно
                             го обеспечения, особенно принадлежащие к объектноориентирован
                             ному сообществу, последние пять лет испытывают неприязнь к подхо
                             ду в стиле водопада. Из всего множества причин этого явления самая
                             главная заключается в том, что при использовании метода  водопада
                             очень трудно утверждать, что разработка какогото проекта действи
                             тельно идет в верном направлении. Слишком легко объявить победу
                             на раннем этапе и скрыть ошибки планирования. Обычно единствен
                             ный способ, которым вы действительно можете показать, что следуете
                             по такому пути, состоит в том, чтобы получить протестированное, ин
                             тегрированное программное обеспечение. В случае итеративного про
                             цесса это повторяется многократно, и в результате, если чтото идет не
                             так, как надо, мы своевременно получаем соответствующий сигнал.
                             Хотя бы только по этой причине я настоятельно рекомендую избегать
                             метода водопада в чистом виде. По крайней мере, необходимо приме















                        48                                                Глава 2. Процесс разработки


                             нять поэтапную доставку, если невозможно  использовать итератив
                             ный метод в полном объеме.
                             Объектноориентированное сообщество долгое время было приверже
                             но итеративному способу разработки, и,  не боясь ошибиться,  можно
                             сказать, что значительная часть разработчиков, участвующих в созда
                             нии UML, предпочитают в том или ином виде итеративную разработ
                             ку. Однако, по моим ощущениям, в практике программной индустрии
                             метод водопада все еще занимает ведущее положение. Одну из причин
                             этого явления я называю псевдоитеративной разработкой: исполните
                             ли объявляют, что ведут итеративное проектирование, а на самом деле
                             действуют в стиле водопада. Основные симптомы этого следующие:
                             •  «Мы выполняем одну итерацию анализа, а затем две итерации про
                                ектирования…»
                             •  «Код данной итерации содержит много ошибок, но мы исправим их
                                в конце…»

                             Особенно важно, чтобы каждая итерация завершалась созданием про
                             тестированного, интегрированного  программного продукта, который
                             бы имел качество, как можно более близкое к качеству серийной про
                             дукции. Тестирование и интеграцию оценить труднее всего, поэтому
                             в конце разработки  проекта лучше  эти этапы не проводить. Процесс
                             тестирования следует организовать так, чтобы  любая  итерация, не
                             объявленная в плане как сдаточная, могла бы быть переведена в такой
                             статус без серьезных дополнительных усилий разработчиков.
                             Общим приемом при итеративной разработке является  упаковка по
                             времени (time boxing). Таким образом, итерация будет занимать фик
                             сированный промежуток времени. Если обнаружилось, что вы не в со
                             стоянии выполнить все, что планировали сделать за время итерации,
                             то необходимо выбросить некоторую функциональность из данной ите
                             рации, но не следует изменять дату исполнения. В большинстве проек
                             тов,  основанных на итеративном процессе, протяженность итераций
                             одинакова, и это позволяет вести разработку в постоянном ритме.
                             Мне нравится упаковка по времени, поскольку люди обычно испыты
                             вают трудности при сокращении функциональности. Регулярно прак
                             тикуясь в сокращении функциональности, они учатся делать осмыс
                             ленный выбор между изменением времени разработки и изменением
                             функциональности. Сокращение функциональности в ходе итерации
                             позволяет также людям научиться расставлять приоритеты между
                             требованиями к проекту.
                             Одним из наиболее общих аспектов итеративной разработки является
                             вопрос переделки. Итеративная разработка недвусмысленно предпо
                             лагает, что вы будете перерабатывать и удалять существующий код на
                             последней итерации проекта. Во многих областях человеческой дея
                             тельности, например в промышленном производстве, переделка счи
                             тается ущербом. Но создание программного обеспечения не похоже на















                        Прогнозирующее и адаптивное планирование                               49


                             промышленное производство – часто бывает выгоднее переработать
                             существующий код, чем латать код неудачно спроектированной про
                             граммы. Некоторые технические приемы способны оказать сущест
                             венную помощь, чтобы процесс переделки был более эффективным.
                             •  Автоматизированные регрессивные тесты  (automated regression
                                tests) позволяют быстро найти любые ошибки, внесенные в процессе
                                изменений. Семейство  оболочек тестирования xUnit представляет
                                наиболее подходящий инструмент для создания автоматизирован
                                ных тестов для модульной проверки (unit tests). Начиная с исход
                                ного JUnit http://junit.org, здесь есть порты для почти всех возмож
                                ных языков (http://www.xprogramming.com/software.htm). Хоро
                                шим правилом является создание модульных тестов примерно та
                                кого же размера, что и тестируемая программа.
                             •  Рефакторинг (refactoring) – это способ изменения существующего
                                программного продукта [20]. Механизм  рефакторинга основан  на
                                применении серии небольших, сохраняющих поведение трансфор
                                маций основного кода. Многие из этих трансформаций могут быть
                                автоматизированы (http://www.refactoring.com).
                             •  Последовательная интеграция  (continuous integration) сохраняет
                                синхронизацию действий разработчиков, объединенных в коман
                                ду, что позволяет избежать болезненных циклов интеграции [18].
                                В ее основе лежит полностью автоматизированный процесс построе
                                ния, который может  быть автоматически прекращен, как только
                                любой член команды начнет записывать код в базу. Предполагает
                                ся, что разработчики записывают код ежедневно, поэтому автома
                                тические сборки выполняются несколько раз в день. Процесс по
                                строения включает запуск большого блока автоматических регрес
                                сионных тестов, что позволяет быстро обнаружить и без труда ис
                                править любую несогласованность.
                             Все эти технические приемы пропагандировались  недавно в книге
                             «Extreme Programming» [2], хотя они применялись и раньше и могли
                             (и должны были) применяться, независимо от того, использовался ли
                             XP (eXtreme Programming) или какойлибо другой гибкий процесс.


                        Прогнозирующее и адаптивное планирование

                             Одна из причин, по которым метод водопада еще жив, заключается
                             в желании обеспечить  предсказуемость при создании программного
                             обеспечения. Ничто так не раздражает, как отсутствие точной оценки
                             стоимости создания программного продукта и сроков его разработки.
                             Прогнозирующий подход направлен на выполнение работы на началь
                             ном этапе  проекта, для того  чтобы лучше понять,  что  нужно делать
                             в дальнейшем. Таким образом, наступает момент, когда оставшуюся
                             часть проекта можно оценить с достаточной степенью точности. В про
                             цессе  прогнозирующего планирования  (predictive planning) проект















                        50                                                Глава 2. Процесс разработки


                             разделяется на две стадии. На первой стадии составляются планы, и
                             тут предсказывать трудно, но вторая стадия более предсказуема, по
                             скольку планы уже готовы.
                             При этом не надо все делить на белое и черное. В процессе выполнения
                             проекта вы постепенно добиваетесь большей предсказуемости. И даже
                             если у вас есть план, все может пойти не так, как вы спрогнозировали.
                             Вы просто ожидаете, что при наличии четкого плана отклонения будут
                             менее значительными.
                             Однако все еще идут острые дискуссии о том, много ли проектов могут
                             быть предсказуемыми. Сущность данного  вопроса состоит в анализе
                             требований. Одна из самых  существенных причин сложности про
                             граммных проектов заключается в трудности понимания требований
                             к программным системам. Большинство программных проектов под
                             вергаются существенному  пересмотру требований  (requirements
                             churn): изменению требований на поздней стадии выполнения проек
                             та. Такой пересмотр вдребезги разбивает основу прогнозов. Последст
                             вия пересмотра можно предотвратить, заморозив требования на ран
                             ней стадии проекта и не позволяя изменениям появляться, но это при
                             водит к риску поставить клиенту систему, которая больше не удовле
                             творяет требованиям пользователей.
                             Эта проблема приводит к двум различным вариантам действий. Один
                             путь – это направить больше усилий собственно на проработку требо
                             ваний. Другой путь состоит в получении более определенного множе
                             ства требований, чтобы сократить возможные изменения.
                             Приверженцы другой школы утверждают, что пересмотр требований
                             неизбежен, что во многих проектах трудно стабилизировать требова
                             ния в такой степени, чтобы имелась возможность использовать прогно
                             зирующее планирование. Это может быть либо следствием того, что ис
                             ключительно трудно представить, что может делать программный про
                             дукт, либо следствием того, что условия рынка диктуют непредсказуе
                             мые изменения. Эта школа поддерживает  адаптивное планирование
                             (adaptive planning) в соответствии с утверждением, что прогнозируе
                             мость  – это иллюзия. Вместо того чтобы  дурачить себя иллюзорной
                             предсказуемостью, мы должны повернуться лицом к  реальности  по
                             стоянных изменений и использовать такой подход в планировании,
                             при котором изменение в проекте считается величиной  постоянной.
                             Это изменение контролируется таким образом, чтобы в результате вы
                             полнения проекта поставлялось как можно лучшее программное обес
                             печение; но хотя проект и контролируем, предсказать его нельзя.
                             Различие между прогнозирующими и адаптивными проектами прояв
                             ляется разными путями, когда люди говорят о состоянии проекта. Ког
                             да утверждается, что выполнение проекта идет хорошо, поскольку ра
                             бота ведется в соответствии с планом, то имеется в виду метод прогно
                             зирования. При адаптивной разработке нельзя сказать «в соответствии
                             с планом», поскольку план все время меняется. Это не означает, что















                        Гибкие процессы                                                        51


                             адаптивные проекты не планируются; обычно планирование занимает
                             значительное время, но план трактуется как основная линия проведе
                             ния последовательных изменений, а не как предсказание будущего.
                             На основе прогнозирующего плана можно разработать контракт с фик
                             сированной функциональностью по  фиксированной  цене. В  таком
                             контракте точно указывается, что должно быть создано, сколько это
                             стоит и когда продукт будет поставлен. В адаптивном плане такое фик
                             сирование невозможно. Вы можете обозначить бюджет и сроки постав
                             ки, но вы не можете точно зафиксировать функциональность постав
                             ляемого продукта. Адаптивный контракт предполагает, что пользова
                             тели будут сотрудничать с командой разработчиков, чтобы регулярно
                             пересматривать требуемую функциональность и прерывать проект, ес
                             ли прогресс слишком незначителен. Как таковой процесс адаптивного
                             планирования может определять  проект  с переменными границами
                             функциональности по фиксированной цене.
                             Естественно, адаптивный подход  менее желателен, поскольку все
                             предпочитают большую предсказуемость программных проектов. Од
                             нако предсказуемость зависит от точности, корректности и стабильно
                             сти множества требований. Если вы не в состоянии стабилизировать
                             свои требования, то прогнозирующий план базируется на песке, а из
                             менения настолько значительны, что проект сбивается с курса. Отсю
                             да вытекают два важных совета.
                             1. Не составляйте прогнозирующий план до тех пор, пока не получите
                                точные и корректные требования и не будете уверены, что они не
                                подвергнутся существенным изменениям.
                             2. Если вы не можете получить точные, корректные и стабильные тре
                                бования, то используйте метод адаптивного планирования.
                             Предсказуемость и  адаптивность предоставляют  выбор жизненного
                             цикла. Адаптивное планирование совершенно определенно подразуме
                             вает итеративный процесс. Прогнозирующий план может быть выпол
                             нен любым из двух способов, хотя за его выполнением легче наблюдать
                             в случае применения метода водопада, или метода поэтапной поставки.

                        Гибкие процессы

                             За последние несколько лет вырос интерес к гибким процессам разра
                             ботки программного обеспечения. Гибкий (agile) – это широкий термин,
                             охватывающий большое количество процессов, имеющих общее множе
                             ство величин и понятий, определенных Манифестом гибкой разработки
                             программного обеспечения (Manifesto  of  Agile Software Development)
                             (http://agileManifesto.org). Примерами таких процессов являются XP
                             (Extreme Programming – экстремальное программирование), Scrum
                             (столкновение), FDD (Feature Driven Development – разработка, управ
                             ляемая возможностями), Crystal (кристалл) и DSDM (Dynamic Systems
                             Development Method – метод разработки динамических систем).















                        52                                                Глава 2. Процесс разработки


                             В терминах нашего  обсуждения  гибкие процессы  исключительно
                             адаптивны по своей природе. Они также имеют четкую ориентацию на
                             человека. Гибкие подходы предполагают, что наиболее важным фак
                             тором успешного завершения проекта является квалификация испол
                             нителей и их хорошая совместная работа с человеческой точки зрения.
                             Значимость процессов или инструментов, ими используемых, опреде
                             ленно стоит на втором месте.
                             Гибкие методы в основном направлены на использование коротких,
                             ограниченных по времени итераций, чаще всего заканчивающихся че
                             рез месяц или раньше. Поскольку их вклад в документацию невелик,
                             то  в гибком подходе  не предполагается применение UML в режиме
                             проектирования. Чаще всего UML используется в режиме эскизирова
                             ния и реже в качестве языка программирования.
                             В большинстве своем гибкие процессы не слишком формализованы.
                             Сильно формализованные  или тяжеловесные процессы имеют  много
                             документации и постоянный контроль во время выполнения проекта.
                             Гибкий подход предполагает, что формализм мешает проведению из
                             менений и  противоречит природе талантливых личностей.  Поэтому
                             гибкие процессы часто называют облегченными (lightweight). Важно
                             понимать, что недостаточная формализованность является следствием
                             адаптивности и  ориентации специалистов, а не фундаментальным
                             свойством.

                        Унифицированный процесс от Rational

                             Хотя унифицированный процесс, разработанный компанией Rational
                             (Rational Unified Process, RUP), не зависит от UML, их часто упомина
                             ют вместе. Поэтому я думаю, что будет уместно сказать здесь об этом
                             несколько слов.
                             Хотя RUP называется процессом, в действительности  это оболочка
                             процессов, предоставляющая словарь и свободную структуру для обсу
                             ждения процессов. В случае применения RUP в первую очередь необ
                             ходимо выбрать шаблон разработки (development case) – процесс, ко
                             торый вы собираетесь использовать в проекте.  Шаблоны  разработки
                             могут очень значительно варьироваться, поэтому не думайте, что ваш
                             шаблон разработки будет сильно похож на другие шаблоны. При выбо
                             ре  шаблона разработки сразу требуется  человек, хорошо знакомый
                             с RUP, – тот, кто сможет приспособить RUP к определенным требова
                             ниям проекта. В качестве альтернативы существует постоянно увели
                             чивающийся набор распределенных по пакетам шаблонов разработки,
                             с которых можно начать.
                             Независимо от шаблона разработки RUP по существу является итера
                             тивным процессом. Метод водопада не совместим с философией RUP,
                             хотя с прискорбием должен отметить, что проекты, в которых приме
                             няются процессы в стиле водопада, нередко обряжают в одежды RUP.















                        Настройка процесса под проект                                          53


                             Все RUPпроекты должны иметь четыре фазы.
                             1. Начало  (inception).  На этой  стадии осуществляется первичная
                                оценка проекта. Обычно именно здесь вы решаете, стоит ли вкла
                                дывать средства в фазу уточнения.
                             2. Уточнение (elaboration). На этой стадии идентифицируются основ
                                ные прецеденты проекта и в итеративном процессе создается про
                                граммное обеспечение, для того чтобы развернуть архитектуру сис
                                темы. В конце фазы уточнения у вас должно быть достаточно пол
                                ное понимание требований и скелет работающей системы, которую
                                можно взять за основу разработки. В частности, необходимо обна
                                ружить и разрешить основные риски проекта.
                             3. На стадии построения (construction) продолжается процесс созда
                                ния и разрабатывается функциональность, достаточная для выпус
                                ка продукта.
                             4. Внедрение (transition) состоит из различных стадий работы, выпол
                                няемых  в  конце и в неитеративном режиме.  Они могут  включать
                                развертывание в информационном центре, обучение пользователей
                                и тому подобное.
                             Между фазами существует полная неопределенность, особенно между
                             уточнением и построением.  Для когото  переход  к  построению – это
                             момент, когда можно переключиться в режим прогнозирующего пла
                             нирования. А для когото это просто точка, в которой появляется яс
                             ное понимание требований и архитектуры, определение которой, как
                             вам кажется, движется к завершению.
                             Иногда RUP называют просто унифицированным процессом (Unified
                             Process, UP). Так обычно поступают организации, которые хотят при
                             менить терминологию и общий подход RUP, но не хотят пользоваться
                             лицензионными продуктами фирмы Rational Software. Можно думать
                             о RUP как  о продукте фирмы Rational, основанном  на UP, а можно
                             считать RUP и UP одним и тем же. В обоих случаях вы найдете людей,
                             которые с вами согласятся.

                        Настройка процесса под проект

                             Программные проекты значительно отличаются друг от друга. Способ,
                             которым ведется разработка программного обеспечения,  зависит от
                             многих факторов: типа создаваемой системы, используемой техноло
                             гии, размера и распределенности команды, характера рисков, послед
                             ствий неудач, стиля работы в команде и культуры организации. По
                             этому не следует ожидать, что найдется процесс, подходящий для всех
                             проектов.
                             Следовательно, необходимо приспособить процесс, чтобы он соответст
                             вовал вашему конкретному окружению. Один из первых шагов, кото
                             рые необходимо сделать, – это взглянуть на проект и выбрать наиболее















                        54                                                Глава 2. Процесс разработки


                             подходящие процессы. Таким образом, вы получите короткий список
                             процессов.
                             Затем необходимо определить, что следует предпринять, чтобы на
                             строить процесс под конкретный проект. При этом надо соблюдать ос
                             торожность. Некоторые процессы трудно оценить, не поработав с ни
                             ми. В таких случаях лучше провести с новым процессом пару итера
                             ций, чтобы понять, как он функционирует. Затем можно начинать мо
                             дифицировать процесс. Если вы с самого начала знаете, как работает
                             процесс, то можно модифицировать его без предварительной подготов
                             ки. Помните, что, как правило, легче начинать с малого и понемногу
                             добавлять, чем сделать слишком много, а потом чтото выбрасывать.

                                                          Шаблоны
                               UML говорит, как изобразить объектноориентированный дизайн.
                               Напротив, шаблоны представляют результат: примеры дизайна.
                               Многие утверждают, что в процессе выполнения проектов появля
                               ются трудности, поскольку исполнители не так сведущи в дизайне,
                               который хорошо известен более подготовленным разработчикам.
                               Шаблоны описывают общие подходы к работе, и они собираются
                               людьми, которые обнаруживают повторяющиеся темы в процессе
                               дизайна. Эти люди берут каждую такую тему и описывают ее так,
                               чтобы другие разработчики смогли прочитать шаблон и узнать спо
                               соб его применения.
                               Рассмотрим пример. Предположим, что у вас есть некоторые объек
                               ты, запускаемые в процессе на рабочем столе, и они должны взаи
                               модействовать с другими объектами, запускаемыми во втором про
                               цессе. Возможно, второй процесс располагается также на вашем ра
                               бочем столе; возможно, он располагается в другом месте. Объекты
                               вашей системы не должны искать другие процессы в сети или вы
                               полнять удаленные вызовы процедур.
                               Для удаленного объекта можно создать объектпосредник внутри
                               локального процесса. Посредник имеет тот же самый интерфейс,
                               что и удаленный объект. Локальный объект общается с посредни
                               ком при помощи рассылки обычных сообщений внутри процесса.
                               При этом посредник отвечает за передачу сообщений реальному
                               объекту независимо от его местоположения.
                               Создание посредника – это обычная практика в сетевом взаимодей
                               ствии и в других областях. Специалисты имеют большой опыт ра
                               боты  с посредниками,  знают, как  их применять, какие это дает
                               преимущества и как их реализовать, какие им свойственны огра
                               ничения. Эти навыки обсуждаются в методических изданиях, по
                               добных этому;  все они рассказывают,  как можно  схематически
                               представить посредника, и хотя это полезно, но не так, как было
                               бы полезно рассмотрение опыта использования посредника.















                        Настройка процесса под проект                                          55


                               В начале 90х годов специалисты начали приобретать такой опыт.
                               Они образовали сообщество людей, заинтересованных в написании
                               шаблонов. Эти специалисты спонсировали ряд конференций и вы
                               пустили несколько книг.
                               Наиболее известной публикацией по шаблонам, выпущенной этой
                               группой, является книга «банды четырех» [21], в которой подробно
                               рассмотрены 23 шаблона дизайна. Посредникам в этой книге по
                               священ десяток страниц, дающих детальное представление о том,
                               как объекты работают друг с другом; кроме того, обсуждаются пре
                               имущества и ограничения шаблонов, общие варианты использова
                               ния и советы по реализации шаблонов.
                               Шаблон – это больше, чем модель. Шаблон должен также включать
                               обоснование выбранного пути. Часто говорят, что шаблон – это ключ
                               к решению проблемы. Шаблон должен четко идентифицировать
                               проблему, объяснить, почему он решает проблему, а также объяс
                               нить, при каких условиях шаблон работает, а при каких нет.
                               Шаблоны важны, поскольку  они являются следующим этапом
                               в понимании основ языка или технологии моделирования. Шабло
                               ны предоставляют набор решений, а также показывают, что помо
                               гает создать хорошую модель и какова последовательность дейст
                               вий при разработке модели. Шаблоны учат на примерах.
                               Когда я начинал, меня удивляло, почему я должен все изобретать
                               с нуля. Почему у меня нет руководства, в котором бы рассказыва
                               лось о том, как делать общие вещи? Сообщество пытается создать
                               такую книгу.
                               В  настоящее  время издано множество книг по шаблонам, и они
                               очень отличаются по качеству. Мои любимые – это [21], [36], [37],
                               [13], [35] и, извините за нескромность, [16] и [19]. Кроме того, вы
                               можете зайти на домашнюю страничку шаблонов: http://www.hill'
                               side.net/patterns.

                             Как бы ни были вы вначале уверены, что знаете свой процесс, очень
                             важно, чтобы по мере продвижения вперед вы учились. Действитель
                             но,  одно из больших  преимуществ  итеративной разработки состоит
                             в возможности часто совершенствовать процесс.
                             В конце каждой итерации следует проводить ее ретроспективный ана
                             лиз  (iteration retrospective), собирая команду  на  совещания, чтобы
                             рассмотреть, как идут дела и что можно улучшить. Если итерация ко
                             роткая, то достаточно двух часов. При этом хорошо составить список
                             из трех категорий:
                             1. Сохранить: все, что работало правильно, и вы хотите это продол
                                жить.
                             2. Проблемы: разделы, которые работали неправильно.
                             3. Испытать: изменения в процессе с целью его улучшения.















                        56                                                Глава 2. Процесс разработки


                             Вы можете начинать ретроспективный анализ каждой итерации, рас
                             сматривая элементы предыдущей сессии и определяя их изменения.
                             Не забудьте про список того, что нужно сохранить; важно отслеживать
                             элементы, которые работают правильно. Если вы этого не делаете, то
                             можете потерять ощущение перспективы проекта и, возможно, пере
                             стать обращать внимание на успешные приемы.
                             В конце разработки проекта или его основной версии можно провести
                             более формальный  ретроспективный анализ проекта  (project retro
                             spective), который может занять пару дней; более подробную инфор
                             мацию можно найти на http://www.retrospectives.com/ и в книге [26].
                             Больше всего меня раздражает, когда организации упорно игнориру
                             ют собственный опыт и постоянно совершают одни и те же ошибки.

                        Настройка UML под процесс

                             При рассмотрении графических языков моделирования обычно о них
                             думают в контексте водопадного процесса. Водопадный процесс, как
                             правило, сопровождается документами,  выступающими в качестве
                             прессрелизов между стадиями анализа, дизайна и кодирования. Час
                             то графические модели могут занимать основную часть этих докумен
                             тов. Действительно, многие из структурных методов 70х и 80х годов
                             часто говорят о моделях анализа и дизайна, подобных этой.
                             Независимо от того, применяете вы метод водопада или нет, так или
                             иначе  вы проводите анализ, дизайн, кодирование и тестирование.
                             Можно запустить итеративный проект с недельными итерациями, ко
                             гда каждую неделю работает метод водопада.
                             Использование UML не подразумевает обязательную разработку доку
                             ментов или загрузку сложных CASEсистем.
                        Анализ требований

                             В процессе  анализа  требований необходимо  понять,  что клиенты и
                             пользователи программного обеспечения ожидают от системы. В ва
                             шем распоряжении имеется множество приемов UML:
                             •  Прецеденты, которые описывают,  как люди взаимодействуют
                                с системой.
                             •  Диаграмма классов, которая строится с точки зрения концептуаль
                                ной перспективы и может служить хорошим инструментом для по
                                строения точного словаря предметной области.
                             •  Диаграмма деятельности, которая показывает рабочий поток орга
                                низации, способы  взаимодействия программного обеспечения и
                                пользователей. Диаграмма деятельности может показать контекст
                                для использования прецедентов, а также детали работы сложных
                                прецедентов.















                        Настройка UML под процесс                                              57


                             •  Диаграмма состояний, которая  может оказаться полезной, если
                                концепция имеет своеобразный жизненный цикл с различными со
                                стояниями и событиями, которые изменяют эти состояния.
                             Анализируя состояния, помните, что самое важное – это взаимодейст
                             вие с вашими пользователями и клиентами. Обычно это непрограмми
                             сты,  и они не  знакомы  с UML и  другими подобными  технологиями.
                             Несмотря на это я успешно применял перечисленные приемы при об
                             щении с  людьми, не имеющими инженерной  подготовки. Чтобы до
                             биться этого, надо свести количество нотаций к минимуму. Не следует
                             вводить элементы, специфичные для программной реализации.
                             Будьте готовы в любой момент отойти от правил UML, если это помо
                             жет улучшить взаимопонимание. Наибольший риск в случае примене
                             ния UML для анализа состоит в том, что вы строите диаграммы, не со
                             всем понятные специалистам  в конкретной предметной области. Та
                             кая диаграмма хуже,  чем  бесполезная; она лишь способна вселить
                             в разработчиков ложное чувство уверенности.

                        Проектирование

                             При разработке модели вы можете широко применять диаграммы.
                             Можно использовать больше нотаций и при этом быть более точным.
                             Вот некоторые полезные приемы:
                             •  Диаграммы классов с точки зрения программного обеспечения.
                                Они показывают классы программы и их взаимосвязи.
                             •  Диаграммы последовательности  для общих сценариев.  Правиль
                                ный подход состоит в извлечении наиболее важных и интересных
                                сценариев из прецедента, а также в использовании CRCкарточек
                                и диаграмм последовательности с целью понять, что происходит в
                                программе.
                             •  Диаграммы пакетов, показывающие высокоуровневую организа
                                цию программного продукта.
                             •  Диаграммы состояний для классов со сложным жизненным циклом.
                             •  Диаграммы развертывания, показывающие физическую конфигу
                                рацию программного обеспечения.
                             Многие из этих  приемов позволяют документировать  программное
                             обеспечение после его создания. Кроме того, это может помочь людям
                             сориентироваться в программе, если они ее не создавали и не знакомы
                             с кодом.
                             В рамках жизненного цикла метода водопада необходимо  создавать
                             эти диаграммы  и выполнять  различного рода действия (активности)
                             как часть конкретных фаз. Документы, создаваемые по окончании ка
                             койлибо фазы, обычно включают диаграммы для проведенных дейст
                             вий. Стиль водопада подразумевает применение UML в качестве инст
                             румента проектирования.















                        58                                                Глава 2. Процесс разработки


                             При итеративном подходе диаграммы UML могут выступать или как
                             модели, или как эскизы. В режиме проектирования  аналитические
                             диаграммы обычно создаются  в  рамках итерации, предшествующей
                             итерации построения функциональности. Каждая итерация не начи
                             нается с самого начала. Напротив, она модифицирует существующую
                             документацию, подчеркивая изменения, произошедшие в новой ите
                             рации.
                             Создание моделей обычно происходит на ранней стадии итерации и
                             может быть сделано по частям для различных разделов функциональ
                             ности, назначенной для данной итерации. Кроме того, итерация под
                             разумевает изменение существующей модели, а не построение каж
                             дый раз новой модели.
                             Применение UML в режиме эскизирования – более подвижный про
                             цесс. Один из подходов заключается в выделении пары дней в начале
                             итерации на создание эскизного дизайна для данной итерации. Можно
                             также проводить короткие сессии  проектирования в любой момент
                             в ходе итерации, устраивая короткие получасовые совещания всякий
                             раз, когда разработчики начинают спорить по поводу нетривиальной
                             функции.
                             В режиме проектирования вы ожидаете, что программная реализация
                             будет строиться в соответствии с диаграммами. Изменение модели сле
                             дует считать отклонением, которое требует, чтобы проектировщики,
                             создавшие эту модель, ее пересмотрели. Эскиз обычно трактуется как
                             первый срез дизайна. Если в ходе кодирования обнаруживается, что
                             эскиз не совсем точен,  то  разработчики  должны иметь  возможность
                             изменить  дизайн.  Разработчики, внедряющие дизайн, должны сами
                             решать,  стоит  ли устраивать широкую дискуссию,  чтобы понять  все
                             возможные варианты.

                             Относительно моделей у  меня есть свое собственное  мнение, которое
                             заключается в том, что даже хорошему проектировщику очень трудно
                             составить правильную модель. Я часто обнаруживаю, что моя собст
                             венная модель  не остается нетронутой по завершении кодирования.
                             И все же я считаю эскизы UML полезными, хотя не думаю, что их сле
                             дует возводить в абсолют.
                             В обоих  режимах имеет смысл  исследовать  несколько вариантов ди
                             зайна. Как правило, лучше просматривать варианты в режиме эскиз
                             ного моделирования, чтобы иметь возможность быстро создавать и из
                             менять варианты.  Выбрав дизайн,  вы можете либо  использовать  эс
                             киз, либо детально проработать его до уровня модели.

                        Документация

                             После создания программного обеспечения можно написать докумен
                             тацию на готовый продукт с помощью UML. Я считаю, что диаграммы
                             UML очень помогают понять систему в целом. Однако я должен под















                        Настройка UML под процесс                                              59


                             черкнуть, что не верю в возможность создания подробных диаграмм
                             всей системы. Процитирую Уорда Каннингема [14]:
                                   Тщательно отобранные и хорошо написанные заметки могут легко
                                   заменить традиционную обширную документацию. Последняя ред
                                   ко  проясняет суть вещей, за  исключением  отдельных аспектов.
                                   Выделите эти аспекты … и забудьте обо всем остальном.
                             Я  полагаю, что подробная  документация должна генерироваться на
                             основе программного кода  – так, как  это делает, например  JavaDoc.
                             Для того чтобы  подчеркнуть важные  концепции, необходимо  напи
                             сать дополнительную документацию. Можно считать ее составной ча
                             стью первого  этапа знакомства с  программой, предшествующего де
                             тальному изучению кода. Я предпочитаю представлять документацию
                             в виде текста, достаточно краткого, чтобы его можно было прочитать
                             за чашкой кофе, и снабженного диаграммами UML, придающими об
                             суждению наглядный характер. Очевидно, что составитель докумен
                             тации  должен решать, что важно, а  что нет, поскольку  разработчик
                             вооружен для этого значительно лучше, чем читатель.
                             Диаграмма пакетов представляет хорошую логическую маршрутную
                             карту системы. Эта диаграмма помогает понять логические блоки сис
                             темы, а также  обнаружить их взаимозависимости и  держать их под
                             контролем. Диаграмма развертывания (см. главу 8), которая показы
                             вает физическую картину системы  на верхнем уровне, также может
                             оказаться полезной на этой стадии.
                             Для каждого пакета я предпочитаю строить диаграмму классов. При
                             этом я не указываю каждую операцию в том или ином классе, а пока
                             зываю только важные свойства, которые помогают мне понять общую
                             картину. Такая диаграмма классов  служит своего рода  оглавлением
                             в виде графической таблицы.
                             Диаграмму классов  следует сопроводить несколькими  диаграммами
                             взаимодействий системы, которые  показывают наиболее  важные из
                             них. Повторюсь: правильный отбор очень важен; помните, что в доку
                             ментации такого типа полнота – враг понятности.
                             Если некоторый класс в течение своего жизненного цикла имеет слож
                             ное поведение, то для его описания я строю диаграмму конечного авто
                             мата (глава 10). Но делаю это только в случае достаточно сложного по
                             ведения, что, на мой взгляд, бывает очень редко.
                             В книге также часто встречаются фрагменты программного кода, важ
                             ные для понимания системы и профессионально написанные. Кроме
                             того, я использую диаграмму деятельности (глава 11), но только если
                             она обеспечивает мне лучшее понимание, чем сам код.
                             Сталкиваясь с повторяющимися понятиями, я описываю их при помо
                             щи шаблонов (стр. 54).
                             В документации важно отразить неиспользованные варианты дизайна
                             и пояснить, почему они были отброшены. Об этом часто забывают, но















                        60                                                Глава 2. Процесс разработки


                             такая информация может оказаться самой важной для ваших пользо
                             вателей.

                        Понимание унаследованного кода

                             Язык UML помогает вникнуть за пару дней в труднодоступную для по
                             нимания ветвь незнакомой программы. Построение эскиза ключевых
                             аспектов системы может действовать как графический запоминающий
                             механизм, который  помогает зафиксировать важную  информацию
                             о системе в процессе ее изучения. Эскизы ключевых классов и их наи
                             более важных взаимосвязей помогают пролить свет на происходящее.
                             Современные инструменты позволяют генерировать подробные  диа
                             граммы ключевых  разделов системы.  Не следует применять  эти ин
                             струменты для создания больших бумажных отчетов; лучше с их по
                             мощью вскрывать наиболее важные  пласты исследуемого программ
                             ного кода. Особенно радует, что есть возможность генерации диаграмм
                             последовательности, позволяющих проследить взаимодействие мно
                             жества объектов при реализации сложного метода.

                        Выбор процесса разработки

                             Я твердый  сторонник  итеративного  процесса разработки. Как я  уже
                             говорил в этой книге: «Применяйте итеративный метод разработки
                             только в проектах, которым вы желаете успеха».
                             Может быть, комуто покажется, что это болтовня, но с годами я ста
                             новлюсь все более агрессивным сторонником итеративной разработки.
                             При грамотном применении  она является весьма важным методом,
                             способным помочь в раннем выявлении возможных рисков и в улуч
                             шении управляемости процессом разработки. Однако это не означает,
                             что можно вовсе обойтись без руководства проектом (хотя, если быть
                             справедливым, я должен отметить, что некоторые используют ее
                             именно для этой цели). Итеративная разработка требует тщательного
                             планирования. Но это весьма надежный подход, и поэтому любая кни
                             га по объектноориентированной  разработке рекомендует его приме
                             нять – и не без основания.
                             Вы не должны удивляться, услышав, что я – как один из авторов Ма
                             нифеста по гибкой разработке  программного  обеспечения  (Manifesto
                             for Agile Software Development) – большой любитель гибких подходов.
                             У меня также накоплен большой положительный опыт в экстремаль
                             ном программировании (Extreme Programming), и я рекомендую вам
                             основательно познакомиться с этими технологиями.















                        Где найти дополнительную информацию                                    61


                        Где найти дополнительную информацию

                             Книги по процессам разработки программного обеспечения всегда бы
                             ли распространены, а расцвет гибкой разработки привел к появлению
                             множества новых публикаций. Моим любимым изданием по основным
                             аспектам процесса является книга [31]. В ней с практической точки
                             зрения рассмотрены многие моменты процесса разработки программ
                             ных продуктов и приведен большой перечень полезных приемов.
                             Хороший обзор дается в книгах представителей сообщества, поддер
                             живающего гибкие процессы, [9] и [22].  Много хороших советов по
                             применению UML в режиме гибкой разработки можно найти в [1].
                             Одним из наиболее популярных методов гибкой разработки является
                             XP (Extreme Programming – экстремальное программирование), в изу
                             чении которого помогут вебсайты http://xprogramming.com и http://
                             www.extremeprogramming.org. По XP написано множество  книг, вот
                             почему теперь я называю его бывшим легковесным методом. Обычно
                             изучение начинают с книги [2].
                             Хотя книга [3] посвящена XP, в ней подробно рассказывается о плани
                             ровании итеративных проектов.  Большую часть этой информации
                             можно найти и в других книгах по XP, но если вас интересует только
                             аспект планирования, то она будет хорошим выбором.
                             Дополнительную информацию по Rational Unified Process вы найдете
                             в книге [28] – моем любимом введении в данный вопрос.






















                             3









                             Диаграммы классов: основы




                             Если ктонибудь подойдет к вам в темном переулке и спросит: «Хотите
                             посмотреть  на диаграмму  UML?», знайте –  скорее всего, речь  идет
                             о диаграмме класса.  Большинство  диаграмм UML, которые я встре
                             чал, были диаграммами  классов. Помимо своего широкого  примене
                             ния диаграммы классов концентрируют в себе большой диапазон по
                             нятий моделирования. Хотя  их основные элементы  используются
                             практически всеми, более сложные элементы применяются не так час
                             то. Именно поэтому я разделил рассмотрение диаграмм классов на две
                             части: основы (данная глава) и дополнительные понятия (глава 5).
                             Диаграмма классов  описывает типы объектов системы  и  различного
                             рода статические  отношения, которые  существуют между  ними. На
                             диаграммах классов отображаются также свойства классов, операции
                             классов и ограничения, которые накладываются на связи между объек
                             тами. В UML термин функциональность (feature) применяется в каче
                             стве основного термина, описывающего и свойства, и операции класса.
                             На рис. 3.1 изображена типичная модель класса, понятная каждому,
                             кто имел  дело с  обработкой заказов  клиентов. Прямоугольники на
                             диаграмме представляют классы и разделены на три части: имя класса
                             (жирный шрифт), его атрибуты и его операции. На рис. 3.1 также по
                             казаны два вида связей между классами: ассоциации и обобщения.

                             Свойства

                             Свойства представляют структурную функциональность класса. В пер
                             вом приближении  можно рассматривать  свойства  как  поля класса.
                             Как мы увидим позднее, в  действительности это  не так  просто,  но
                             вполне приемлемо для начала.
                             Свойства представляют единое понятие, воплощающееся в двух совер
                             шенно различных сущностях: в атрибутах и в ассоциациях. Хотя на
                             диаграмме они выглядят совершенно поразному, в действительности
                             это одно и то же.















                        Атрибуты                                                               63



                                    Order                    кратность
                                                                            Customer
                              dateReceived: Date[0..1]
                              isPrepaid: Boolean[1]  *             1   name [1]
                              number: String [1]                       address [0..1]
                              price: Money
                                                                       getCreditRating(): String
                              dispatch               ассоциация
                              close
                                                     ограничение
                                    1
                                                                       обобщение       класс
                                          {если Order.customer.getCreditRating
                                          равен "poor", то Order.isPrepaid
                                          должен иметь значение true}
                              имя роли
                                                             Corporate Customer  Personal Customer
                                                   атрибуты
                                                             contactName       creditCardNumber
                                                             creditRating
                               lineItems  {ordered}  операции  creditLimit
                                       *
                                   Order Line                billForMonth(Integer)
                                                             remind()
                               quantity: Integer                            {getCreditRating() == "poor"}
                               price: Money
                                                                  *
                                                             salesRep  0..1
                                    *   имеющий направление
                                        навигации
                                                                 Employee
                                    1
                                    Product


                             Рис. 3.1. Простая диаграмма класса


                        Атрибуты

                             Атрибут описывает свойство в виде строки текста внутри прямоуголь
                             ника класса. Полная форма атрибута:
                                видимость имя: тип кратность = значение по умолчанию {строка свойств}
                             Например:
                                 имя: String [1] = "Без имени" {readOnly}
                             Обязательно только имя.
                             •  Метка  видимость обозначает, относится ли атрибут к открытым (+)
                                (public) или к закрытым () (private). Другие типы видимости обсу
                                ждаются на стр. 110.















                        64                                         Глава 3. Диаграммы классов: основы


                             •  Имя атрибута – способ ссылки класса на атрибут – приблизительно
                                соответствует имени поля в языке программирования.
                             •  Тип атрибута накладывает ограничение на вид объекта, который мо
                                жет быть размещен в атрибуте. Можно считать его аналогом типа
                                поля в языке программирования.
                             •  Кратность рассмотрена на стр. 65.
                             •  Значение по умолчанию представляет собой значение для вновь созда
                                ваемых объектов, если атрибут не определен в процессе создания.
                             •  Элемент  {строка  свойств} позволяет указывать дополнительные
                                свойства атрибута. В примере он равен {readOnly}, то есть клиенты
                                не могут изменять  атрибут.  Если он пропущен, то,  как правило,
                                атрибут можно модифицировать. Остальные строки свойств будут
                                описаны позже.

                        Ассоциации

                             Другая ипостась свойства –  это ассоциация. Значительная часть ин
                             формации, которую можно указать в атрибуте, появляется в ассоциа
                             ции. На рис. 3.2 и 3.3 показаны одни и те же свойства, представлен
                             ные в различных обозначениях.


                                         Order
                              + dateReceived: Date  [0..1]
                              + isPrepaid: Boolean  [1]
                              + lineItems: OrderLine [*]  {ordered}


                             Рис. 3.2. Представление свойств заказа в виде атрибутов

                                          0..1         *                    + isPrepaid
                                 Date                        Order                      Boolean
                                          + dateReceived                           1
                                                             1
                                               источник
                                                    цель
                                                                 lineItems
                                                            *   {ordered}
                                                           OrderLine

                             Рис. 3.3. Представление свойств заказа в виде ассоциаций

                             Ассоциация – это непрерывная линия между двумя классами, направ
                             ленная от исходного класса к целевому классу. Имя свойства (вместе
                             с кратностью) располагается на целевом конце ассоциации. Целевой















                        Кратность                                                              65


                             конец ассоциации указывает на класс, который является типом свой
                             ства. Большая часть информации в обоих представлениях одинакова,
                             но некоторые элементы отличаются друг от друга. В частности, ассо
                             циация может показывать кратность на обоих концах линии.
                             Естественно, возникает вопрос: «Когда следует выбирать то или иное
                             представление?». Как правило, я стараюсь обозначать при помощи ат
                             рибутов небольшие элементы, такие как даты или логические значе
                             ния, – главным образом, типы значений (стр. 101), – а ассоциации для
                             более значимых  классов, таких  как клиенты или заказы. Я  также
                             предпочитаю использовать прямоугольники классов для наиболее зна
                             чимых классов диаграммы, а ассоциации и атрибуты для менее важ
                             ных элементов этой диаграммы.

                        Кратность

                             Кратность  свойства обозначает  количество объектов, которые  могут
                             заполнять данное свойство. Чаще всего встречаются следующие крат
                             ности:
                             •  1 (Заказ может представить только один клиент.)
                             •  0..1 (Корпоративный клиент может иметь, а может и не иметь един
                                ственного торгового представителя.)
                             •  * (Клиент не обязан размещать заказ, и количество заказов не огра
                                ничено. Он может разместить ноль или более заказов.)
                             В  большинстве случаев кратности  определяются своими нижней и
                             верхней границами, например 2..4 для игроков в канасту. Нижняя
                             граница может быть нулем или положительным числом, верхняя гра
                             ница представляет  собой положительное число или * (без ограниче
                             ний). Если нижняя и верхняя границы совпадают, то можно указать
                             одно число; поэтому 1 эквивалентно 1..1. Поскольку это общий слу
                             чай, * является сокращением 0..*.
                             При рассмотрении атрибутов вам могут встретиться термины, имею
                             щие отношение к кратности.
                             •  Optional (необязательный) предполагает нулевую нижнюю границу.
                             •  Mandatory  (обязательный) подразумевает, что  нижняя граница
                                равна или больше 1.
                             •  Singlevalued (однозначный) – для такого атрибута верхняя грани
                                ца равна 1.
                             •  Multivalued  (многозначный) имеет в  виду, что верхняя граница
                                больше 1; обычно *.
                             Если свойство может иметь несколько значений, я предпочитаю упо
                             треблять множественную форму его имени. По умолчанию элементы
                             с множественной кратностью образуют множество, поэтому  если  вы
                             просите клиента разместить заказы, то они приходят не в произволь















                        66                                         Глава 3. Диаграммы классов: основы


                             ном порядке. Если порядок заказов в ассоциации имеет значение, то
                             в конце ассоциации необходимо добавить  {ordered}.  Если вы хотите
                             разрешить повторы, то добавьте {nonunique}. (Если желательно явным
                             образом показать значение по умолчанию, то можно использовать {un
                             ordered} и  {unique}.)  Встречаются также имена для unordered, non
                             unique, ориентированные на коллекции, такие как {bag}.
                             UML 1 допускал дискретные кратности, например 2,4 (означающую 2
                             или 4, как в случае автомобилей, до того как появились минивэны).
                             Дискретные кратности не были широко распространены, и в UML 2 их
                             уже нет.
                             Кратность атрибута по умолчанию равна [1]. Хотя это и верно для ме
                             тамодели, нельзя предполагать, что если значение кратности для ат
                             рибута на диаграмме опущено, то оно равно [1], поскольку информа
                             ция о кратности на диаграмме может отсутствовать. Поэтому я пред
                             почитаю  указывать кратность явным образом,  если эта  информация
                             важна.

                        Программная интерпретация свойств


                             Как и для других элементов UML, интерпретировать свойства в про
                             грамме можно поразному. Наиболее распространенным представле
                             нием является поле или  свойство языка программирования.  Так,
                             класс Order Line (Строка заказа), показанный на рис. 3.1, мог бы быть
                             представлен в Java следующим образом:

                                public class OrderLine...
                                  private int quantity;
                                  private Money price;
                                  private Order order;
                                  private Product product
                             В языке, подобном C#, который допускает свойства, это могло бы вы
                             глядеть так:
                                public class OrderLine ...
                                  public int Quantity;
                                  public Money Price;
                                  public Order Order;
                                  public Product Product;
                             Обратите внимание, что атрибут обычно соответствует открытым (pub
                             lic) свойствам в языке,  поддерживающем свойства,  но соответствует
                             закрытым  (private)  полям  в языке, в котором  такой поддержки нет.
                             В языке без свойств с полями можно общаться посредством методов
                             доступа (получение и установка). У атрибута только для чтения не бу
                             дет метода установки (в случае полей) или операции установки (в слу
                             чае свойства). Учтите, что если свойству не присвоить имя, то в общем
                             случае ему будет назначено имя целевого класса.















                        Программная интерпретация свойств                                      67


                             Применение закрытых полей является интерпретацией, ориентирован
                             ной сугубо на реализацию. Интерпретация, ориентированная в боль
                             шей степени на интерфейс, может быть акцентирована на методах до
                             ступа, а не на данных. В этом случае атрибуты класса Order Line могли
                             бы быть представлены следующими методами:

                                public class OrderLine...
                                  private int quantity;
                                  private Product product;
                                  public int getQuantity() {
                                    return quantity;
                                  }
                                  public void setQuantity(int quantity) {
                                    this.quantity = quantity;
                                  }
                                  public Money getPrice() {
                                    return product.getPrice().multiply(quantity);
                                  }
                             Здесь нет поля для цены – ее значение вычисляется. Но поскольку
                             клиенты класса  Order Line заинтересованы в этой информации, она
                             выглядит как  поле. Клиенты  не могут сказать, что  является  полем,
                             а что  вычисляется. Такое сокрытие информации представляет сущ
                             ность инкапсуляции.
                             Если атрибут имеет несколько значений, то связанные с ним данные
                             представляют собой  коллекцию. Поэтому  класс  Order (Заказ)  будет
                             ссылаться на коллекцию классов Order Line. Поскольку эта кратность
                             упорядочена (ordered), то и коллекция должна быть упорядочена (на
                             пример, List в Java или IList в .NET). Если коллекция не упорядочена,
                             то, строго говоря, она не должна иметь ярко выраженного порядка, то
                             есть должна быть представлена множеством, но большинство специа
                             листов реализуют неупорядоченные атрибуты также в виде списков.
                             Некоторые разработчики используют массивы, но  поскольку  UML
                             подразумевает неограниченность сверху, то я почти всегда для струк
                             туры данных применяю коллекцию.
                             Многозначные свойства имеют  интерфейс,  отличный от интерфейса
                             свойств с одним значением (в Java):

                                class Order {
                                  private Set lineItems = new HashSet();
                                  public Set getLineItems() {
                                    return Collections.unmodifiableSet(lineItems);
                                  }
                                  public void addLineItem (OrderItem arg) {
                                    lineItems.add (arg);
                                  }
                                  public void removeLineItem (OrderItem arg) {
                                    lineItems.remove(arg);
                                  }















                        68                                         Глава 3. Диаграммы классов: основы


                             В большинстве случаев значения многозначных свойств не присваива
                             ются прямо; вместо этого  применяются методы добавления  (add) и
                             удаления (remove).  Для  того  чтобы управлять своим свойством  Line
                             Items (Позиции заказов), заказ должен контролировать членство этой
                             коллекции; поэтому он не должен передавать незащищенную коллек
                             цию. В таких случаях я использовал представителя защиты, чтобы за
                             ключить коллекцию в оболочку только для чтения. Можно также реа
                             лизовать необновляемый итератор  или сделать копию. Конечно, так
                             клиентам удобнее модифицировать объектычлены, но они не должны
                             иметь возможность напрямую изменять саму коллекцию.
                             Поскольку многозначные  атрибуты  подразумевают коллекции, то
                             практически вы никогда не увидите классы коллекций на диаграмме
                             класса. Их можно увидеть только на очень низком уровне представле
                             ния диаграмм самих коллекций.
                             Необходимо крайне остерегаться классов, являющихся не чем иным,
                             как коллекциями полей и средствами доступа к ним. Объектноориен
                             тированное проектирование должно предоставлять объекты с богатым
                             поведением, поэтому они не должны просто обеспечивать данными
                             другие объекты. Если данные запрашиваются многократно с помощью
                             средств доступа,  то это  сигнал  к тому, что  такое поведение должно
                             быть перенесено в объект, владеющий этими данными.
                             Эти  примеры  также подтверждают тот факт, что  между UML и  про
                             граммой нет обязательного соответствия, однако есть подобие. Согла
                             шения,  принятые внутри команды разработчиков, приведут к более
                             полному соответствию.
                             Независимо от того, как реализовано свойство – в виде поля или как
                             вычисляемое значение, оно представляет нечто, что объект может все
                             гда предоставить. Не следует прибегать к свойству для моделирования
                             транзитного отношения, такого, когда объект передается в качестве
                             параметра  во время  вызова метода  и используется только в рамках
                             данного взаимодействия.

                        Двунаправленные ассоциации

                             До сих пор мы говорили об однонаправленных ассоциациях. К друго
                             му распространенному типу  ассоциаций относится двунаправленная
                             ассоциация, например, показанная на рис. 3.4.
                             Двунаправленная ассоциация – это пара свойств, связанных в противо
                             положных направлениях. Класс  Car  (Автомобиль) имеет свойство


                                              owner
                                  Person                               Car
                                              0..1
                                                               *
                             Рис. 3.4. Двунаправленная ассоциация















                        Двунаправленные ассоциации                                             69


                             owner:Person[1], а  класс  Person (Личность) имеет свойство  cars:Car[*].
                             (Обратите внимание, что я использовал множественную форму имени
                             свойства cars, а это соглашение общепринятое, но ненормативное.)
                             Обратная связь между ними подразумевает, что если вы следуете обо
                             им свойствам, то должны вернуться обратно к множеству, содержаще
                             му вашу исходную точку. Например, если я начинаю с конкретной мо
                             дели MG Midget, нахожу ее владельца, а затем смотрю на множество
                             принадлежащих ему машин, то оно должно включать модель Midget,
                             с которой я начал.
                             В качестве альтернативы маркировки ассоциации по свойству многие
                             люди, особенно если они имеют опыт моделирования данных, любят
                             именовать ассоциации с помощью глаголов (рис. 3.5), чтобы отноше
                             ние можно было использовать в предложении. Это вполне допустимо,
                             и можно добавить к  ассоциации стрелку, чтобы избежать неопреде
                             ленности.  Большинство разработчиков объектов предпочитают ис
                             пользовать имя свойства, так как оно больше соответствует функцио
                             нальным назначениям и операциям.
                             Некоторые разработчики тем или иным способом именуют каждую ас
                             социацию. Я предпочитаю давать  имя ассоциации, только если это
                             улучшает понимание. Слишком часто встречаются такие имена, как
                             «has» (имеет) или «is related to» (связан с).
                             На рис. 3.4  двунаправленная  природа ассоциации подчеркивается
                             стрелками на обоих концах ассоциации. На рис. 3.5 стрелок нет; в язы
                             ке UML эта форма применяется либо для обозначения двунаправлен
                             ной ассоциации, либо когда направление отношения не показывается.
                             Я предпочитаю обозначать двунаправленную ассоциацию с помощью
                             двойных стрелок.


                                                   Owns
                                  Person                               Car
                                              0..1
                                                               *
                             Рис. 3.5. Использование глагола (own – владеть) в имени ассоциации

                             Реализация двунаправленной ассоциации в языке программирования
                             часто представляет некоторую сложность, поскольку необходимо обес
                             печить синхронизацию обоих свойств.  В C# для реализации двуна
                             правленной ассоциации я делаю следующее:
                                class Car...
                                  public Person Owner {
                                    get {return__owner;}
                                    set {
                                     if (_owner != null) __owner.friendCars().Remove(this);
                                     __owner = value;
                                     if (_owner != null)__owner.friendCars().Add(this);















                        70                                         Глава 3. Диаграммы классов: основы


                                    }
                                  }
                                  private Person _owner;
                                ...
                                class Person ...
                                  public IList Cars {
                                    get {return ArrayList.ReadOnly(_cars);}
                                  }
                                  public void AddCar(Car arg) {
                                    arg.Owner = this;
                                  }
                                  private IList _cars = new ArrayList();
                                  internal IList friendCars() {
                                    //должен быть использован только Car.Owner
                                    return _cars;
                                  }
                                ....
                             Главное – сделать так, чтобы одна сторона ассоциации (по возможно
                             сти с единственным значением) управляла всем отношением. Для это
                             го ведомый конец (Person) должен предоставить инкапсуляцию своих
                             данных ведущему концу. Это приводит к добавлению в ведомый класс
                             не очень удобного метода, которого здесь  не должно  было бы быть
                             в действительности, если только язык не имеет более тонкого инстру
                             мента управления доступом. Я здесь употребил слово «friend» (друг)
                             в имени как намек на C++, где метод установки ведущего класса дей
                             ствительно был бы дружественным. Как и большинство кода, работа
                             ющего со свойствами, это стереотипный фрагмент, и поэтому многие
                             разработчики предпочитают получать его посредством различных спо
                             собов генерации кода.
                             В концептуальных моделях навигация не очень важна, поэтому в та
                             ких случаях я не показываю какихлибо навигационных стрелок.

                        Операции

                             Операции (operations) представляют собой действия, реализуемые не
                             которым классом. Существует  очевидное соответствие между опера
                             циями и методами класса. Обычно можно не показывать такие опера
                             ции, которые просто манипулируют свойствами, поскольку они и так
                             подразумеваются.
                             Полный синтаксис операций в языке UML выглядит следующим обра
                             зом:
                                видимость имя (список параметров) : возвращаемый тип {строка свойств}
                             •  Метка видимости обозначает, относится ли операция к открытым (+)
                                (public) или к закрытым () (private); другие типы видимости обсу
                                ждаются на стр. 110.















                        Операции                                                               71


                             •  Имя – это строка.
                             •  Список параметров – список параметров операции.
                             •  Возвращаемый тип – тип возвращаемого значения, если таковое есть.
                             •  Строка свойств – значения свойств, которые применяются к данной
                                операции.
                             Параметры в списке параметров обозначаются таким же образом, что
                             и для атрибутов. Они имеют вид:

                                направление имя: тип = значение по умолчанию
                             •  Имя, тип и значение по умолчанию те же самые, что и для атрибутов.
                             •  Направление обозначает, является ли параметр входным (in), вы
                                ходным (out) или тем и другим (inout). Если направление не указа
                                но, то предполагается in.
                             Например, в счете операция может выглядеть так:

                                + balanceOn (date: Date) : Money
                             В рамках концептуальной модели не следует применять операции для
                             спецификации интерфейса класса.  Вместо  этого используйте их для
                             представления главных  обязанностей класса, возможно, с помощью
                             пары слов, обобщающих ответственность в CRCкарточках (стр. 89).
                             По моему мнению, следует различать операции, изменяющие состоя
                             ние системы, и операции, не делающие этого. Язык UML определяет
                             запрос как некую операцию, результатом которой является некоторое
                             значение, получаемое от класса; при этом состояние системы не изме
                             няется, то есть данная операция не вызывает побочных эффектов. Та
                             кую операцию можно пометить строкой свойств {query} (запрос). Опе
                             рации, изменяющие состояние,  я называю  модификаторами, иначе
                             именуемые командами.
                             Строго говоря, различие между запросом и модификаторами состоит
                             в том, могут ли они изменять видимое состояние [33]. Видимое состоя
                             ние  –  это то,  что можно наблюдать извне.  Операция, обновляющая
                             кэш, изменит внутреннее состояние, но это не окажет никакого влия
                             ния на то, что видно снаружи.
                             Я считаю полезным выделение запросов, так как это позволяет изме
                             нить порядок выполнения запросов и не изменить при этом поведение
                             системы. Общепринято конструировать операции так, чтобы модифи
                             каторы не возвращали значение, – тогда можно быть уверенным в том,
                             что операции, возвращающие значения, являются запросами. [33] на
                             зывает  это принципом разделения  командызапроса. Делать так все
                             время не очень удобно, но необходимо применять этот способ так час
                             то, как только возможно.
                             Другие термины, с которыми иногда приходится сталкиваться, – это
                             методы  получения значения (getting methods)  и методы установки















                        72                                         Глава 3. Диаграммы классов: основы


                             значения (setting methods). Метод получения значения возвращает не
                             которое значение из поля (и не делает ничего больше). Метод установ
                             ки значения помещает некоторое значение в поле (и не делает ничего
                             больше). За пределами класса клиент не способен определить, являет
                             ся ли запрос методом получения значения или модификатор – методом
                             установки значений. Эта информация о методах является исключи
                             тельно внутренней для каждого из классов.
                             Существует еще различие между операцией и  методом.  Операция
                             представляет собой то, что вызывается объектом – объявление проце
                             дуры, тогда как метод – это тело процедуры. Эти два понятия различа
                             ют,  когда  имеют дело  с полиморфизмом. Если  у вас есть супертип
                             с тремя подтипами, каждый из которых переопределяет одну и ту же
                             операцию супертипа, то вы имеете дело с одной операцией и четырьмя
                             реализующими ее методами.
                             Обычно термины  операция  и  метод  употребляются как взаимозаме
                             няемые, однако иногда полезно их различать.

                        Обобщение


                             Типичный пример обобщения (generalization) включает индивидуаль
                             ного и корпоративного клиентов некоторой бизнессистемы. Несмотря
                             на определенные различия, у них много общего. Одинаковые свойства
                             можно поместить в базовый класс  Customer (Клиент, супертип), при
                             этом класс Personal Customer (Индивидуальный клиент) и класс Corpo
                             rate Customer (Корпоративный клиент) будут выступать как подтипы.
                             Этот факт служит объектом разнообразных интерпретаций в моделях
                             различных уровней. На концептуальном уровне мы можем утвер
                             ждать, что Корпоративный клиент представляет собой подтип Клиен
                             та, если все экземпляры класса Корпоративный клиент по определе
                             нию являются также экземплярами класса Клиент. Таким образом,
                             класс Корпоративный клиент представляет собой частную разновид
                             ность класса Клиент. Основная идея заключается в следующем: все,
                             что нам известно о классе Клиент (ассоциации, атрибуты, операции),
                             справедливо также и для класса Корпоративный клиент.
                             С точки зрения программного обеспечения очевидная интерпретация
                             наследования выглядит следующим образом: Корпоративный клиент
                             является подклассом класса Клиент. В основных объектноориентиро
                             ванных языках подкласс наследует всю функциональность суперклас
                             са и может переопределять любые методы суперкласса.
                             Важным принципом эффективного использования  наследования яв
                             ляется замещаемость. Мне необходимо иметь возможность подставить
                             Корпоративного клиента в любом месте программы, где требуется
                             Клиент, и при этом все должно прекрасно работать. По существу это
                             означает, что когда я пишу программу в предположении, что у меня
                             есть Клиент, то я могу свободно использовать любой подтип Клиента.















                        Примечания и комментарии                                               73


                             Вследствие полиморфизма Корпоративный клиент может реагировать
                             на определенные команды не так, как другой Клиент, но вызывающий
                             не должен беспокоиться об этом отличии. (Дополнительную информа
                             цию можно найти в главе «Liskov Substitution Principle (LSP)» (Прин
                             цип замещения Лисков) книги [30]).
                             Наследование представляет  собой  мощный механизм,  но оно  несет
                             с собой много такого, что не всегда является необходимым для дости
                             жения замещаемости. Вот хороший  пример: на заре существования
                             языка Java многим разработчикам не нравилась реализация встроен
                             ного класса Vector (Вектор), и они хотели заменить его чемнибудь по
                             легче. Однако единственным способом получения класса, способного
                             заменить Vector, было создание его подкласса, что означало наследова
                             ние множества нежелательных данных и поведения.
                             Замещаемые классы можно создавать при помощи массы других меха
                             низмов. Поэтому многие разработчики предпочитают различать созда
                             ние подтипа, то есть наследование интерфейса, и создание подкласса,
                             или наследование реализации. Класс – это подтип, если он может за
                             мещать свой супертип, в независимости от того, использует он насле
                             дование или нет. Создание подкласса используется как синоним обыч
                             ного наследования.
                             Существует достаточное количество  других механизмов, позволяю
                             щих создавать подтипы без создания  подклассов. Примером может
                             служить  реализация интерфейса (стр. 96) и множество стандартных
                             шаблонов разработки [21].

                        Примечания и комментарии

                             Примечания – это  комментарии на диаграммах. Примечания могут
                             существовать сами по себе или быть связаны пунктирной линией с эле
                             ментами, которые они комментируют (рис. 3.6). Они могут присутст
                             вовать на диаграммах любого типа.


                                                              Car
                              Включает пикапы
                              и универсалы,
                              но не мотоциклы

                             Рис. 3.6. Примечание используется как комментарий к одному
                                     или более элементам диаграммы

                             Иногда применять пунктирную линию неудобно изза невозможности
                             точного позиционирования конца линии. Поэтому по общепринятому
                             соглашению в конце линии размещается небольшая открытая окруж
                             ность. В некоторых случаях удобнее поместить однострочный коммен
                             тарий на элементе диаграммы, при этом в начале текста ставятся два
                             дефиса: .















                        74                                         Глава 3. Диаграммы классов: основы


                        Зависимость

                             Считается, что между двумя элементами существует зависимость (de
                             pendency), если изменения в  определении одного элемента (сервера)
                             могут вызвать изменения в другом элементе (клиенте). В случае клас
                             сов зависимости появляются по разным причинам: один класс посыла
                             ет сообщение другому классу; один класс владеет другим классом как
                             частью своих данных; один класс использует другой класс в качестве
                             параметра операции. Если класс изменяет свой интерфейс, то сообще
                             ния, посылаемые этому классу, могут стать недействительными.
                             По мере роста систем  необходимо  все более и более беспокоиться об
                             управлении зависимостями. Если зависимости выходят изпод конт
                             роля, то каждое изменение в системе оказывает действие, нарастаю
                             щее волнообразно по мере увеличения количества изменений. Чем
                             больше волна, тем труднее чтонибудь изменить.
                             UML позволяет изобразить зависимости между элементами всех типов.
                             Зависимости можно использовать всякий раз, когда  надо показать,
                             как изменения в одном элементе могут повлиять на другие элементы.
                             На рис. 3.7 показаны зависимости, которые можно обнаружить в мно
                             гоуровневом приложении. Класс  Benefits Window (Окно льгот) – это
                             пользовательский интерфейс, или класс представления, зависящий от
                             класса  Employee (Сотрудник). Класс  Employee – это  объект предметной
                             области, который представляет основное поведение системы, в данном
                             случае бизнесправила. Это означает, что если класс Employee изменяет
                             свой интерфейс, то, возможно, и класс Benefits Window также должен
                             измениться.

                                          клиент      сервер
                                                                                    Employee
                                                                                   Data Gateway
                                  Benefits                  Employee
                                  Window
                                                                                    Benefits
                                          зависимость                              Data Gateway

                             Рис. 3.7. Пример зависимостей

                             Здесь важно  то, что зависимость  имеет  только одно направление
                             и идет от класса представления к классу предметной области. Таким
                             образом, мы знаем, что имеем возможность свободно изменять класс
                             Benefits Window, не оказывая влияния на объект  Employee или  другие
                             объекты предметной области. Я понял, что строгое разделение логики
                             представления и логики предметной области, когда представление за
                             висит от предметной области, но не наоборот, – это ценное правило,
                             которому я должен следовать.















                        Зависимость                                                            75


                             Второй существенный момент этой диаграммы: здесь нет прямой зави
                             симости двух классов Data Gateway (Шлюз данных) от Benefits Window.
                             Если эти классы изменяются,  то,  возможно,  должен измениться и
                             класс Employee. Но если изменяется только реализация класса Employee,
                             а не его интерфейс, то на этом изменения и заканчиваются.
                             UML  включает  множество видов зависимостей, каждая с определен
                             ной семантикой и ключевыми словами. Базовая зависимость, которую
                             я здесь обрисовал, с моей точки зрения, наиболее полезна, и обычно
                             я использую ее без ключевых слов. Чтобы сделать ее более детальной,
                             вы можете добавить соответствующее ключевое слово (табл. 3.1).

                             Таблица 3.1. Избранные ключевые слова зависимостей
                              Ключевое слово        Значение
                              «call» (вызывать)     Источник вызывает операцию в цели
                              «create» (создавать)  Источник создает экземпляр цели
                              «derive» (производить)  Источник представляет собой производное цели
                              «instantiate»         Источник является экземпляром цели. (Обратите
                              (создать экземпляр)   внимание, что если источник является классом, то
                                                    сам класс является  экземпляром класса класс;  то
                                                    есть целевой класс – это метакласс)
                              «permit» (разрешать)  Цель разрешает источнику доступ к ее закрытой
                                                    функциональности
                              «realize» (реализовать)  Источник является реализацией спецификации
                                                    или интерфейса, определенного целью (стр. 96)
                              «refine» (уточнить)   Уточнение означает отношение между различными
                                                    семантическими уровнями;  например, источник
                                                    может быть классом разработки, а цель – соответст
                                                    вующим классом анализа
                              «substitute» (заместить)  Источник может быть заменен целью (стр. 72)
                              «trace» (проследить)  Используется,  чтобы отследить такие моменты,
                                                    как  требования к классам или как изменения од
                                                    ной ссылки модели влияют на все остальное
                              «use» (использовать)  Для реализации источника требуется цель

                             Базовая зависимость не является транзитивным отношением. Приме
                             ром транзитивного отношения может служить отношение «эта борода
                             больше». Если у Джима борода больше, чем у Гради, а борода Гради
                             больше бороды Айвара, то мы можем сделать вывод, что у Джима бо
                             рода больше, чем у Айвара. Некоторые типы зависимостей, такие как
                             замещение, являются транзитивными, но в большинстве случаев су
                             ществует значительное расхождение между прямыми и обратными за
                             висимостями, как показано на рис. 3.7.















                        76                                         Глава 3. Диаграммы классов: основы


                             Многие отношения UML предполагают  зависимость. Направленная
                             ассоциация от Order к Customer означает, что Order зависит от Customer.
                             Подкласс зависит от своего суперкласса, но не наоборот.
                             Вашим основным правилом должна стать минимизация зависимостей,
                             особенно когда они затрагивают значительную часть системы. В част
                             ности, будьте осторожны с  циклами,  поскольку они могут  привести
                             к циклическим изменениям. Я не слишком строго придерживаюсь
                             этого правила. Я не имею в виду взаимные зависимости между тесно
                             связанными классами, но стараюсь избегать циклов на более высоких
                             уровнях, особенно между пакетами.

                             Бесполезно пытаться показать все зависимости на диаграмме классов;
                             их слишком много,  и они слишком  сильно отличаются.  Соблюдайте
                             меру и показывайте только зависимости, относящиеся к конкретной
                             теме, о которой вы хотите сообщить. Чтобы понимать и управлять за
                             висимостями, лучше всего использовать для этого диаграммы пакетов
                             (стр. 114).
                             В самом общем случае я использую зависимости с классами для иллю
                             страции транзитивного отношения, такого, когда один объект переда
                             ется другому в качестве параметра. Иногда их применяют с ключевы
                             ми словами  «parameter» (параметр), «local» (локальный) и «global»
                             (глобальный). Эти ключевые слова можно увидеть  на  ассоциациях
                             в моделях UML 1, и в этом случае они обозначают транзитные связи,
                             а не свойства. Эти ключевые слова не входят в UML 2.
                             Зависимости можно обнаружить, просматривая программу, вот поче
                             му эти  инструменты идеальны для анализа зависимостей.  Примене
                             ние инструментария для обращения схем зависимостей – наиболее по
                             лезный способ применения этого раздела UML.

                        Правила ограничений


                             При построении диаграмм классов большая часть времени уходит на
                             представление различных ограничений. На рис. 3.1 показано, что За
                             каз (Order) может быть сделан только одним единственным Клиентом
                             (Customer). Из этой диаграммы классов также следует, что каждая Line
                             Item (Позиция заказа) рассматривается отдельно: вы можете заказать
                             40 коричневых, 40 голубых и 40 красных штучек, но не 120 штук во
                             обще. Далее диаграмма утверждает, что Корпоративные клиенты рас
                             полагают кредитами, а Индивидуальные клиенты – нет.
                             С помощью базовых конструкций ассоциации, атрибута и обобщения
                             можно сделать многое, специфицируя наиболее важные ограничения,
                             но этими средствами невозможно записать каждое ограничение. Эти
                             ограничения  еще нужно какимто образом отобразить,  и  диаграмма
                             классов является вполне подходящим местом для этого.















                        Когда применяются диаграммы классов                                    77


                             Язык UML разрешает использовать для описания ограничений все что
                             угодно. При этом необходимо лишь придерживаться правила: ограни
                             чения следует помещать в фигурные скобки ({}). Можно употреблять
                             разговорный язык, язык программирования или формальный объект
                             ный язык ограничений UML (Object Constraint Language, OCL) [43],
                             базирующийся на исчислении предикатов. Формальное написание по
                             зволяет избежать риска неоднозначного толкования конструкций раз
                             говорного языка. Однако это приводит к возможности недоразумений
                             изза непрофессионального владения OCL пишущими и читающими.
                             Поэтому до тех пор, пока ваши читатели не вполне овладеют исчисле
                             нием предикатов, я предлагаю говорить на обычном языке.
                             Если хотите, можете предварять ограничение именем с двоеточием,
                             например: {запрещение кровосмешения: муж и жена не должны быть
                             родными братом и сестрой}.

                        Когда применяются диаграммы классов

                             Диаграммы классов составляют фундамент UML, и поэтому их посто
                             янное применение  является  условием достижения успеха. Эта глава
                             посвящена основным понятиям, а многие более сложные материи об
                             суждаются в главе 5.
                             Трудность, связанная с диаграммами классов, заключается в том, что
                             они настолько обширны, что  их применение может  оказаться непо
                             мерно сложным. Приведем несколько полезных советов.
                             •  Не пытайтесь задействовать сразу все доступные понятия. Начните
                                с самых простых, описанных в этой главе: классов, ассоциаций, ат
                                рибутов, обобщений  и ограничений. Обращайтесь  к дополнитель
                                ным понятиям, рассмотренным в главе 5, только если они действи
                                тельно необходимы.
                             •  Я пришел к выводу, что концептуальные диаграммы классов очень
                                полезны при изучении делового языка. Чтобы при этом все получа
                                лось, необходимо всячески избегать обсуждения программного
                                обеспечения и применять очень простые обозначения.
                             •  Не надо строить модели для всего на свете,  вместо этого  следует
                                сконцентрироваться на ключевых аспектах.  Лучше создать мало
                                диаграмм, которые постоянно применяются в работе и отражают
                                все внесенные изменения, чем иметь дело с большим количеством
                                забытых и устаревших моделей.
                             Самая большая опасность, связанная с диаграммами классов, заклю
                             чается в том, что вы можете сосредоточиться исключительно на струк
                             туре и забыть о поведении. Поэтому, рисуя диаграммы классов для то
                             го, чтобы разобраться в программном обеспечении,  используйте  ка
                             киелибо формы анализа поведения. Если вы применяете эти методы
                             поочередно, значит, вы двигаетесь в верном направлении.















                        78                                         Глава 3. Диаграммы классов: основы


                                             Проектирование по контракту

                               Проектирование по контракту (Design by Contract) – это метод про
                               ектирования, являющийся центральным свойством языка Eiffel.
                               И метод, и язык разработаны Бертраном Мейером [33]. Однако про
                               ектирование по контракту не является привилегией только языка
                               Eiffel, этот метод можно применять и в любом другом языке про
                               граммирования.
                               Главной идеей проектирования по контракту  является понятие
                               утверждения. Утверждение (assertion) – это булево высказывание,
                               которое никогда не должно принимать ложное значение и поэтому
                               может быть ложным только в результате ошибки. Обычно утверж
                               дение проверяется только во время отладки и не проверяется в ре
                               жиме выполнения. Действительно при  выполнении программы
                               никогда не следует предполагать, что утверждение проверяется.
                               В методе проектирования по контракту определены утверждения
                               трех типов: предусловия, постусловия и инварианты. Предусловия
                               и постусловия применяются к операциям. Постусловие – это вы
                               сказывание относительно того, как будет выглядеть окружающий
                               мир после выполнения операции. Например, если мы определяем
                               для числа операцию  «извлечь квадратный корень»,  постусловие
                               может принимать форму input = result * result, где result является
                               выходом, а input – исходное значение числа. Постусловие – это хо
                               роший способ выразить, что должно быть сделано, не говоря при
                               этом, как это сделать. Другими словами, постусловия позволяют
                               отделить интерфейс от реализации.
                               Предусловие –  это высказывание  относительно того, как должен
                               выглядеть окружающий мир до выполнения операции. Для опера
                               ции «извлечь квадратный корень» можно определить предусловие
                               input >= 0. Такое предусловие утверждает, что применение опера
                               ции «извлечь квадратный корень» для отрицательного числа явля
                               ется ошибочным и последствия такого применения не определены.
                               На первый взгляд эта  идея кажется неудачной, поскольку  нам
                               придется выполнить некоторые дополнительные проверки, чтобы
                               убедиться в корректности выполнения операции «извлечь квад
                               ратный корень». При этом возникает важный вопрос: на кого ля
                               жет ответственность за выполнение этой проверки.
                               Предусловие явным образом устанавливает, что за подобную про
                               верку отвечает вызывающий объект. Без такого явного указания
                               обязанностей  мы можем получить либо недостаточный  уровень
                               проверки (когда каждая из сторон предполагает, что ответствен
                               ность несет другая сторона), либо чрезмерную проверку (когда она
                               будет выполняться обеими сторонами). Излишняя проверка тоже
                               плоха, поскольку это влечет за собой дублирование кода проверки,
                               что, в свою очередь, может существенно увеличить сложность про















                        Где найти дополнительную информацию                                    79


                               граммы. Явное определение ответственности помогает снизить
                               сложность кода. Опасность того, что вызывающий объект забудет
                               выполнить проверку, уменьшается тем обстоятельством, что утвер
                               ждение обычно проверяется во время отладки и тестирования.
                               Исходя из этих  определений предусловия и  постусловия, мы мо
                               жем дать строгое определение термина исключение. Исключение
                               возникает, когда предусловие операции  выполнено, но  операция
                               не может возвратить значение в  соответствии с  указанным пост
                               условием.
                               Инвариант представляет собой утверждение относительно класса.
                               Например, класс Account (Счет) может иметь инвариант, который
                               утверждает, что balance == sum(entries.amount()). Инвариант дол
                               жен быть «всегда» истинным для всех экземпляров класса. В дан
                               ном случае «всегда» означает «всякий раз, когда объект доступен
                               для выполнения над ним операции».
                               По существу это означает, что инвариант дополняет предусловия и
                               постусловия, связанные со всеми открытыми операциями данного
                               класса. Значение инварианта может оказаться ложным  во время
                               выполнения некоторого метода, однако оно должно снова стать ис
                               тинным к моменту взаимодействия с любым другим объектом.
                               Утверждения могут играть уникальную роль в  определении под
                               классов. Одна из опасностей наследования состоит в том, что опе
                               рации подкласса можно переопределить так, что они станут не со
                               вместимыми с операциями суперкласса. Утверждения уменьшают
                               вероятность этого. Инварианты и постусловия класса должны при
                               меняться ко всем подклассам. Подклассы могут усилить эти утвер
                               ждения, но не могут их ослабить. С другой стороны, предусловия
                               нельзя усилить, но можно ослабить.
                               На первый взгляд все это кажется излишним, однако имеет весьма
                               важное значение для обеспечения динамического связывания. В со
                               ответствии с принципом замещения необходимо всегда иметь воз
                               можность обратиться к объекту подкласса так, как если бы он был
                               экземпляром суперкласса. Если подкласс  усилил свое предусло
                               вие, то операция суперкласса, примененная к подклассу, может за
                               вершиться аварийно.


                        Где найти дополнительную информацию

                             Все упомянутые мной в главе 1 книги по основам UML рассказывают
                             о диаграммах классов более подробно. Управление зависимостями яв
                             ляется критическим элементом больших проектов. Лучшая книга по
                             этой теме – [30].






















                             4









                             Диаграммы последовательности





                             Диаграммы взаимодействия (interaction diagrams) описывают взаимо
                             действие групп  объектов в  различных  условиях их поведения.  UML
                             определяет диаграммы взаимодействия нескольких типов, из которых
                             наиболее употребительными являются диаграммы последовательности.
                             Обычно диаграмма последовательности описывает один сценарий. На
                             диаграмме показаны  экземпляры  объектов и  сообщения, которыми
                             обмениваются объекты в рамках одного прецедента (use case).
                             Для того чтобы начать  обсуждение, рассмотрим простой сценарий.
                             Предположим, что у нас есть заказ, и мы собираемся вызвать команду
                             для определения его стоимости. При этом объекту заказа (Order) необ
                             ходимо просмотреть все позиции заказа (Line Items) и определить их
                             цены, основанные на правилах построения цены продукции в строке
                             заказа (Order Line). Проделав это для всех позиций заказа, объект за
                             каза должен вычислить общую скидку, которая определяется индиви
                             дуально для каждого клиента.
                             На рис. 4.1 приведена диаграмма, представляющая реализацию дан
                             ного сценария.  Диаграммы последовательности показывают взаимо
                             действие, представляя каждого участника вместе с его линией жизни
                             (lifeline), которая идет вертикально вниз и упорядочивает сообщения
                             на странице; сообщения также следует читать сверху вниз.
                             Одно из преимуществ диаграммы  последовательности заключается
                             в том, что мне почти не придется объяснять ее нотацию. Можно видеть,
                             что  экземпляр заказа посылает строке заказа сообщения  getQuantity
                             и getProduct. Можно также видеть, как заказ применяет метод к само
                             му себе и как этот метод посылает сообщение getDiscountInfo экземпля
                             ру клиента.
                             Однако диаграмма не все показывает так хорошо. Последовательность
                             сообщений getQuantity, getProduct, getPricingDetails и calculateBasePrice
                             должна быть реализована для каждой строки заказа, тогда как метод
                             calculateDiscounts вызывается лишь однажды. Такое заключение нель















                                                                                               81




                                      an Order       an Order Line     aProduct       aCustomer

                              calculatePrice
                                             getQuantity

                                             getProduct      участник           линия
                                                                                жизни
                              найденное       aProduct
                              сообщение
                                                                            активация
                                           getPricingDetails  возврат



                                            calculateBasePrice  самовызов


                                                                                сообщение
                                            calculateDiscounts
                                                            getDiscountInfo







                             Рис. 4.1. Диаграмма последовательности централизованного управления
                             зя сделать на основе этой диаграммы, но позднее я введу дополнитель
                             ное обозначение, которое поможет в этом.
                             В большинстве случаев можно считать участников диаграммы взаимо
                             действия объектами, как это и было в действительности в UML 1. Но
                             в UML 2 их роль значительно сложнее, и полное ее объяснение выходит
                             за рамки этой книги. Поэтому я употребляю термин участники (partici
                             pants), который формально не входит в спецификацию UML. В UML
                             версии 1 участники были объектами, и поэтому их имена подчеркива
                             лись, но в UML 2 их надо показывать без подчеркивания, как я и сде
                             лал выше.
                             На приведенной диаграмме я именовал участников, используя стиль
                             anOrder. В большинстве случаев это вполне приемлемо. Вот более пол
                             ный синтаксис: имя : Класс, где и имя, и класс не обязательны, но если
                             класс используется, то двоеточие должно присутствовать. (Этот стиль
                             выдержан на рис. 4.4.)
                             Каждая линия жизни имеет полосу активности, которая показывает
                             интервал активности участника при взаимодействии. Она соответству
                             ет времени нахождения в стеке одного из методов участника. В языке
                             UML полосы активности не обязательны, но я считаю их исключи















                        82                                     Глава 4. Диаграммы последовательности


                             тельно удобными при пояснении поведения. Единственным исключе
                             нием является стадия проработки дизайна, поскольку их неудобно ри
                             совать на белых досках.
                             Именование бывает часто полезным для установления связей между
                             участниками на диаграмме. Как видно на диаграмме, вызов метода
                             getProduct возвращает aProduct, имеющего то же самое имя и, следова
                             тельно, означающего того же самого участника, aProduct, которому по
                             сылается вызов  getPricingDetails. Обратите внимание,  что обратной
                             стрелкой я обозначил только этот вызов с целью показать соответст
                             вие. Многие разработчики используют возвраты для всех вызовов, но
                             я предпочитаю применять их, только когда это дает дополнительную
                             информацию; в противном случае они просто вносят неразбериху. Не
                             исключено, что даже в данном случае можно было опустить возврат,
                             не запутав читателя.
                             У  первого сообщения нет участника, пославшего его,  поскольку оно
                             приходит из неизвестного источника. Оно называется найденным со
                             общением (found message).
                             Другой подход  можно увидеть на  рис. 4.2. Основная задача  остается
                             той же самой, но способ взаимодействия участников для ее решения
                             совершенно другой. Заказ спрашивает каждую строку заказа о его соб
                             ственной цене (Price). Сама строка заказа передает вычисление даль
                             ше – объекту продукта (Product); обратите внимание, как мы показы
                             ваем передачу параметра. Подобным же образом для  вычисления
                             скидки объект заказа  вызывает  метод для клиента  (Customer).  По
                             скольку для выполнения этой задачи клиенту требуется информация
                             от объекта заказа, то он делает повторный вызов в отношении заказа
                             для получения этих данных.


                                      an Order       an Order Line       aProduct      aCustomer

                              calculatePrice                                   параметр
                                            calculatePrice
                                                          getPrice(quantity: number)



                                                         getDiscountedValue (an Order)

                                                               getBaseValue
                                                                              возврат



                                                              discountedValue
                             Рис. 4.2. Диаграмма последовательности для распределенного управления















                                                                                               83


                             Вопервых, на этих двух диаграммах надо обратить внимание на то, на
                             сколько ясно диаграмма последовательности показывает различия во
                             взаимодействии участников. В этом проявляется мощь диаграмм взаи
                             модействий.  Они не очень хорошо  представляют детали  алгоритмов,
                             такие  как циклы или  условное поведение, но делают абсолютно  про
                             зрачными вызовы между участниками  и  дают действительно ясную
                             картину того, какую обработку выполняют конкретные участники.
                             Вовторых, посмотрите, как четко видна разница в стиле между двумя
                             взаимодействиями. На рис. 4.1 представлено централизованное управ
                             ление (centralized control), когда один из участников в значительной
                             степени выполняет всю обработку, а другие предоставляют данные. На
                             рис. 4.2 изображено распределенное управление (distributed control),
                             при котором обработка распределяется между многими участниками,
                             каждый их которых выполняет небольшую часть алгоритма.
                             Оба  стиля обладают преимуществами и недостатками. Большинство
                             разработчиков, особенно новички  в объектноориентированном про
                             граммировании, чаще всего применяют  централизованное управле
                             ние. Во многих случаях это проще, так как вся обработка сосредоточе
                             на в одном месте; напротив, в случае распределенного управления при
                             попытке понять программу создается ощущение погони за объектами.
                             Несмотря на это фанатики объектов, такие как я, предпочитают рас
                             пределенное управление. Одна из главных задач хорошего проектиро
                             вания заключается в локализации изменений. Данные и программный
                             код, получающий доступ к этим данным, часто изменяются вместе. По
                             этому размещение данных и обращающейся к ним программы в одном
                             месте – первое правило объектноориентированного проектирования.
                             Кроме того, распределенное управление позволяет создать больше воз
                             можностей для применения полиморфизма, чем в случае применения
                             условной логики. Если алгоритмы определения цены отличаются для
                             различных типов продуктов, то механизм распределенного управле
                             ния позволяет нам использовать подклассы класса продукта (Product)
                             для обработки этих вариантов.
                             Вообще,  объектноориентированный стиль предназначен  для работы
                             с большим количеством  небольших объектов,  обладающих множест
                             вом небольших методов, что дает широкие возможности для переопре
                             деления и изменения. Этот стиль сбивает с толку людей, применяю
                             щих длинные процедуры; действительно это изменение является серд
                             цем  смены парадигмы  (paradigm shift)  при  объектной ориентации.
                             Научить этому трудно. Представляется, что единственный способ дей
                             ствительно понять это заключается в использовании распределенного
                             управления при работе в объектноориентированном окружении. Мно
                             гие люди говорят, что они испытали внезапное озарение, когда поняли
                             смысл этого стиля. В этот момент их мозг перестроился, и они начали
                             думать, что децентрализованное управление действительно проще.















                        84                                     Глава 4. Диаграммы последовательности


                        Создание и удаление участников

                             В диаграммах последовательности для создания и удаления участни
                             ков применяются некоторые дополнительные обозначения (рис. 4.3).
                             В случае создания участника надо нарисовать стрелку сообщения, на
                             правленную  к прямоугольнику участника. Если применяется конст
                             руктор, то имя сообщения не обязательно, но я обычно маркирую его
                             словом «new» в любом случае. Если участник выполняет чтонибудь
                             непосредственно после создания, например команду запроса, то надо
                             начать активацию сразу после прямоугольника участника.
                             Удаление участника обозначается большим крестом (X). Стрелка сооб
                             щения, идущая в X, означает, что один участник явным образом уда
                             ляет другого; X в конце линии жизни показывает, что участник удаля
                             ет сам себя.
                             Если в системе работает  сборщик  мусора, то объекты не удаляются
                             вручную,  тем не менее следует  при  помощи X показать, что объект
                             больше не нужен и готов к удалению. Так следует поступать и в случае
                             операций закрытия, показывая, что объект больше не используется.



                                           a Handler

                              запросить базу данных


                                                  new       a Query
                                                           Command
                                                                  new      a Database
                                                                           Statement
                                                 создание
                                                                    выполнить
                                                                                  удаление
                                                                                  из другого
                                                                    результаты    объекта


                                                                 извлечь результаты

                                                                     закрыть


                                                    результаты           самоудаление


                             Рис. 4.3. Создание и удаление участников















                        Циклы, условия и тому подобное                                         85


                        Циклы, условия и тому подобное

                             Общая  проблема диаграмм последовательности заключается в том,
                             как отображать циклы и условные конструкции. Прежде всего надо
                             усвоить, что диаграммы последовательности для этого не предназначе
                             ны. Подобные управляющие структуры лучше показывать с помощью
                             диаграммы деятельности или собственно кода. Диаграммы последова
                             тельности применяются для  визуализации процесса  взаимодействия
                             объектов, а не как средство моделирования алгоритма управления.
                             Как было  сказано, существуют дополнительные  обозначения. И для
                             циклов, и для условий используются фреймы взаимодействий (inter
                             action frames), представляющие собой средство разметки диаграммы
                             взаимодействия. На  рис. 4.4 показан  простой алгоритм, основанный
                             на следующем псевдокоде.
                                  foreach (lineitem)
                                    if (product.value > $10K)
                                     careful.dispatch
                                    else
                                     regular.dispatch
                                    end if


                                                                 careful :   regular :
                                                     :Order                             :Messenger
                                                                Distributor  Distributor
                                                dispatch

                                        loop   [для каждой позиции заказа]


                             оператор      alt   [значение > $10000]                  фрейм
                                                           dispatch




                                                  [else]
                                                                 dispatch
                                             защита



                                              opt   [needsConfirmation]  подтвердить




                             Рис. 4.4. Фреймы взаимодействия















                        86                                     Глава 4. Диаграммы последовательности


                                  end for
                                  if (needsConfirmation) messenger.confirm
                                end procedure
                             В основном фреймы состоят из некоторой области диаграммы последо
                             вательности, разделенной  на несколько фрагментов. Каждый  фрейм
                             имеет оператор, а каждый фрагмент может иметь защиту. (В табл. 4.1
                             перечислены общепринятые операторы для фреймов взаимодействия.)
                             Для отображения цикла  применяется оператор  loop с  единственным
                             фрагментом, а тело итерации помещается в защиту. Для условной ло
                             гики можно использовать оператор alt и помещать условие в каждый
                             фрагмент. Будет выполнен только тот фрагмент, защита которого имеет
                             истинное значение. Для единственной области существует оператор opt.
                             Таблица 4.1. Общепринятые операторы для фреймов взаимодействия

                              Оператор   Значение
                              alt        Несколько альтернативных фрагментов (alternative); выполняет
                                         ся только тот фрагмент, условие которого истинно (рис. 4.4)
                              opt        Необязательный (optional) фрагмент; выполняется, только если
                                         условие истинно. Эквивалентно alt с одной веткой (рис. 4.4)
                              par        Параллельный (parallel); все  фрагменты выполняются парал
                                         лельно
                              loop       Цикл (loop); фрагмент может выполняться несколько раз, а за
                                         щита обозначает тело итерации (рис. 4.4)

                              region     Критическая  область (critical region); фрагмент  может  иметь
                                         только один поток, выполняющийся за один прием
                              neg        Отрицательный (negative) фрагмент; обозначает неверное вза
                                         имодействие
                              ref        Ссылка (reference); ссылается на взаимодействие, определенное
                                         на другой  диаграмме. Фрейм рисуется, чтобы охватить линии
                                         жизни, вовлеченные во взаимодействие. Можно определять па
                                         раметры и возвращать значение
                              sd         Диаграмма последовательности (sequence diagram); используется
                                         для очерчивания всей диаграммы последовательности, если это
                                         необходимо

                             Фреймы взаимодействия – новинка UML 2. В диаграммах,  разрабо
                             танных до создания UML 2, применяется другой подход; кроме того,
                             некоторые разработчики не любят фреймы и предпочитают прежние
                             соглашения. На рис. 4.5 показаны некоторые из этих неофициальных
                             приемов.
                             В  UML 1  использовались  маркеры итераций и защиты. В качестве
                             маркера итерации (iteration marker) выступал символ *, добавленный
                             к имени сообщения. Для обозначения тела итерации можно добавить
                             текст в квадратных скобках. Защита (guard) – это условное выраже















                        Циклы, условия и тому подобное                                         87


                             ние, размещенное в квадратных скобках и означающее, что сообщение
                             посылается, только когда защита принимает истинное значение. Эти
                             обозначения исключены из UML 2, но они все еще встречаются в диа
                             граммах взаимодействия.
                             Несмотря на то что маркеры итерации и защиты могут оказаться по
                             лезными, они имеют один недостаток. С помощью защиты нельзя по
                             казать, что несколько защит взаимно исключают друг друга, напри
                             мер две защиты, представленные на рис. 4.5. Оба обозначения работа
                             ют только в случае отправки одного сообщения и не работают, когда
                             при одной активации посылается несколько сообщений в рамках того
                             же самого цикла или условного блока.
                             Решением последней проблемы может служить ставшее популярным
                             неофициальное соглашение, заключающееся в применении псевдосо
                             общения (pseudomessage) в виде условия цикла или защиты на одном
                             из вариантов обозначения самовызова. На рис. 4.5 я показал это без
                             стрелки сообщения; некоторые разработчики включают стрелку сооб
                             щения, но ее отсутствие помогает подчеркнуть, что это ненастоящий
                             вызов. Некоторые разработчики любят оттенять прямоугольник акти
                             вации псевдосообщения серым цветом. Вариативное поведение можно
                             показать, поставив маркер альтернативы между активациями.


                                                       careful :           regular :
                                      an Order                                          :Messenger
                                                      Distributor         Distributor
                                 dispatch   маркер итерации
                                                             псевдосообщение

                                   !       * [для каждой
                                 ненор        позиции заказа]  асинхронное сообщение
                               мативный     [значение > $10000]  ( UML 1.4 и старше)

                                             dispatch                           асинхронное сообщение
                                                                  идентификатор  ( UML 1.3 и младше)
                                                                        заказа
                                            [else]
                             альтернатива       dispatch  номер позиции

                                                          вектор      идентификатор
                                                          данных
                                               защита                 доставки

                                               [needsConfirmation] подтвердить






                             Рис. 4.5. Старые соглашения для условной логики















                        88                                     Глава 4. Диаграммы последовательности


                             Хотя я считаю активации очень полезными, они не слишком много да
                             ют в случае метода dispatch (перенаправить), с помощью которого от
                             правляются сообщения, при этом в рамках активации приемника
                             больше ничего не происходит. По общепринятому соглашению, кото
                             рого я придерживался в диаграмме на рис. 4.5, для таких простых вы
                             зовов активация опускается.
                             Стандарт UML не предоставляет графических средств для обозначения
                             передаваемых данных; вместо этого они показываются с помощью па
                             раметров в имени сообщения и на стрелках возврата. Векторы данных
                             повсеместно использовались во многих областях для обозначения пе
                             ремещения данных, и многие разработчики все еще с удовольствием
                             применяют их в UML.
                             В конечном счете, хотя различные системы могут включать в диаграм
                             мы последовательности  обозначения для  условной логики,  я не  ду
                             маю, что они работают скольконибудь лучше программного кода или,
                             по крайней мере, псевдокода. В частности, я считаю фреймы взаимо
                             действия очень тяжеловесными, скрывающими основной смысл диа
                             граммы, поэтому я предпочитаю псевдосообщения.


                        Синхронные и асинхронные вызовы

                             Если вы были очень внимательны, то заметили, что стрелки в послед
                             них двух диаграммах отличаются от предыдущих. Это небольшое от
                             личие достаточно важно в UML версии 2. Здесь закрашенные стрелки
                             показывают синхронное  сообщение, а  простые стрелки обозначают
                             асинхронное сообщение.
                             Если вызывающий объект посылает синхронное сообщение (synchro
                             nous message), то он должен ждать, пока обработка сообщения не будет
                             закончена,  например при вызове подпрограммы.  Если вызывающий
                             объект посылает  асинхронное сообщение  (asynchronous message), то
                             он может продолжать работу и не должен ждать ответа. Асинхронные
                             вызовы можно встретить в многопоточных приложениях и в промежу
                             точном  программном  обеспечении, ориентированном на сообщения.
                             Асинхронность улучшает способность к реагированию и уменьшает
                             количество временных соединений, но сложнее в отладке.
                             Разница в изображении стрелок едва уловима; действительно их до
                             вольно трудно  отличить. Кроме  того, это изменение, введенное в
                             UML 1.4,  не обладает обратной  совместимостью, поскольку  до этого
                             асинхронные сообщения обозначались  половинными стрелками, как
                             показано на рис. 4.5.
                             На мой взгляд,  такое  различие слишком незаметно. Я бы  советовал
                             выделять асинхронные сообщения  при помощи старых  половинных
                             стрелок, которые больше привлекают взгляд. Читая диаграмму после
                             довательности, не спешите делать предположения о синхронности по















                        Когда применяются диаграммы последовательности                         89


                             виду стрелок до тех пор, пока не убедитесь, что автор умышленно на
                             рисовал их разными.

                        Когда применяются диаграммы
                        последовательности

                             Диаграммы последовательности следует применять тогда, когда тре
                             буется посмотреть на поведение нескольких объектов в рамках одного
                             прецедента. Диаграммы последовательности хороши для представле
                             ния взаимодействия объектов, но не очень подходят для точного опре
                             деления поведения.
                             Если вы хотите посмотреть на поведение одного объекта в нескольких
                             прецедентах, то примените диаграмму состояния (глава 10). Если же
                             надо изучить поведение нескольких объектов в нескольких прецеден
                             тах или потоках, не забудьте о диаграмме деятельности (глава 11).
                             Если требуется быстро исследовать несколько вариантов взаимодейст
                             вия, лучше использовать CRCкарточки, поскольку это позволяет из
                             бежать непрерывного рисования и стирания. Часто бывает удобно по
                             работать с CRCкарточками для просмотра вариантов взаимодействия,
                             а затем с помощью диаграмм взаимодействий фиксировать те взаимо
                             действия, которые будут применяться позже.
                             Другим полезным видом диаграмм взаимодействий являются комму
                             никационные диаграммы, которые показывают соединения, и времен
                             ные диаграммы, показывающие временные интервалы.

                                                       CRCкарточки
                               Одним из наиболее полезных приемов, соответствующих хороше
                               му стилю ООП, является исследование взаимодействия объектов,
                               поскольку его цель состоит в том, чтобы исследовать работу про
                               граммы, а не данные.  CRCдиаграммы (ClassResponsibilityCol
                               laboration, классобязанностькооперация), придуманные  Уордом
                               Каннингемом (Ward Cunningham) в конце 80х годов, выдержали
                               проверку временем и стали высокоэффективным инструментом ре
                               шения этой задачи (рис. 4.6). И хотя они не входят в состав UML,
                               все же являются очень популярными среди высококвалифициро
                               ванных разработчиков в области объектных технологий.
                               Для использования CRCкарточек вы и ваши коллеги должны со
                               браться за столом. Возьмите различные сценарии и проиграйте их
                               с  помощью карточек, поднимая  их  над столом,  в то время  когда
                               они активны, и передавая их по кругу в предположении, что они
                               посылают сообщение. Эту технологию почти невозможно описать
                               в книге, но легко продемонстрировать; лучший способ научиться
                               этому состоит в том, чтобы попросить когонибудь, кто имеет такой
                               опыт, показать вам это.















                        90                                     Глава 4. Диаграммы последовательности



                                                 имя класса
                                ответственность                          взаимодействие

                                                       Order
                                       Проверить наличие позиции  Order Line
                                       Определить цену            Customer
                                       Проверить правильность оплаты
                                       Отправить по адресу доставки






                               Рис. 4.6. Пример CRC'карточки
                               Важным моментом в CRCметодике является определение ответст
                               венностей. Ответственность (responsibility) – это краткое описание
                               того, что объект должен делать: операция, которую выполняет
                               объект, некоторый объем знаний, который объект поддерживает,
                               или какиелибо важные решения, принимаемые объектом.  Идея
                               состоит в том, чтобы вы могли взять любой класс и сформулиро
                               вать его разумно ограниченные обязанности. Такой образ действия
                               поможет вам яснее представить себе архитектуру классов.
                               Вторая буква «C» (в CRC) означает взаимодействие (collaboration):
                               другие классы, с  которыми должен работать рассматриваемый
                               класс. Это дает вам некоторое представление о связях между клас
                               сами, но все еще на высоком уровне.
                               Одно из главных преимуществ CRCкарточек состоит в том, что
                               они способствуют живому обсуждению проектов в среде разработ
                               чиков. Если в процессе работы над шаблоном поведения вы хотите
                               посмотреть, как классы его реализуют, то вычерчивание диаграмм
                               взаимодействия, описанных в этой главе, может занять слишком
                               много времени. Обычно требуется просмотреть варианты, а рисова
                               ние и стирание вариантов на диаграммах может быть очень утоми
                               тельным. С помощью  CRCкарточек разработчики моделируют
                               взаимодействие, поднимая карточки и передавая их по кругу. Это
                               позволяет быстро просчитать варианты.
                               В процессе работы вы создаете представление об ответственностях
                               и записываете их на карточки. Размышления об ответственностях
                               важны, поскольку рассеивают представление о классах как о бес
                               словесных хранителях данных и помогают членам команды лучше
                               понять поведение каждого класса на высшем уровне. Ответствен
                               ность может соответствовать  операции, атрибуту  или, что  более
                               точно, неограниченной группе атрибутов и операций.















                        Когда применяются диаграммы последовательности                         91


                               Мой опыт показывает, что распространенной ошибкой разработчи
                               ков является создание  ими длинных  списков низкоуровневых  от
                               ветственностей. Это приводит к непониманию  сути. Ответственно
                               сти должны свободно помещаться на одной карточке. Спросите себя,
                               следует ли разделить класс или лучше отрегулировать ответствен
                               ности, переместив их на более высокий уровень операторов.
                               Многие разработчики подчеркивают важность ролевой игры, ког
                               да каждый член команды играет роль одного или нескольких клас
                               сов. Я никогда не видел, чтобы Уорд Каннингем так поступал, и ду
                               маю, что ролевая игра находится в начале своего пути.
                               CRC были посвящены целые книги, но не думаю, что они действи
                               тельно стали сердцем методологии. Первой работой по CRC была
                               статья, написанная  Кентом Беком (Kent  Beck) [4].  Дополнитель
                               ную информацию по CRCкарточкам можно найти в [44].






















                             5









                             Диаграммы классов:
                             дополнительные понятия





                             Описанные  ранее в  главе 4 понятия  соответствуют основной нотации
                             диаграмм классов. Именно эти понятия нужно постичь и освоить преж
                             де всего, поскольку они на 90% удовлетворят ваши потребности при
                             построении диаграмм классов.
                             Однако диаграммы классов могут содержать множество обозначений
                             для представления различных дополнительных понятий. Я сам обра
                             щаюсь к ним не слишком часто, но в отдельных случаях они оказыва
                             ются весьма удобными.  Рассмотрим последовательно эти дополни
                             тельные понятия, обращая внимание на особенности их применения.
                             Возможно, при чтении этой главы вы столкнетесь с некоторыми труд
                             ностями. Порадую вас:  эту  главу  можно без всякого ущерба пропус
                             тить при первом чтении книги и вернуться к ней позже.

                             Ключевые слова

                             Одна из трудностей, сопряженных с графическими языками, состоит
                             в необходимости запоминать значения символов. Когда символов
                             слишком много, пользователям трудно запомнить, что означает каж
                             дый из них. Поэтому в UML нередко предпринимаются  попытки
                             уменьшить количество  символов, заменяя их ключевыми словами.
                             Когда требуется смоделировать конструкцию, отсутствующую в UML,
                             но похожую на один из его элементов, возьмите символ существующей
                             конструкции UML, пометив его ключевым словом, чтобы показать,
                             что используется нечто другое.
                             Примером может служить  интерфейс.  Интерфейс  (interface) в UML
                             (стр. 96) означает класс, в котором все операции открытые и не имеют
                             тел методов. Это соответствует интерфейсам в Java, COM (Component
                             Object Module) и CORBA. Поскольку это специальный вид класса, то он
                             изображается с помощью  пиктограммы с ключевым словом  «inter















                        Ответственности                                                        93


                             face». Обычно ключевые слова представляются в виде текста, заклю
                             ченного во французские кавычки («елочки»). Вместо ключевых слов
                             можно использовать специальные значки, но тем самым вы заставляе
                             те всех запоминать их значения.
                             Некоторые ключевые слова, такие как {abstract}, заключаются в фи
                             гурные скобки. В действительности никогда не понятно, что формаль
                             но должно быть в кавычках, а что в фигурных скобках. К счастью, ес
                             ли вы ошибетесь, то заметят это только настоящие знатоки UML. Но
                             лучше быть внимательными.
                             Некоторые ключевые слова настолько общеупотребительны, что часто
                             заменяются сокращениями:  «interface» часто сокращается  до  «I»,
                             а {abstract} – до {A}. Такие сокращения очень полезны, особенно на бе
                             лых досках, однако их применение не стандартизовано. Поэтому если
                             вы их употребляете, то не забудьте найти место для расшифровки этих
                             обозначений.
                             В UML 1 кавычки  применялись в основном для стереотипов. В  UML
                             версии 2 стереотипы определены очень кратко, и разговор о том, что
                             является стереотипом, а что нет, выходит за рамки этой книги. Одна
                             ко изза UML 1 многие разработчики употребляют термин «стереотип»
                             в качестве синонима ключевого слова, хотя теперь это неверно.
                             Стереотипы используются как части профилей. Профиль (profile) бе
                             рет часть UML и расширяет его с помощью связанной группы стерео
                             типов для определенной цели,  например для бизнесмоделирования.
                             Полное описание семантики профилей выходит за рамки этой книги.
                             Пока вы не займетесь разработкой серьезной метамодели, вам вряд ли
                             понадобится  создавать  профиль самому. Скорее всего, вы  возьмете
                             профиль, ранее созданный для конкретного варианта моделирования,
                             и, к счастью, применение профиля не требует знания чудовищного ко
                             личества подробностей, связанных с метамоделью.

                        Ответственности

                             Часто бывает удобным показывать ответственности класса (стр. 90) на
                             диаграмме классов. Лучший способ показать их состоит в том, чтобы
                             располагать строки комментария в их собственной ячейке (рис. 5.1).
                             При желании ячейке можно присвоить имя, но я обычно этого не де
                             лаю, поскольку вероятность возникновения путаницы невелика.

                        Статические операции и атрибуты

                             Если в  UML ссылаются  на операции и атрибуты, принадлежащие
                             классу, а не экземпляру класса, то они называются статическими. Это
                             эквивалентно статическим членам в Cподобных языках. На диаграм
                             ме класса статические элементы подчеркиваются (рис. 5.2).















                        94                          Глава 5. Диаграммы классов: дополнительные понятия



                                       View
                                                                   Model
                                   Обязанности
                              -- показывают информацию        -- логика домена
                                  о модели







                                                   Input Controller
                                               -- обрабатывает входные
                                                   сообщения
                             Рис. 5.1. Представление обязанностей на диаграмме классов


                                                    Order

                                              getNumber
                                              getNextNewNumber
                             область видимости
                                экземпляра                         статическая
                             Рис. 5.2. Статическая нотация


                        Агрегация и композиция

                             К одним из наиболее частых источников недоразумений в UML –мож
                             но отнести агрегацию и композицию. В нескольких словах это можно
                             объяснить так: Агрегация (aggregation) – это отношение типа «часть
                             целого».  Точно так  же можно сказать,  что двигатель и  колеса пред
                             ставляют собой части автомобиля. Звучит вроде бы просто, однако при
                             рассмотрении разницы между агрегацией и композицией возникают
                             определенные трудности.
                             До появления языка UML вопрос о различии между агрегацией и ком
                             позицией у  аналитиков просто не  возникал. Осознавалась подобная
                             неопределенность или нет, но свои работы в этом вопросе аналитики
                             совсем не согласовывали между собой. В результате многие разработ
                             чики считают агрегацию важной, но по совершенно другой причине.
                             Язык UML включает агрегацию (рис. 5.3) но семантика ее очень рас
                             плывчата. Как говорит Джим Рамбо (Jim Rumbaugh): «Можно пред
                             ставить себе  агрегацию как плацебо для моделирования» [40].
                             Наряду с агрегацией в языке UML есть более определенное свойство –
                             композиция (composition). На рис. 5.4 экземпляр класса Point (Точка)
                             может быть частью многоугольника, а может представлять центр ок
                             ружности, но он не может быть и тем и другим одновременно. Главное















                        Производные свойства                                                   95



                                                        члены
                                   Club                            Person
                                             **

                             Рис. 5.3. Агрегация


                                                {ordered}               центр
                                 Polygon                     Point                      Circle
                                                     3.. *              1

                             Рис. 5.4. Композиция
                             правило состоит в том, что хотя класс может быть частью нескольких
                             других классов, но любой экземпляр может принадлежать только од
                             ному владельцу. На диаграмме  классов можно  показать несколько
                             классов потенциальных владельцев,  но у  любого экземпляра класса
                             есть только один объектвладелец.
                             Вы заметите, что на рис 5.4 я не показываю обратные кратности. В боль
                             шинстве случаев, как и здесь, они равны 0..1. Единственной альтерна
                             тивой является значение 1, когда класскомпонент разработан таким
                             образом, что у него только один классвладелец.
                             Правило «нет совместного владения» является ключевым в компози
                             ции. Другое допущение состоит в том, что если удаляется многоуголь
                             ник (Polygon), то автоматически должны удалиться все точки (Points),
                             которыми он владеет.
                             Композиция – это хороший способ показать свойства, которыми владе
                             ют по значению, свойства объектовзначений (стр. 100) или свойства,
                             которые имеют определенные и до некоторой  степени исключитель
                             ные права владения другими компонентами. Агрегация совершенно не
                             имеет смысла; поэтому я не рекомендовал бы применять ее в диаграм
                             мах. Если вы встретите ее в диаграммах других разработчиков, то вам
                             придется покопаться, чтобы понять их значение. Разные авторы и ко
                             манды разработчиков используют их в совершенно разных целях.


                        Производные свойства

                             Производные свойства (derived properties) могут вычисляться на ос
                             нове других значений. Говоря об интервале дат (рис. 5.5), мы можем
                             рассуждать о трех свойствах: начальной дате, конечной дате и количе
                             стве дней за данный период. Эти значения связаны, поэтому мы мо
                             жем сказать, что длина является производной двух других значений.
                             С точки зрения программного обеспечения образование производных
                             можно интерпретировать двумя различными путями. Можно исполь
                             зовать образование производных для обозначения различия между вы
                             числяемым и хранимым значениями. В этом случае, глядя на рис. 5.5,















                        96                          Глава 5. Диаграммы классов: дополнительные понятия



                                             Date Range
                             производный
                                          start: Date             {length = start - end}
                               атрибут
                                          end: Date
                                          /length: Integer

                             Рис. 5.5. Производный атрибут для временного интервала
                             мы скажем, что начальная (start) и конечная (end) даты хранятся,
                             адлина (length)  вычисляется. И хотя  это наиболее  распространенное
                             применение, меня это не очень привлекает, поскольку слишком рас
                             крывает внутреннее устройство класса DateRange (Интервал дат).
                             Я предпочитаю рассматривать это как связь между значениями. В дан
                             ном случае мы  говорим,  что между тремя  значениями существует
                             связь, но не важно, какое из трех  значений вычисляется. При этом
                             можно произвольно выбирать, какой атрибут отмечать как производ
                             ный,  а можно и  вовсе этого не  делать, но все же полезно напомнить
                             разработчикам о  связи. Такое применение имеет смысл в концепту
                             альных диаграммах.
                             Образование производных может быть применено к свойствам с помо
                             щью ассоциаций. В этом случае вы просто отмечаете имя символом «/».

                        Интерфейсы и абстрактные классы


                             Абстрактный класс (abstract class) – это класс, который нельзя реали
                             зовать непосредственно. Вместо этого создается экземпляр подкласса.
                             Обычно абстрактный класс имеет одну или более абстрактных опера
                             ций. У абстрактной операции (abstract operation) нет реализации; это
                             чистое объявление, которое клиенты могут привязать к абстрактному
                             классу.
                             Наиболее распространенным способом обозначения абстрактного
                             класса или операции в языке UML является написание их имен курси
                             вом. Можно также сделать свойства абстрактными, определяя абст
                             рактное свойство или методы доступа. Курсив сложно изобразить на
                             доске, поэтому можно прибегнуть к метке: {abstract}.
                             Интерфейс – это класс, не имеющий реализации, то есть вся его функ
                             циональность абстрактна. Интерфейсы прямо соответствуют интер
                             фейсам в C# и Java и являются общей идиомой в других типизирован
                             ных языках. Интерфейс обозначается ключевым словом «interface».
                             Классы обладают двумя  типами  отношений с интерфейсами: предо
                             ставление или требование. Класс предоставляет интерфейс, если его
                             можно заменить на интерфейс. В Java и .NET класс может сделать это,
                             реализуя интерфейс или подтип  интерфейса. В C++ создается под
                             класс класса, являющегося интерфейсом.















                        Интерфейсы и абстрактные классы                                        97


                             Класс требует интерфейс, если для работы ему нужен экземпляр дан
                             ного интерфейса. По сути дела, это зависимость от интерфейса.
                             На рис. 5.6 эти отношения демонстрируются  в действии  на базе не
                             большого набора классов, заимствованных из Java. Я мог бы написать
                             класс  Order  (Заказ), содержащий список позиций заказа (Line  Items).
                             Поскольку я использую список, то класс Order зависит от интерфейса
                             List (Список). Предположим, что он вызывает методы equals, add и get.
                             При выполнении  связывания объект  Order действительно  будет ис
                             пользовать экземпляр класса ArrayList, но ему не нужно знать, что не
                             обходимо вызывать эти три метода, поскольку они входят в состав ин
                             терфейса List.
                             Класс ArrayList – это подкласс класса AbstractList. Класс AbstractList
                             предоставляет некоторую, но не всю реализацию поведения интерфей
                             са List. В частности, метод get – абстрактный. В результате ArrayList
                             реализует метод get, а также переопределяет некоторые другие опера
                             ции класса AbstractList. В данном случае он переопределяет метод add,
                             но вполне удовлетворен наследованием реализации метода equals.

                                                        «interface»
                                                        Collection
                                           интерфейс
                                                     equals
                                                     add
                                                                             абстрактный
                                                                                класс




                                                                                Abstract List
                                                        «interface»
                                   Order                  List
                                                                              equals
                              Line Items [*]                                  get
                                                     get
                                                                              add
                                       зависимость              реализация            абстрактный
                                        (требует              (предоставляет             метод
                                        интерфейс)              интерфейс)


                                                                                 ArrayList
                                                                              get
                                                                              add





                                                                         переопределение
                             Рис. 5.6. Пример интерфейсов и абстрактного класса на языке Java















                        98                          Глава 5. Диаграммы классов: дополнительные понятия


                             Почему бы мне просто не отказаться от этого и не заставить Order пря
                             мо использовать ArrayList? Применение интерфейса позволяет мне по
                             лучить преимущество при последующем изменении реализации, если
                             потребуется. Другой способ реализации может оказаться более
                             производительным – он может предоставить функции работы с базой
                             данных или другие возможности. Программируя интерфейс, а не реа
                             лизацию, я избегаю необходимости переделывать весь код, когда до
                             статочно изменить реализацию класса List. Следует всегда стараться
                             программировать интерфейс так, как показано выше, то есть всегда
                             использовать наиболее общий тип.
                             Относительно вышесказанного приведу один практический совет. Ко
                             гда программисты применяют коллекцию, подобную приведенной
                             здесь, они обычно инициализируют ее при объявлении, например:
                                private List lineItems = new ArrayList();
                             Обратите внимание, что это определенно приводит к зависимости Order
                             от конкретного ArrayList. С точки зрения теории это проблема, но на
                             практике разработчиков это не беспокоит. Поскольку lineItems объяв
                             лен как List, то никакая другая часть класса Order не зависит от Array
                             List. При необходимости изменить реализацию нужно побеспокоиться
                             лишь об одной строке кода инициализации. Общепринято ссылаться
                             на конкретный класс  единожды –  при создании,  а впоследствии  ис
                             пользовать только интерфейс.

                             Полная нотация на рис. 5.6 – это один из способов обозначения интер
                             фейса. На рис. 5.7 показана более компактная нотация. Тот факт, что
                             ArrayList реализует List и Collection, показан с помощью кружков, на
                             зываемых часто «леденцами на палочках». То, что  Order требует ин
                             терфейс List, показано с помощью значка «гнездо». Связь совершенно
                             очевидна.
                             В UML уже применялась нотация «леденцов на палочках», но гнездо
                             вая нотация – это новинка UML 2. (Мне кажется, это моя любимая но
                             тация из добавленных.)  Возможно, вы  встретите более  старые  диа
                             граммы, использующие стиль, представленный на рис. 5.8, где зави
                             симость основана на нотации леденцов.
                             Любой класс – это сочетание интерфейса и реализации. Поэтому мы
                             часто можем видеть, что объект используется посредством интерфейса
                             одного из его суперклассов. Определенно, было бы допустимо исполь

                                  Order             List
                                                              ArrayList
                              Line Items [*]

                                                      Collection
                             Рис. 5.7. Шарово'гнездовая нотация















                        Интерфейсы и абстрактные классы                                        99



                                  Order             List
                                                              ArrayList
                              Line Items [*]


                                                      Collection

                             Рис. 5.8. Более старое обозначение зависимостей с помощью
                                     «леденцов на палочке»
                             зовать для суперкласса нотацию леденцов, поскольку суперкласс – это
                             класс, а не чистый интерфейс. Но я обхожу эти правила для ясности.
                             Разработчики сочли, что нотация леденцов полезна не только для диа
                             грамм классов, но и в других местах. Одна из вечных проблем диа
                             грамм взаимодействий  заключается  в том, что они не обеспечивают
                             хорошую визуализацию полиморфного поведения. Хотя это норматив
                             ное применение, вы можете обозначить такое поведение вдоль линий,
                             как на рис. 5.9. Здесь, как вы можете видеть, хотя у нас есть экземп
                             ляр класса Salesman, который используется объектом  Bonus Calculator
                             как таковой, но объект Pay Period использует Salesman только через его
                             интерфейс Employee. (Тот же самый прием может применяться и в слу
                             чае коммуникационных диаграмм.)


                                                                                     march : Pay
                                      a scenario                  Bruce: Salesman
                                                                                       Period
                                оценить

                                                      a Bonus
                                                     Calculator

                                                          установить размер льгот
                                                                            сообщение
                                                                              через
                                                                            интерфейс
                                                           addToPayList (Bruce)
                                                            calculatePayroll

                                                                              calculate Pay
                                                             !
                                                           ненор        employee
                                                          мативный


                             Рис. 5.9. Представление полиморфизма на диаграммах последовательности
                                     с помощью нотации леденцов















                        100                         Глава 5. Диаграммы классов: дополнительные понятия


                        ReadOnly и Frozen

                             На  стр. 64 я описал  ключевое  слово  {readOnly} (только  для чтения).
                             Этим ключевым словом обозначается свойство, которое клиенты могут
                             только читать, но не могут обновлять. Подобное, но несколько отлича
                             ющееся ключевое слово {frozen} (замороженный) было в UML 1. Свой
                             ство находится в состоянии frozen, если оно не может быть изменено
                             в течение жизни объекта; такие свойства часто называются неизмен
                             ными (immutable). Оно было исключено из UML 2, но понятие frozen
                             очень полезное, поэтому я буду применять его попрежнему. Наряду с
                             обозначением отдельных свойств, ключевое слово frozen можно приме
                             нять к классу для указания того, что все свойства всех экземпляров
                             класса находятся в состоянии frozen. (До меня дошли слухи, что клю
                             чевое слово frozen скоро будет восстановлено.)

                        Объектыссылки и объектызначения


                             Одна из наиболее общих черт объектов заключается в том, что они об
                             ладают индивидуальностью (identity).  Это правда,  но  все обстоит не
                             столь  просто, как может показаться.  На практике  оказывается, что
                             индивидуальность важна для объектовссылок, но она не так важна
                             для объектовзначений.

                             Объектыссылки (reference objects) – это такие объекты, как Customer
                             (Клиент). В данном случае индивидуальность очень важна, поскольку
                             в реальном мире конкретному классу обычно должен соответствовать
                             только один программный объект. Любой объект, который обращает
                             ся к объекту Customer, может воспользоваться соответствующей ссыл
                             кой или указателем. В результате все объекты, обращающиеся к дан
                             ному объекту Customer, получат доступ к одному и тому же программ
                             ному объекту. Таким образом, изменения, вносимые в объект Customer,
                             будут доступны всем пользователям данного объекта.

                             Если имеются две ссылки на объект Customer и требуется установить их
                             тождественность, то обычно сравниваются индивидуальности тех объ
                             ектов, на которые указывают эти ссылки. Создание копий может быть
                             запрещено; если же оно разрешено, то, как правило, применяется ред
                             ко – возможно, для архивирования или репликации через компьютер
                             ную сеть. Если копии созданы, то необходимо обеспечить синхрониза
                             цию вносимых в них изменений.

                             Объектызначения (value objects) – это такие объекты, как Date (Дата).
                             Как правило, один и тот же объект в реальном мире может быть пред
                             ставлен целым множеством объектов  значений. Например, вполне
                             нормально, когда имеются сотни  объектов со значением  «1  января
                             2004 года». Все эти объекты являются взаимозаменяемыми копиями.
                             При этом новые даты создаются и уничтожаются достаточно часто.















                        Квалифицированные ассоциации                                          101


                             Если имеются две даты и надо установить, тождественны ли они, то
                             вполне достаточно просто посмотреть на их значения, а не устанавли
                             вать их индивидуальность. Обычно это означает, что в программе не
                             обходимо определить оператор проверки равенства, который бы прове
                             рял в датах год, месяц и день (каким бы ни было их внутреннее пред
                             ставление). Обычно каждый объект, ссылающийся на 1 января 2004
                             года, имеет собственный специальный объект, однако иногда даты мо
                             гут быть объектами общего пользования.
                             Объектызначения должны быть постоянными. Другими словами, не
                             должно допускаться изменение значения объектадаты  «1 января
                             2004 года» на «2 января 2004 года». Вместо этого следует создать но
                             вый объект «2 января 2004 года» и использовать его вместо первого
                             объекта. Причина запрета  подобного изменения заключается  в  сле
                             дующем: если бы эта дата была объектом общего пользования, то ее об
                             новление могло бы повлиять на другие объекты непредсказуемым об
                             разом. Данная проблема известна как совмещение имен (aliasing).
                             В прежнее время различие между объектамиссылками и объектами
                             значениями было более четким. Объектызначения являлись встроен
                             ными элементами системы типов. В настоящее время можно расши
                             рить систему типов с помощью собственных классов, поэтому данный
                             аспект требует более внимательного отношения.
                             В языке UML  используется концепция  типа данных, который  пред
                             ставляется  ключевым словом на  символе  класса. Строго говоря,  тип
                             данных не идентичен объектузначению, поскольку типы данных не
                             могут иметь индивидуальности. Объектызначения могут иметь инди
                             видуальность, но она не используется для проверки равенства. В язы
                             ке Java примитивы могут быть типами данных, но не даты, хотя они
                             могут быть объектамизначениями.  Если требуется их  выделить,  то
                             при создании взаимосвязи с объектомзначением я использую компо
                             зицию. Можно также применить ключевое слово для типа значения;
                             на мой взгляд, стандартными являются слова «value» и «struct».


                        Квалифицированные ассоциации

                             Квалифицированная ассоциация  в языке UML  эквивалентна  таким
                             известным понятиям в языках программирования, как ассоциативные
                             массивы (associative arrays), проекции (maps), хеши (hashes) и словари
                             (dictionaries). Рисунок 5.10 иллюстрирует способ представления ассо
                             циации между классами  Order (Заказ)  и  Order Line (Строка  заказа),
                             в котором используется квалификатор. Квалификатор указывает, что
                             в соответствии с заказом для каждого экземпляра продукта (Product)
                             может существовать только одна строка заказа.
                             С точки зрения программного обеспечения такая квалифицированная
                             ассоциация может повлечь создание интерфейса следующего вида:















                        102                         Глава 5. Диаграммы классов: дополнительные понятия



                                                                                  Order Line
                                                                          0..1
                                 Order     Product                               amount:Number
                                                                      line item


                             Рис. 5.10. Квалифицированная ассоциация

                                class Order ...
                                public OrderLine getLineItem(Product aProduct);
                                public void addLineItem(Number amount, Product forProduct);
                             Таким  образом,  любой доступ к определенной строке заказа требует
                             подстановки некоторого  продукта в  качестве аргумента, в предполо
                             жении, что это структура данных, состоящая из ключа и значения.
                             Разработчиков  часто ставит в тупик кратность квалифицированных
                             ассоциаций. На рис. 5.10 заказ может иметь несколько позиций заказа
                             (Line Items), но кратность квалифицированной ассоциации – это крат
                             ность в контексте квалификатора.  Поэтому  диаграмма говорит, что
                             в заказе имеется 0..1 позиций заказа на продукт. Кратность, равная 1,
                             означает, что в заказе должна быть одна позиция заказа для каждого
                             продукта. Кратность * означает, что для любого продукта может суще
                             ствовать несколько позиций заказа, но доступ к позициям заказа ин
                             дексируется по продукту.
                             В ходе концептуального  моделирования я использую конструкцию
                             квалификатора только для того, чтобы показать ограничения относи
                             тельно отдельных позиций – «единственная строка заказа для каждо
                             го продукта в заказе».

                        Классификация и обобщение

                             Мне часто приходится слышать суждения разработчиков о механизме
                             подтипов как об отношении является (это [есть]). Я настоятельно ре
                             комендую держаться подальше от такого представления. Проблема за
                             ключается в том, что выражение является может иметь самый разный
                             смысл.
                             Рассмотрим следующие предложения.
                             1. Шеп – это бордерколли.
                             2. Бордерколли – это собака.
                             3. Собаки являются животными.
                             4. Бордерколли – это порода собак.
                             5. Собака – это биологический вид.
                             Теперь попытаемся скомбинировать эти фразы. При объединении пер
                             вого и второго предложений получаем «Шеп – это собака»; второе и
                             третье предложения в результате  дают «бордерколли  – это живот















                        Множественная и динамическая классификация                            103


                             ные». Объединение первых трех фраз дает «Шеп – это животное». Чем
                             дальше, тем лучше. Теперь попробуем первое и четвертое предложе
                             ния: «Шеп – это порода собак». В результате объединения  второго
                             и пятого предложений получим «бордерколли – это  биологический
                             вид». Это уже не так хорошо.
                             Почему некоторые из этих фраз можно комбинировать, а другие нель
                             зя? Причина в том, что некоторые предложения представляют собой
                             классификацию – объект Шеп (Shep) является экземпляром типа Бор
                             дерКолли (Border Collie), в то время как другие предложения представ
                             ляют собой  обобщение  –  тип БордерКолли является подтипом  типа
                             Собака (Dog). Обобщение транзитивно, а классификация – нет. Если
                             обобщение следует за классификацией, то их можно объединить, а ес
                             ли наоборот – классификация следует за обобщением, то нельзя.

                             Смысл  сказанного в том, что с  отношением  является  следует обра
                             щаться весьма осторожно. Его использование может привести к невер
                             ному применению подклассов и к ошибочному распределению ответст
                             венностей. В приведенном примере хорошими тестами для проверки
                             подтипов могут служить следующие фразы: «Собаки являются разно
                             видностью Животных» и «Каждый экземпляр БордерКолли является
                             экземпляром Собаки».
                             В языке UML обобщение обозначается соответствующим символом.
                             Для того чтобы показать классификацию, применяется зависимость
                             с ключевым словом «instantiate».

                        Множественная и динамическая классификация

                             Классификация служит для обозначения отношения между некото
                             рым объектом и  его типом. В основных языках программирования
                             предполагается, что  объект относится к  единственному классу.  Но
                             в UML имеется больше возможностей для классификации.
                             При однозначной классификации (single classification) любой объект
                             принадлежит единственному типу, который может быть унаследован
                             от супертипов. Во множественной классификации (multiple classifica
                             tion) объект может быть описан несколькими типами, которые не обя
                             зательно должны быть связаны наследованием.
                             Множественная классификация отличается от множественного насле
                             дования. При множественном наследовании тип может иметь несколь
                             ко супертипов, но для каждого объекта должен быть только один тип.
                             Множественная классификация допускает принадлежность объекта
                             нескольким типам, при этом не требуется определять специальный тип.
                             В качестве примера рассмотрим тип Person (Личность), подтипами ко
                             торого являются  Male (Мужчина)  или  Female (Женщина),  Doctor (Док
                             тор) или  Nurse (Медсестра),  Patient  (Пациент) или вообще  никто
                             (рис. 5.11). Множественная  классификация позволяет некоторому















                        104                         Глава 5. Диаграммы классов: дополнительные понятия


                             объекту иметь  любой из этих типов в любом допустимом сочетании,
                             при этом нет необходимости определять отдельные типы для всех воз
                             можных комбинаций.
                             Если вы используете множественную  классификацию, то  должны
                             быть уверены в том, что четко определили, какие комбинации являют
                             ся допустимыми. В языке UML версии 2 это осуществляется помеще
                             нием каждого обобщающего отношения в множество обобщения. На
                             диаграмме классов вы помечаете линию обобщения с помощью имени
                             множества обобщения,  которое в UML 1 называется дискриминато
                             ром. Единственная классификация соответствует одному безымянно
                             му множеству обобщения.
                             По определению множества обобщения не пересекаются: каждый эк
                             земпляр супертипа может быть экземпляром только одного подтипа из
                             данного множества. Если  вы соединяете  линии обобщений с одной
                             стрелкой, то они должны входить в одно и то же множество обобще
                             ния, как показано на рис. 5.11. Альтернативный способ – изобразить
                             несколько стрелок с одинаковой текстовой меткой.

                             В качестве иллюстрации отметим на диаграмме следующие допусти
                             мые комбинации подтипов: (Female, Patient, Nurse); (Male, Physiothera
                             pist (Физиотерапевт)); (Female,  Patient) и (Female,  Doctor,  Surgeon (Хи
                             рург)). Комбинация (Patient, Doctor, Nurse) является недопустимой, по
                             скольку она содержит два типа из множества обобщения role (роль).
                             Возникает еще  один вопрос: может ли  объект изменить  свой класс?
                             Например, когда банковский счет клиента становится пустым, он су
                             щественно меняет свое поведение. В частности, отклоняются некото
                             рые операции, такие как «снять со счета» и «закрыть счет».


                                                                                     Surgeon
                                             дискриминатор
                                                                      Doctor

                                                                                      Family
                               Female                                                 Doctor
                                                         role
                                                Person                Nurse
                                         sex
                                Male                 patient
                                                                      Physio-
                                                                     therapist
                                                Patient


                             Рис. 5.11. Множественная классификация















                        Класс7ассоциация                                                      105


                             Динамическая классификация (dynamic classification) разрешает объ
                             ектам изменять свой тип в рамках структуры подтипов, а статическая
                             классификация (static classification) этого не допускает. Статическая
                             классификация проводит границу между типами и состояниями, а ди
                             намическая классификация объединяет эти понятия.
                             Следует ли использовать множественную динамическую классифика
                             цию? Я полагаю, что она полезна для концептуального моделирова
                             ния. Однако с точки зрения программного обеспечения на пути ее реа
                             лизации слишком много препятствий. В  подавляющем большинстве
                             диаграмм UML вы встретите только однозначную статическую класси
                             фикацию, поэтому она должна стать вашим обычным инструментом.


                        Классассоциация


                             Классыассоциации (association classes) позволяют дополнительно оп
                             ределять для ассоциаций атрибуты, операции и другие свойства, как
                             показано на рис. 5.12. Из данной диаграммы видно, что Person (Лич
                             ность) может принимать участие в нескольких совещаниях (Meeting).
                             При этом необходимо какимто образом хранить информацию о том,
                             насколько  внимательной была данная  личность;  это можно сделать,
                             добавив к ассоциации атрибут attentiveness (внимательность).


                                         2.. *
                                Person                                         Meeting
                                                                          *

                                                                           класс#ассоциация
                                                      Attendance

                                                  attentiveness



                             Рис. 5.12. Класс'ассоциация
                             На  рис. 5.13 показан  другой способ представления данной информа
                             ции: образование  самостоятельного класса  Attendance (Присутствие).
                             Обратите внимание, как при этом изменили свои значения кратности.


                                                      Attendance
                                         1     *                    2.. *  1
                                Person            attentiveness                Meeting



                             Рис. 5.13. Развитие класса'ассоциации до обычного класса















                        106                         Глава 5. Диаграммы классов: дополнительные понятия


                             Какие же преимущества может дать классассоциация в качестве ком
                             пенсации за необходимость помнить еще один вариант уже описанной
                             нотации? Классассоциация  дает  возможность определить дополни
                             тельное ограничение, согласно которому двум участвующим в ассо
                             циации объектам может соответствовать только один экземпляр клас
                             саассоциации. Мне кажется, необходимо привести еще один пример.
                             Посмотрим на две диаграммы, изображенные на рис. 5.14. Форма этих
                             диаграмм практически одинакова. Хотя можно себе представить ком
                             панию (Company),  играющую различные роли (Role) в одном и том же
                             контракте (Contract), но  трудно вообразить личность (Person), имею
                             щую различные уровни компетенции в одном и том же навыке (Skill);
                             действительно, скорее всего, это можно считать ошибкой.

                             В языке UML допустим только последний вариант. Может существо
                             вать только один уровень компетенции для каждой комбинации лич
                             ности и навыка. Верхняя диаграмма на рис. 5.14 не допускает участия
                             компании более чем в одной роли в одном и том же контракте. Если без
                             этого не обойтись, надо превратить Role в полный класс, как это сдела
                             но на рис. 5.13.


                                         *
                               Company                                         Contract
                                                                          *
                                                        Role
                                                   description





                                         *                                *
                                Person                                          Skill

                                                      Competency

                                                   level


                             Рис. 5.14. Хитрости класса'ассоциации (класс Role, возможно, не должен
                                     быть классом'ассоциацией)

                             Реализация классовассоциаций  не слишком очевидна. Мой совет:
                             реализовывать классассоциацию так, как будто это обычный класс,
                             но методы, предоставляющие информацию связанным классам, долж
                             ны принадлежать классуассоциации. Поэтому для  случая, изобра
                             женного на рис. 5.12, я бы представил следующие методы класса Per
                             son:















                        Класс7ассоциация                                                      107


                                class Person
                                List getAttendances()
                                List getMeetings()
                             Таким образом, клиенты объекта Person могут обнаружить сотрудни
                             ков на совещании; если им требуются детали, то они могут получить
                             собственно часы работы (Attendance). Если вы так делаете, не забудьте
                             об ограничении, при  котором  для любой пары объектов  Person (Лич
                             ность) и Meeting (Совещание) может существовать только один объект
                             Attendance (Присутствие).
                             Часто этот вид конструкции можно встретить там, где речь идет о вре
                             менных изменениях (см., например, рис. 5.15). Однако я считаю, что
                             создание дополнительных классов или классовассоциаций может сде
                             лать модель сложной для понимания, а также направить реализацию
                             в неправильное русло.

                                                       Employment
                                          1                                   1
                                Person                                            Company
                                                    period : dateRange
                                                *                   *
                             Рис. 5.15. Использование класса для временного отношения

                             Если я встречаю временную информацию такого типа, то использую
                             для ассоциации ключевое слово «temporal» (временной) (рис. 5.16). Мо
                             дель означает, что некоторое время личность может работать только
                             в одной компании. Однако по прошествии времени личность сможет
                             работать в нескольких компаниях. Это предполагает интерфейс, опи
                             сываемый следующими строками:
                                class Person ...
                                Company getEmployer();        // определение текущего работодателя
                                Company getEmployer(Date);    // определение работодателя на указанный момент
                                void changeEmployer(Company newEmployer,Date changeDate);
                                void leaveEmployer (Date changeDate);
                             Ключевое слово «temporal» не входит в состав языка UML, но я упомя
                             нул его здесь по двум причинам. Вопервых, это понятие часто оказы
                             валось полезным для  меня как проектировщика. Вовторых, это де
                             монстрирует, как можно применять ключевые слова для расширения
                             языка UML. Дополнительную информацию по данному вопросу мож
                             но найти на http://martinfowler.com/ap2/timeNarrative.html.
                                                               employer
                                         *                     «temporal»
                                Person                                   Company
                                                                   0..1

                             Рис. 5.16. Ключевое слово «temporal» для ассоциаций















                        108                         Глава 5. Диаграммы классов: дополнительные понятия


                        Шаблон класса (параметризованный класс)

                             Некоторые языки, в особенности C++, включают в себя понятие пара
                             метризованного класса (parameterized class) или шаблона (template).
                             (Шаблоны могут быть включены в языки Java и C# в ближайшем бу
                             дущем.)
                             Наиболее очевидная польза от применения этого понятия проявляется
                             при работе с коллекциями в  строго типизированных языках.  Таким
                             образом, в общем случае поведение для множества можно определить
                             с помощью шаблона класса Set (Множество).
                                class Set <T> {
                                void insert (T newElement);
                                void remove (T anElement);
                             После этого можно использовать данное общее определение для зада
                             ния более конкретных классовмножеств:
                                Set <Employee> employeeSet;
                             Для объявления классашаблона в языке UML используется нотация,
                             показанная на рис. 5.17. Прямоугольник с буквой «T» на диаграмме
                             служит для указания параметра типа. (Можно  указать более одного
                             параметра.)

                                                            T
                                                     Set              параметр шаблона

                             шаблон класса
                                                  insert(T)
                                                  remove(T)


                             Рис. 5.17.  Класс'шаблон
                             Применение параметризованного класса, такого как Set<Employee>, на
                             зывается образованием производных (derivation). Образование произ
                             водных можно изобразить двумя способами. Первый способ отражает
                             синтаксис языка C++ (рис. 5.18). Выражение образования производ
                             ных описывается в угловых скобках в виде <parametername::parameter
                             value>. Если указывается только один параметр, то обычно имя пара
                             метра опускают. Альтернативная нотация (рис. 5.19) усиливает связь
                             с шаблоном и допускает переименование связанного элемента.



                                Set <T::Employee>


                             Рис. 5.18. Связанный элемент (вариант 1)















                        Перечисления                                                          109



                                                         T
                                                  Set


                                               insert(T)
                                  шаблон       remove(T)
                                  класса


                                                     «bind»

                                                     <T::Employee>


                                               EmployeeSet     связывание
                             связанный
                                                               параметра
                             элемент
                             Рис. 5.19. Связанный элемент (вариант 2)

                             Ключевое слово  «bind» (связать) является  стереотипом  отношения
                             уточнения. Это отношение означает, что класс EmployeeSet (Множество
                             служащих) будет согласован с  интерфейсом класса  Set. Можете счи
                             тать EmployeeSet подтипом типа Set. Это соответствует другому способу
                             реализации типизированных коллекций, который заключается в объ
                             явлении всех соответствующих подтипов.
                             Однако использование образования производных не эквивалентно оп
                             ределению подтипа. В связанный элемент нельзя добавлять новые воз
                             можности – он полностью определен своим шаблоном; можно только
                             добавить информацию, ограничивающую его тип. Если же вы хотите
                             добавить возможности, то должны создать некоторый подтип.

                        Перечисления

                             Перечисления (рис. 5.20) используются для представления  фиксиро
                             ванного набора значений, у которых нет других свойств кроме их сим
                             волических значений. Они изображаются в виде класса с ключевым
                             словом «enumeration».

                                «enumeration»
                                   Color

                               red
                               white
                               blue

                             Рис. 5.20. Перечисление















                        110                         Глава 5. Диаграммы классов: дополнительные понятия


                        Активный класс

                             Активный класс (active class) имеет экземпляры, каждый из которых
                             выполняет и управляет собственным потоком управления. Вызовы ме
                             тодов могут выполняться в клиентском потоке или в потоке активного
                             объекта. Удачным примером может  служить командный процессор,
                             который принимает извне командные объекты, а затем исполняет ко
                             манды в контексте собственного потока управления.
                             Как видно из рис. 5.21, при переходе от UML 1 к UML 2 нотация ак
                             тивных классов изменилась. В UML 2 активный класс обозначен до
                             полнительными вертикальными линиями по краям; в UML 1 он имел
                             толстую границу и назывался активным объектом.


                                 Command              Command
                                 Processor             Processor




                                  активный объект (UML 1)  активный класс (UML 2)
                             Рис. 5.21. Активный класс

                        Видимость

                             Видимость (visibility) – это понятие простое по существу, но содержа
                             щее сложные  нюансы.  Идея заключается в том, что у  любого класса
                             имеются открытые (public) и закрытые (private) элементы. Открытые
                             элементы могут быть использованы любым другим классом, а закры
                             тые  элементы – только классомвладельцем. Однако в каждом  языке
                             действуют свои правила. Несмотря на то что во многих языках употреб
                             ляются такие термины, как public (открытый), private (закрытый) и pro'
                             tected  (защищенный), в разных языках  они имеют  различные значе
                             ния. Эти различия невелики, но они приводят к недоразумениям, осо
                             бенно у тех, кто использует в своей работе более одного языка програм
                             мирования.
                             В языке UML делается попытка решить эту задачу, не устраивая жут
                             кую путаницу. По существу, в рамках UML для любого атрибута или
                             операции можно указать индикатор видимости. Для этой цели можно
                             использовать любую подходящую метку, смысл которой определяется
                             тем или иным языком программирования. Тем не менее в UML пред
                             лагается четыре аббревиатуры для обозначения видимости: + (public –
                             открытый),  (private – закрытый),   (package – пакетный) и # (protec
                                                                ~
                             ted  – защищенный). Эти  четыре уровня определены  и используются
                             в рамках метамодели языка UML, но их определения очень незначи
                             тельно отличаются от соответствующих определений в других языках
                             программирования.















                        Сообщения                                                              111


                             При  использовании видимости применяйте правила  того языка  про
                             граммирования, на котором вы работаете. Рассматривая модель в UML
                             с какойнибудь точки зрения, аккуратно расшифровывайте значения
                             маркеров видимости и старайтесь понять, как эти значения могут из
                             мениться при переходе от одного языка программирования к другому.
                             В подавляющем большинстве случаев я не рисую на диаграммах мар
                             керы видимости; я их использую,  только если необходимо подчерк
                             нуть  различия в видимости определенных свойств.  И даже в таких
                             случаях я могу, как правило, обойтись без + и , которые, по крайней
                             мере, достаточно легко запомнить.

                        Сообщения

                             В стандартном языке UML не отображается информация о сообщениях
                             на диаграммах классов. Однако иногда я встречал диаграммы, подоб
                             ные той, которая приведена на рис. 5.22.

                                                        calculatePrice
                                                        fill
                                          Order                              Order Item
                                                    1
                                                                      *
                                          *                                      *
                             calculatePrice    getDiscountedValue
                             itemsWaiting
                                                          !      getPrice (quantity)
                                                       ненор    getLeadTime
                                                      мативный
                                          1                                      1

                                         Customer                             Product
                                                         getSpecialPrice

                             Рис. 5.22. Классы с сообщениями

                             При этом добавляются стрелки со стороны ассоциаций. Стрелки поме
                             чаются сообщениями, которые  один объект посылает  другому. По
                             скольку для посылки сообщения классу наличие ассоциации с ним не
                             обязательно, то может потребоваться дополнительная стрелка зависи
                             мости, чтобы отобразить сообщения между классами, не связанными
                             ассоциацией.
                             Информация о сообщениях охватывает несколько прецедентов, поэто
                             му, в отличие от коммуникационных диаграмм, они не нумеруются,
                             чтобы показать их последовательность.






















                             6









                             Диаграммы объектов




                             Диаграмма объектов (object diagram) – это снимок объектов системы
                             в какойто момент времени. Поскольку она показывает экземпляры,
                             а не  классы, то диаграмму объектов часто называют диаграммой эк
                             земпляров.
                             Диаграмму объектов можно использовать для отображения одного из
                             вариантов конфигурации объектов. (На рис. 6.1 показано множество
                             классов, а на рис. 6.2 представлено множество связанных объектов.)
                             Последний вариант очень полезен,  когда допустимые связи  между
                             объектами могут быть сложными.
                             Можно определить, что элементы, показанные на рис. 6.2, являются
                             экземплярами, поскольку их имена подчеркнуты. Каждое имя пред
                             ставляется в виде: имя экземпляра : имя класса. Обе части имени не яв
                             ляются обязательными, поэтому имена John, :Person и aPerson являют
                             ся допустимыми. Если указано только имя класса, то необходимо по
                             ставить двоеточие. Можно также задать значения и атрибуты, как по
                             казано на рис. 6.2.
                             Строго говоря, элементы диаграммы объектов – это спецификации эк
                             земпляров,  а не сами экземпляры. Причина в том, что разрешается
                             оставлять обязательные атрибуты пустыми или показывать специфи
                             кации экземпляров абстрактных классов. Можно рассматривать спе

                                         Party     потомок
                                                 *
                                      location


                                                      0..1 родитель

                                 Person      Organization

                             Рис. 6.1. Диаграмма классов, показывающая структуру класса Party
                                     (вечеринка)















                        Когда применяются диаграммы объектов                                  113


                                                  engineering : Organization
                                                location = "Boston"
                                               родитель

                                       tools : Organization  apps : Organization
                                     location = "Chicago"  location = "Saba"
                                         родитель
                                   Don : Person          John : Person
                              location = "Champaign"  location = "Champaign"

                             Рис. 6.2. Диаграмма объектов с примером экземпляра класса Party

                             цификации экземпляров (instance specifications) как частично опреде
                             ленные экземпляры.
                             С другой стороны, диаграмму объектов можно считать коммуникаци
                             онной диаграммой (стр. 152) без сообщений.

                        Когда применяются диаграммы объектов

                             Диаграммы объектов удобны для  показа примеров связанных друг
                             с другом объектов. Во многих ситуациях точную структуру можно оп
                             ределить с помощью диаграммы классов, но при этом структура оста
                             ется  трудной  для понимания.  В таких случаях  пара примеров диа
                             граммы объектов может прояснить ситуацию.










                             По договору между издательством «СимволПлюс» и Интернетмага
                             зином «Books.Ru  Книги  России» единственный легальный способ
                             получения данного файла с книгой ISBN 593286060X, название
                             «UML. Основы, 3е издание» – покупка в Интернетмагазине «Books.Ru
                              Книги России». Если Вы получили данный файл какимлибо другим
                             образом, Вы нарушили международное законодательство и законода
                             тельство Российской Федерации об охране авторского права. Вам необ
                             ходимо удалить данный файл, а также сообщить издательству «Сим
                             волПлюс» (piracy@symbol.ru), где именно Вы получили данный файл.






















                             7









                             Диаграммы пакетов





                             Классы составляют структурный  костяк объектноориентированной
                             системы. Хотя они исключительно полезны, но нужно нечто большее
                             для структурирования больших систем, которые могут состоять из со
                             тен классов.
                             Пакет (package) – это инструмент группирования, который позволяет
                             взять любую конструкцию UML и объединить ее элементы в единицы
                             высокого уровня. В основном пакеты служат для объединения классов
                             в группы, и именно этот способ их применения я здесь описываю, но
                             помните, что пакеты могут применяться для любой другой конструк
                             ции языка UML.
                             В модели UML каждый класс может включаться только в один пакет.
                             Пакеты могут также входить в состав других пакетов, поэтому мы ос
                             таемся в иерархической структуре, в которой пакеты верхнего уровня
                             распадаются  на подпакеты со своими собственными  подпакетами, и
                             так далее, до самого низа иерархии классов. Пакет может содержать
                             и подпакеты, и классы.
                             В терминах программирования пакеты в UML соответствуют  таким
                             группирующим конструкциям, как  пакеты в Java и пространства
                             имен в C++ и .NET.
                             Каждый пакет представляет пространство имен (namespace), а это озна
                             чает,  что каждый  класс внутри собственного пакета  должен иметь
                             уникальное имя. Если я хочу создать пакет с именем Date, а класс Date
                             уже существует в пакете System, то я обязан поместить его в отдельный
                             пакет. Чтобы отличить один класс от другого, я могу  использовать
                             полностью определенное имя (fully qualified name), то есть имя, кото
                             рое указывает на структуру, владеющую пакетом. В языке UML в име
                             нах пакетов используются двойные двоеточия, поэтому классы дат мо
                             гут иметь имена System::Date и MartinFowler::Util::Date.
                             На диаграммах пакеты изображаются в  виде  папок с закладками
                             (рис. 7.1). Можно показывать только имя пакета или имя вместе с его















                                                                                              115



                                                       util                   util
                                                      Date
                                       util                                         Date


                                                     Содержимое, перечисленное   Содержимое в виде диаграммы
                                                     в прямоугольнике      в прямоугольнике



                                                        java

                                                         util
                              java::util

                                                               Date
                                      Date
                                                                                java::util::Date


                               Полностью определенное      Вложенные пакеты   Полностью определенное
                               имя пакета                                     имя класса
                             Рис. 7.1. Способы изображения пакетов на диаграммах

                             содержимым. В любом случае можно использовать либо полностью оп
                             ределенные  имена, либо обычные  имена. Изображение содержимого
                             с помощью значков классов позволяет показать все особенности клас
                             са, вплоть до изображения диаграммы классов внутри пакета. Простое
                             перечисление имен имеет смысл, если вы хотите лишь показать, какие
                             классы входят в той или иной пакет.
                             Вполне можно встретить класс, например с именем Date (как в java.util),
                             а не с полностью определенным именем. Этот стиль является соглаше
                             нием, в основном принятым в Rational Rose, которое не входит в стан
                             дарт языка.
                             UML разрешает классам в пакетах быть открытыми (public) или за
                             крытыми (private). Открытые классы представляют часть интерфейса
                             пакета и  могут быть использованы классами из  других пакетов; за
                             крытые классы недоступны извне. В различных средах программиро
                             вания действуют различные правила в отношении видимости их груп
                             пирующими конструкциями; необходимо придерживаться правил
                             своего программного окружения, даже если это идет вразрез с прави
                             лами UML.
                             В таких  случаях полезно сократить интерфейс пакета, экспортируя
                             только небольшое подмножество  операций, связанных с открытыми
                             классами пакета. Можно сделать это, присвоив всем классам модифи
                             катор видимости private (закрытый), так чтобы они были доступны















                        116                                               Глава 7. Диаграммы пакетов


                             только классам данного пакета,  а  также  создав дополнительные от
                             крытые классы для внешнего использования. Эти дополнительные
                             классы, называемые Facades (Фасады) [21], делегируют открытые опе
                             рации своим более застенчивым соратникам по пакету.
                             Как распределить классы по пакетам? Это действительно сложный во
                             прос, на который может ответить только специалист с большим опытом
                             работы в области проектирования. В этом деле могут помочь два пра
                             вила: общий принцип замыкания (Common Closure Principle) и общий
                             принцип повторного использования (Common Reuse Principle) [30]. Об
                             щий принцип замыкания гласит, что причины изменения классов па
                             кета должны быть одинаковые. Общий принцип повторного использо
                             вания утверждает,  что классы  должны использоваться повторно все
                             вместе. Большинство причин, по  которым классы  должны объеди
                             няться в пакет, проистекают из зависимостей между классами, к кото
                             рым я сейчас и перехожу.

                        Пакеты и зависимости


                             Диаграмма пакетов (package diagram) показывает пакеты и зависимо
                             сти между ними. Я ввел понятие зависимости на стр. 74. При наличии
                             пакетов для классов представления и пакетов для классов предметной
                             области пакет представления зависит от пакета предметной области,
                             если любой класс пакета представления зависит от какоголибо класса
                             пакета предметной области. Таким  образом, межпакетная зависи
                             мость обобщает зависимости между их содержимым.
                             В языке UML имеются разнообразные виды зависимостей, каждая из
                             которых обладает самостоятельной семантикой и стереотипом. По мо
                             ему мнению, намного  проще начинать с зависимости  без стереотипа
                             и использовать  более конкретные виды зависимостей только  по  мере
                             необходимости. В средних и больших по размеру системах рисование
                             диаграммы пакетов может быть одним из самых ценных приемов, по
                             зволяющих управлять их многомерной структурой. В идеале такая
                             диаграмма должна быть сгенерирована на основании собственно исход
                             ного кода, так чтобы она реально отражала происходящее в системе.
                             Хорошая структура  пакетов имеет прозрачный поток (clear  flow)
                             зависимостей – концепцию, которую трудно определить, но легко рас
                             познать. На рис. 7.2 показана простая диаграмма пакетов для про
                             мышленного приложения, которая хорошо структурирована и имеет
                             прозрачный поток зависимостей.
                             Часто можно идентифицировать прозрачный поток, поскольку все за
                             висимости идут в одном направлении. Это хороший индикатор пра
                             вильно структурированной системы, но пакеты data mapper (преобразо
                             ватель данных) на рис. 7.2 представляют исключение из этого эмпири
                             ческого правила. Пакеты преобразователей данных действуют в каче
                             стве изолирующего уровня между пакетами предметной  области















                        Пакеты и зависимости                                                   117


                             (domain) и пакетами базы данных (database) и служат примером шабло
                             на Mapper (Преобразователь) [19].
                             Многие авторы утверждают, что в зависимостях не должно быть цик
                             лов (Acyclic Dependency Principle – принцип ацикличности зависимос
                             тей,  [30]). Я не считаю это правило абсолютным, но думаю, что циклы
                             необходимо локализовать, в частности не должно быть циклов, пересе
                             кающих уровни.
                             Чем больше зависимостей входит в пакет, тем более стабильным дол
                             жен быть его интерфейс, поскольку любые изменения интерфейса от
                             разятся на всех пакетах, зависящих от него (Stable Dependencies Princi
                             ple – принцип стабильных зависимостей, [30]). Поэтому на рис. 7.2 па
                             кету  asset domain (предметная область собственности) требуется  более
                             стабильный интерфейс, чем пакету leasing data mapper (преобразовате
                             ль данных аренды). Вы увидите, что зачастую более стабильные паке
                             ты содержат относительно больше интерфейсов и абстрактных классов
                             (Stable Abstractions Principle – принцип стабильных абстракций, [30]).
                             Отношения зависимостей не транзитивны (стр. 75). Чтобы убедиться
                             в важности  этого свойства для  зависимостей, взгляните снова на
                             рис. 7.2. Если изменяется класс пакета предметной области собствен
                             ности, то может измениться и  класс из пакета предметной  области
                             аренды (leasing domain). Но эти изменения не обязательно пройдут че
                             рез представление аренды (leasing presentation). (Они проходят, толь



                                  leasing                                     asset
                                presentation                               presentation


                                                      UI framework



                               leasing domain                              asset domain






                                leasing data                                asset data
                                  mapper                                     mapper



                                                       database


                             Рис. 7.2. Диаграмма пакетов для промышленного предприятия















                        118                                               Глава 7. Диаграммы пакетов


                             ко если предметная область аренды изменяет свой интерфейс.) Неко
                             торые пакеты используются в таком количестве мест, что можно запу
                             таться в линиях зависимостей, идущих к ним. В таком случае действу
                             ет соглашение, в соответствии с  которым на пакете указывается
                             ключевое слово «global» (глобальный).
                             В пакетах UML определены также конструкции, позволяющие паке
                             там импортировать классы из одного пакета в другой и объединять их,
                             используя зависимости с ключевыми словами для их обозначения. Од
                             нако  правила для такого типа элементов существенно отличаются
                             в различных языках программирования. В целом, я думаю, что на
                             практике значительно более полезна основная нотация зависимостей.

                        Аспекты пакетов

                             Рассматривая рис. 7.2, вы понимаете, что на диаграмме присутствуют
                             структуры двух видов. Одна – структура уровня приложения: пред
                             ставление (presentation), предметная область (domain), преобразователь
                             данных (data mapper)  и база данных (database). Другая  – структура
                             предметных областей: аренда (leasing) и собственность (asset).
                             Это можно сделать более прозрачным, если разделить два данных ас
                             пекта так, как это сделано на рис. 7.3. На представленной диаграмме
                             можно ясно увидеть каждый аспект. Однако эти два аспекта не явля




                                presentation         UI framework                 leasing






                                  domain
                                                              !
                                                           ненор                  asset
                                                          мативный



                                data mapper







                                 database

                             Рис. 7.3. Разделение рис. 7.2 на два аспекта















                        Реализация пакетов                                                    119


                             ются истинными пакетами, поскольку рассматриваемые классы мож
                             но объединить в один пакет. (Возможно, вам придется извлечь по од
                             ному классу из каждого аспекта.) Эта проблема является отражением
                             проблемы иерархических пространств имен в языках программирова
                             ния. Хотя диаграммы, подобные представленным на рис 7.3, не вхо
                             дят в стандарт языка UML, они зачастую очень удобны для объясне
                             ния структуры сложных приложений.

                        Реализация пакетов


                             Часто встречается ситуация, когда один пакет определяет интерфейс,
                             который может быть реализован многими другими пакетами, как это
                             показано на рис. 7.4. В данном случае отношение реализации означа
                             ет,  что шлюз базы данных  (Database Gateway) определяет  интерфейс,
                             а другие классы шлюзов обеспечивают реализацию. На практике это
                             может означать,  что пакет шлюза  базы данных  (Database Gateway) со
                             держит интерфейсы и абстрактные классы, которые полностью реали
                             зуются в других пакетах.



                                                               Database
                                 Application
                                                               Gateway









                                                              SQL Server         Test Stub
                                         Oracle Gateway
                                                               Gateway            Gateway

                             Рис. 7.4. Пакет, реализованный другими пакетами

                             Общепринято размещать интерфейс и его реализацию в разных паке
                             тах. Действительно, клиентский пакет часто содержит интерфейс, ко
                             торый должен быть реализован другим пакетом  (такую же нотацию
                             затребованного интерфейса я обсуждал на стр. 97).
                             Допустим, что  вы хотите  предоставить некоторый  пользовательский
                             интерфейс  (UI) выключателей (controls) для  включения  и выключе
                             ния некоторого объекта. Мы хотим, чтобы он работал с различными
                             устройствами, такими как обогреватели (heaters) или лампы (lights).
                             Выключатели UI должны вызывать методы обогревателя, но мы не хо
                             тим, чтобы выключатели зависели от обогревателя. Мы можем избе
                             жать этой зависимости, определяя в пакете выключателей интерфейс,















                        120                                               Глава 7. Диаграммы пакетов


                             который затем реализуется каждым классом, работающим с этими вы
                             ключателями, как показано на рис. 7.5. Здесь представлен пример
                             шаблона Separated Interface (Разделенный интерфейс) [19].

                                  Control

                                                          «interface»
                                    Button                  OnOff

                                                        turnOn
                                                        turnOff
                                                        isOn
                                   Check Box            isOff









                                              Furnace::Heater       Lighting::Light



                             Рис. 7.5. Определение затребованного интерфейса в клиентском пакете

                        Когда применяются диаграммы пакетов

                             Я считаю, что диаграммы пакетов исключительно удобны в больших
                             по размерам системах для представления картины зависимостей меж
                             ду основными элементами системы. Такие диаграммы  хорошо соот
                             ветствуют общепринятым программным структурам. Рисование диа
                             грамм пакетов и зависимостей помогает держать под контролем зави
                             симости приложения. Диаграммы пакетов представляют группирую
                             щий механизм времени компиляции. Для представления компоновки
                             объектов во время выполнения  применяются диаграммы  составных
                             структур (composite structure) (стр. 155).

                        Где найти дополнительную информацию

                             Лучшее описание пакетов и их использования, которое мне известно, –
                             это книга Мартина [30]. Роберт Мартин почти патологически одержим
                             зависимостями и описывает способы обращения с зависимостями, ко
                             торые позволяют их минимизировать.






















                                                                                         8









                                                  Диаграммы развертывания





                             Диаграммы развертывания представляют физическое расположение
                             системы, показывая, на каком физическом оборудовании запускается
                             та или  иная составляющая программного обеспечения.  Диаграммы
                             развертывания очень просты, поэтому будем кратки.
                             На рис. 8.1 показан пример простой диаграммы развертывания. Глав
                             ными элементами диаграммы являются узлы, связанные информаци
                             онными путями. Узел (node) – это то, что может содержать программ
                             ное обеспечение. Узлы бывают двух типов. Устройство (device) – это
                             физическое оборудование: компьютер или устройство, связанное с сис
                             темой. Среда выполнения (execution environment) – это программное
                             обеспечение, которое само может включать другое программное обес
                             печение, например операционную систему или процессконтейнер.

                             Узлы могут содержать артефакты (artifacts), которые являются физи
                             ческим олицетворением программного обеспечения; обычно это файлы.
                             Такими файлами могут быть исполняемые файлы (такие как файлы
                             .exe, двоичные файлы, файлы DLL, файлы JAR, сборки или сценарии)
                             или файлы данных, конфигурационные файлы, HTMLдокументы
                             и т. д. Перечень артефактов внутри узла указывает на то, что на дан
                             ном узле артефакт разворачивается в запускаемую систему.

                             Артефакты можно изображать  в виде прямоугольников классов или
                             перечислять их имена внутри узла. Если вы показываете эти элементы
                             в виде прямоугольников классов, то можете добавить значок докумен
                             та или ключевое слово «artifact». Можно сопровождать узлы или арте
                             факты значениями в  виде меток, чтобы указать различную интерес
                             ную информацию об узле, например поставщика, операционную сис
                             тему, местоположение – в общем, все, что придет вам в голову.
                             Часто у  вас будет множество физических узлов для решения одной
                             и той же логической задачи. Можно отобразить этот факт, нарисовав
                             множество прямоугольников узлов или поставив число в виде значе
                             нияметки. На рис. 8.1 я обозначил три физических вебсервера с по















                        122                                         Глава 8. Диаграммы развертывания



                                 BrowserClient          Rich Client
                                                      {OS = Windows}
                              browser
                                                   herculesClient.exe   значение#метка

                                        информационный путь
                                                                             Application Server


                                                                              JoveGL.exe
                                  http/Internet     http/LAN               {vendor = romanSoft}
                                                                        {component = General Ledger}
                                                         развернутый
                                                          артефакт
                                           Web server                          EJB Container
                                          {OS = Solaris}
                                        {web server = apache}              herculesBase.ear
                                        {number deployed = 3}  Java RMI/   herculesAR.ear
                                                             LAN           herculesAP.ear
                                       herculesWeb.war
                                                                              JDBC


                                                         узел#среда
                                   узел#устройство
                                                         выполнения
                                                                               Oracle DBMS


                             Рис. 8.1. Пример диаграммы развертывания

                             мощью метки number deployed (количество развернутых), но это не стан
                             дартная метка.
                             Артефакты часто являются реализацией компонентов. Это можно по
                             казать, задав значенияметки внутри прямоугольников артефактов.
                             Информационные пути между узлами представляют обмен информа
                             цией в системе. Можно сопровождать эти пути  информацией об ис
                             пользуемых информационных протоколах.

                        Когда применяются диаграммы развертывания

                             Пусть краткость этой главы не заставляет вас думать, что диаграммы
                             развертывания можно не использовать. С их помощью  очень удобно
                             показывать размещение элементов, поэтому в случае любого нетриви
                             ального развертывания они могут оказаться очень полезными.






















                                                                                         9









                                                                            Прецеденты




                             Прецеденты – это технология определения функциональных требова
                             ний к системе. Работа прецедентов заключается в описании типичных
                             взаимодействий между пользователями системы  и самой системой
                             и предоставлении описания процесса  ее функционирования. Вместо
                             того чтобы описывать прецеденты в лоб, я предпочитаю подкрасться
                             к ним сзади и начать с описания сценариев. Сценарий (scenario) – это
                             последовательность шагов, описывающих взаимодействие пользовате
                             ля и системы. Поэтому при наличии онлайнового магазина, основан
                             ного на вебсайте, мы можем использовать сценарий «Покупка това
                             ра» (Buy a Product), в котором происходит следующее.
                                   Покупатель просматривает каталог и помещает выбранные то
                                   вары в корзину. При желании оплатить покупку он вводит инфор
                                   мацию о кредитной карте и производит платеж. Система проверя
                                   ет авторизацию кредитной карты и подтверждает оплату това
                                   ра тотчас же и по электронной почте.
                             Подобный сценарий описывает только одну ситуацию, которая может
                             иметь место. Однако если авторизация кредитной карты окажется не
                             удачной, то подобная ситуация может послужить предметом уже дру
                             гого сценария. В другом случае у вас может быть постоянный клиент,
                             для которого проверка информации о покупке и кредитной карте не
                             обязательна, и это будет третий сценарий.
                             Так или иначе, но все эти сценарии похожи. Суть в том, что во всех
                             трех сценариях у пользователя одна и та же цель: купить товар. Поль
                             зователь не всегда может это сделать, но цель остается. Именно цель
                             пользователя является ключом к прецедентам: прецедент представля
                             ет собой множество сценариев, объединенных некоторой общей целью
                             пользователя.
                             В терминах прецедента пользователи называются  актерами.  Актер
                             (actor) представляет собой некую роль, которую пользователь играет
                             по отношению к системе. Актерами могут быть пользователь, торго
                             вый представитель пользователя, менеджер по продажам и товаровед.















                        124                                                     Глава 9. Прецеденты


                             Актеры  действуют в рамках прецедентов.  Один актер может выпол
                             нять несколько прецедентов; и наоборот, в соответствии с одним пре
                             цедентом могут действовать несколько актеров. Обычно клиентов мно
                             го, поэтому роль клиента могут играть многие люди. К тому же один
                             человек может играть несколько ролей, например менеджер по прода
                             жам, выполняющий роль торгового представителя клиента. Актер не
                             обязательно должен быть человеком. Если система предоставляет не
                             который сервис другой компьютерной системе, то другая система яв
                             ляется актером.
                             На самом деле актер – не совсем верный термин; возможно, термин
                             роль (role) подошел бы лучше. Очевидно, имел место неправильный пе
                             ревод со  шведского языка, и в результате сообщество пользователей
                             прецедентов теперь употребляет термин актер.
                             Прецеденты считаются важной частью языка UML. Однако удивитель
                             но то, что определение прецедентов в UML довольно скудное. В UML
                             ничего не  говорится о том, как определять содержимое  прецедента.
                             Все, что описано в UML, – это диаграмма прецедентов, которая пока
                             зывает, как прецеденты связаны друг с другом. Но почти вся ценность
                             прецедентов как раз в их содержании, а диаграмма имеет ограничен
                             ное значение.

                        Содержимое прецедентов

                             Не существует стандартного способа описания содержимого прецеден
                             та; в разных случаях применяются различные форматы. На рис. 9.1 по
                             казан  общий стиль использования.  Вы начинаете  с  выбора одного из
                             сценариев в качестве главного успешного сценария (main success sce
                             nario). Сначала  вы описываете тело  прецедента, в  котором главный
                             успешный сценарий  представлен последовательностью  нумерованных
                             шагов. Затем берете другой сценарий и вставляете его в виде расшире
                             ния (extension), описывая его в терминах изменений главного успешно
                             го сценария. Расширения могут быть успешными – пользователь достиг
                             своей цели, как в варианте 3a, или неудачными, как в варианте 6a.
                             В каждом прецеденте есть ведущий актер, который посылает системе
                             запрос на обслуживание. Ведущий актер – это актер, желание которо
                             го пытается удовлетворить прецедент и который обычно, но не всегда,
                             является инициатором прецедента. Одновременно могут быть и другие
                             актеры, с которыми система также взаимодействует во время выпол
                             нения прецедента. Они называются второстепенными актерами.
                             Каждый шаг в прецеденте – это элемент взаимодействия актера с систе
                             мой. Каждый шаг должен быть простым утверждением и должен четко
                             указывать, кто выполняет этот шаг. Шаг должен показывать намере
                             ние актера, а не механику его действий. Следовательно, в прецеденте
                             интерфейс актера не описывается. Действительно, составление преце
                             дента обычно предшествует разработке интерфейса пользователя.















                        Содержимое прецедентов                                                125



                                Покупка товара
                                Целевой уровень: уровень моря
                                Главный успешный сценарий:
                                1. Покупатель просматривает каталог и выбирает товары для покупки.
                                2. Покупатель оценивает стоимость всех товаров.
                                3. Покупатель вводит информацию, необходимую для доставки товара
                                   (адрес, доставка на следующий день или в течение трех дней).
                                4. Система предоставляет полную информацию о цене товара и его до
                                   ставке.
                                5. Покупатель вводит информацию о кредитной карточке.
                                6. Система осуществляет авторизацию счета покупателя.
                                7. Система подтверждает оплату товаров немедленно.
                                8. Система посылает подтверждение оплаты товаров по адресу элект
                                   ронной почты покупателя.
                                Расширения:
                                3а. Клиент является постоянным покупателем.
                                 .1: Система предоставляет информацию о текущей покупке и ее цене,
                                    а также информацию о счете.
                                 .2: Покупатель может согласиться или изменить значения по умолча
                                    нию, затем возвращаемся к шагу 6 главного успешного сценария.
                                6a. Система не подтверждает авторизацию счета.
                                 .1: Пользователь может повторить ввод информации о кредитной карте
                                    или закончить сеанс.
                             Рис. 9.1. Пример текста прецедента

                             Расширение внутри прецедента указывает условие, которое приводит
                             к взаимодействиям, отличным от описанных в главном успешном сце
                             нарии (main success scenario, MSS), и устанавливает, в чем состоят эти
                             отличия. Расширение начинается с имени шага, на котором определя
                             ется это условие, и предоставляет краткое описание  этого условия.
                             Следуйте этому условию, нумеруя  шаги таким же образом, что и в
                             главном успешном сценарии. Заканчивайте эти шаги описанием точ
                             ки возврата в главный успешный сценарий, если это необходимо.
                             Структура прецедента – это отличный инструмент для поиска альтер
                             натив главного  успешного сценария. На  каждом шаге спрашивайте:
                             «Что может еще произойти?» и в частности «Что может пойти не так?»
                             Обычно лучше сначала изучить все возможные условия расширения,
                             чтобы потом не увязнуть в трясине работы над последствиями. Таким
                             образом, вы, возможно, обдумаете больше условий, что приведет к мень
                             шему количеству ошибок, которые потом пришлось бы отлавливать.
                             Сложный шаг в прецеденте можно представить другим прецедентом.
                             В терминах языка UML мы говорим, что первый прецедент включает
                             (includes) второй. Не существует стандартного способа показать в тексте















                        126                                                     Глава 9. Прецеденты


                             включение прецедента, но я думаю, что подчеркивание, которое пред
                             полагает гиперссылку, работает прекрасно, а во многих инструментах
                             действительно будет гиперссылкой. Так, на рис. 9.1 первый шаг вклю
                             чает шаблон «просматривает каталог и выбирает товары для покупки».
                             Включенные прецеденты могут быть полезными в случае сложных
                             шагов, которые иначе загромождали бы главный сценарий, или когда
                             одни и те же шаги присутствуют в нескольких сценариях. Однако не
                             пытайтесь разбивать прецеденты на подпрецеденты и использовать их
                             для функциональной декомпозиции. Такая декомпозиция – хороший
                             способ потерять много времени.
                             Наряду с шагами сценария можно вставить в прецедент дополнитель
                             ную общую информацию.
                             •  Предусловие  (precondition) описывает  действия, обязательно  вы
                                полняемые системой перед тем,  как  она разрешит начать  работу
                                прецедента. Это полезная информация, позволяющая разработчи
                                кам не проверять некоторые условия в их программе.
                             •  Гарантия (guarantee) описывает обязательные действия системы по
                                окончании работы шаблона ответа. Успешные гарантии выполня
                                ются после успешного сценария; минимальные гарантии выполня
                                ются после любого сценария.
                             •  Триггер (trigger) определяет событие, инициирующее выполнение
                                прецедента.
                             При рассмотрении дополнительных элементов относитесь к этому скеп
                             тически.  Лучше сделать слишком  мало, чем слишком много.  Кроме
                             того, приложите максимум усилий, чтобы сделать прецедент кратким
                             и легким для чтения. Я убедился, что излишне подробный прецедент,
                             который трудно читать, скорее приведет к провалу, чем к достижению
                             цели. Не обязательно записывать все детали; устное общение часто бы
                             вает очень эффективным, особенно во время итеративного цикла, когда
                             необходимые условия быстро выполняются запущенной программой.

                             Степень  детализации, необходимая в прецеденте,  зависит от уровня
                             риска этого прецедента. Часто детали нужны в начале только немно
                             гих ключевых прецедентов, другие можно конкретизировать непо
                             средственно перед их реализацией.

                        Диаграммы прецедентов


                             Я уже говорил, что язык UML умалчивает о содержимом прецедента,
                             но предоставляет формат диаграммы, позволяющий  его отображать
                             (рис. 9.2). Хотя диаграмма иногда оказывается полезной, без нее мож
                             но обойтись. При разработке прецедента не стоит прилагать много уси
                             лий для создания диаграммы. Вместо этого лучше сконцентрировать
                             ся на текстовом содержании прецедентов.















                        Уровни прецедентов                                                    127



                                                     Set           Update
                                                    Limits       Accounts

                                                   Analyze           включает   Accounting
                                                    Risk   «include»              System
                                  Trading
                                  Manager
                                                    Price            Value
                                                    Deal   «include»  Deal
                                                   Capture
                                                    Deal

                                     Trader
                             актер

                                     прецедент
                                                                             Salesperson
                                                     граница
                                                     системы
                             Рис. 9.2. Диаграмма прецедентов

                             Лучше всего обдумывать диаграмму прецедентов с помощью графиче
                             ской таблицы, показывающей их содержимое. Она  напоминает диа
                             грамму контекста, используемую в структурных методах, поскольку
                             она показывает границы системы и ее взаимодействие с внешним ми
                             ром. Диаграмма прецедентов показывает актеров, прецеденты и отно
                             шения между ними:
                             •  Какие актеры выполняют тот или иной прецедент
                             •  Какие прецеденты включают другие прецеденты
                             В языке UML помимо отношения «include» (включает) есть и другие
                             типы отношений между прецедентами, например отношение «extend»
                             (расширяет). Я настоятельно рекомендую его избегать. Слишком час
                             то на моих глазах разработчики целыми командами надолго погружа
                             лись в рассмотрение различных отношений между прецедентами, по
                             напрасну растрачивая силы. Лучше уделяйте больше внимания тек
                             стовому описанию прецедента; именно в этом заключается истинная
                             ценность этой технологии.

                        Уровни прецедентов

                             Общая проблема прецедентов состоит в том, что, увлекшись взаимодей
                             ствием пользователя с системой, можно не обратить внимание на тот
                             факт, что лучшим способом решения проблемы может быть изменение
                             самого бизнеспроцесса. Часто можно слышать упоминание о прецеден
                             тах системы и прецедентах бизнеспроцессов. Конечно, эта терминоло
                             гия не является точной, но обычно считается, что прецедент системы
                             (system use case) описывает особенности взаимодействия с программ















                        128                                                     Глава 9. Прецеденты


                             ным обеспечением, тогда как прецедент бизнеспроцесса (business use
                             case) представляет собой реакцию бизнеспроцесса на действие клиен
                             та или некоторое событие.
                             В книге Кокборна [10] предлагается схема уровней прецедентов. Базо
                             вый прецедент находится на «уровне моря». Прецеденты уровня моря
                             (sea level) обычно представляют  отдельное взаимодействие ведущего
                             актера и системы. Такие прецеденты предоставляют ведущему актеру
                             какойлибо полезный результат и обычно занимают от пары минут до
                             получаса. Прецеденты, которые существуют  в системе, только если
                             они включены в прецеденты уровня моря, называются прецедентами
                             уровня рыб (fish level). Прецеденты высшего уровня, уровня воздуш
                             ного змея  (kitelevel), показывают, как  прецеденты уровня моря на
                             страиваются  на более широкое взаимодействие с бизнеспроцессами.
                             Обычно прецеденты уровня воздушного змея являются прецедентами
                             бизнеспроцессов, а на уровне моря и на уровне рыб находятся преце
                             денты системы. Большинство ваших прецедентов  должно принадле
                             жать уровню моря. Я предпочитаю указывать уровень в начале преце
                             дента, как показано на рис. 9.1.

                        Прецеденты и возможности (или пожелания)

                             Во  многих подходах возможности системы применяются для описа
                             ния требований к системе; в экстремальном программировании (Ext
                             reme Programming) возможности системы называются пожеланиями
                             пользователя. Общим является вопрос о том, как установить соответ
                             ствие между возможностями и прецедентами.
                             Использование возможностей – это хороший способ разделения систе
                             мы на блоки при планировании итеративного процесса, в результате
                             чего каждая  итерация предоставляет определенное количество воз
                             можностей. Отсюда следует, что хотя оба приема описывают требова
                             ния, их цели различны.
                             Описать возможности можно сразу, но многие специалисты считают
                             более удобным в первую очередь разработать прецеденты, а уже затем
                             сгенерировать список возможностей. Возможность может быть пред
                             ставлена целым прецедентом, сценарием в прецеденте, шагом в преце
                             денте или какимлибо вариантом поведения,  например добавление
                             еще одного метода вычисления амортизации при оценке вашего иму
                             щества, который не указан в описании прецедента. Обычно возможно
                             сти получаются более четко определенными, чем прецеденты.

                        Когда применяются прецеденты

                             Прецеденты представляют собой ценный инструмент для понимания
                             функциональных требований к системе. Первый вариант прецедентов
                             должен составляться на ранней  стадии выполнения  проекта. Более















                        Где найти дополнительную информацию                                   129


                             подробные версии прецедентов должны появляться  непосредственно
                             перед реализацией данного прецедента.
                             Важно  помнить, что прецеденты представляют  взгляд на систему  со
                             стороны. А раз так, то не ждите какоголибо соответствия между пре
                             цедентами и классами внутри системы.
                             Чем больше прецедентов я вижу, тем менее ценной мне кажется диа
                             грамма прецедентов. Несмотря на то что в языке UML ничего не гово
                             рится о тексте прецедентов, именно текстовое содержание прецеден
                             тов является основной ценностью этой технологии.
                             Большая опасность прецедентов заключается в том, что разработчики
                             делают их очень сложными и застревают на них. Обычно чем меньше
                             вы делаете, тем меньший вред можете нанести. Если у вас немного ин
                             формации, то получится короткий, легко читаемый документ, который
                             явится отправной точкой для вопросов. Если информации  слишком
                             много, то вряд ли ктото вообще будет ее изучать и пытаться понять.

                        Где найти дополнительную информацию

                             Впервые  прецеденты были изложены в  доступной форме Айваром
                             Джекобсоном в [24].
                             Хотя прецеденты существовали и до этого, в упомянутой публикации
                             была предпринята попытка некоторой стандартизации их использова
                             ния. В языке UML ничего не говорится о такой важной вещи, как со
                             держимое прецедентов, в нем стандартизован только менее важный
                             элемент – диаграмма прецедентов.  Поэтому  можно  услышать целый
                             ряд различных мнений о прецедентах.
                             Однако за последние несколько лет книга Кокборна [10] стала стандар
                             том по этому предмету. Я следовал терминологии и советам этой книги
                             по той веской причине, что когда в прошлом мы расходились во мне
                             ниях, в конце концов я соглашался с Алистером Кокборном. Он под
                             держивает вебсайт по адресу http://usecases.org. В книге [11] предла
                             гается убедительный процесс получения пользовательских интерфей
                             сов из прецедентов; посетите также сайт по адресу  http://foruse.com.






















                             10









                             Диаграммы состояний





                             Диаграммы состояний (state machine diagrams) – это известная техно
                             логия описания поведения системы. В том или ином виде диаграммы
                             состояний существуют с 1960 года, и на заре объектноориентирован
                             ного программирования они применялись для представления поведе
                             ния системы. В объектноориентированных подходах вы рисуете диа
                             грамму состояний единственного класса, чтобы показать поведение
                             одного объекта в течение его жизни.
                             Всякий раз, когда пишут о конечных автоматах, в качестве примеров
                             неизбежно приводят системы круизконтроля или торговые автоматы.
                             Поскольку они мне слегка наскучили, я решил использовать контрол
                             лер секретной панели управления в Готическом замке. В этом замке я
                             хочу так спрятать свои сокровища, чтобы их было трудно найти. Для
                             того чтобы получить доступ к замку сейфа, я должен вытащить из кан
                             делябра стратегическую свечу, но замок появится, только если дверь
                             закрыта. После появления замка я могу вставить в него ключ и от
                             крыть  сейф. Для дополнительной безопасности я сделал  так,  чтобы
                             сейф можно было открыть только после извлечения свечи. Если вор не
                             обратит внимания на эту предосторожность, то я спущу с цепи отвра
                             тительного монстра, который проглотит вора.
                             На рис. 10.1 показана диаграмма состояний класса контроллера, кото
                             рый управляет моей необычной системой безопасности. Диаграмма со
                             стояния начинается  с состояния создаваемого объекта контроллера:
                             состояния Wait (Ожидание). На диаграмме это обозначено с помощью
                             начального псевдосостояния (initial pseudostate), которое не является
                             состоянием, но имеет стрелку, указывающую на начальное состояние.
                             На диаграмме показано, что контроллер может находиться в одном из
                             трех состояний: Wait (Ожидание), Lock (Замок) и Open (Открыт). На диа
                             грамме также представлены  правила, согласно которым контроллер
                             переходит из одного состояния  в  другое. Эти правила представлены
                             в виде переходов – линий, связывающих состояния.















                                                                                              131


                                                                       сейф закрыт
                                                                                      Open


                                                     переход
                                начальное                       ключ повернут [свеча не вынута] /
                             псевдосостояние                                  открыть сейф


                                                   свеча вынута [дверь закрыта] / показать замок
                                          Wait                                        Lock

                                                                  ключ повернут [свеча вынута] /
                                                                       спустить кролика-убийцу
                                   состояние
                                                                конечное состояние
                             Рис. 10.1. Простая диаграмма состояний
                             Переход (transition) означает перемещение из одного состояния в дру
                             гое. Каждый переход имеет свою метку, которая состоит из трех частей:
                             триггеридентификатор [защита]/активность (triggersignature [guard]/acti
                             vity). Все они не обязательны. Как правило, триггеридентификатор – это
                             единственное событие, которое  может вызвать изменение  состояния.
                             Защита, если она указана, представляет собой логическое условие, кото
                             рое должно быть выполнено, чтобы переход имел место.  Активность –
                             это некоторое поведение системы во время перехода. Это может быть
                             любое поведенческое выражение. Полная форма триггераидентификато
                             ра может включать несколько событий и параметров. Переход из со
                             стояния Wait (рис. 10.1) в другое состояние можно прочесть как «В со
                             стоянии Wait, если свеча удалена, вы видите замок и переходите в со
                             стояние Lock».
                             Все три части описания перехода не обязательны. Пропуск активности
                             означает, что в процессе перехода ничего не происходит. Пропуск за
                             щиты означает, что переход всегда осуществляется, если происходит
                             инициирующее событие. Триггеридентификатор отсутствует редко,
                             но и  так бывает. Это  означает,  что переход происходит немедленно,
                             что можно наблюдать  главным образом в состояниях активности,
                             о чем я расскажу в нужный момент.
                             Когда в определенном состоянии происходит событие, то из этого со
                             стояния можно совершить только один переход, например в состоянии
                             Lock (рис. 10.1) защиты должны быть взаимно исключающими. Если
                             событие происходит, а разрешенных переходов нет – например закры
                             тие сейфа в состоянии Wait или удаление свечи при открытой двери, –
                             событие игнорируется.
                             Конечное состояние (final  state)  означает,  что конечный автомат  за
                             кончил работу, что вызывает удаление объекта контроллера. Так что















                        132                                            Глава 10. Диаграммы состояний


                             для тех, кто имел неосторожность попасть в мою ловушку, сообщаю,
                             что поскольку объект контроллера  прекращает свое существование,
                             я вынужден посадить кролика обратно в клетку, вымыть пол и пере
                             грузить систему.
                             Помните, что конечные автоматы могут показывать только те объек
                             ты, которые непосредственно наблюдаются или действуют. Поэтому,
                             хотя вы могли ожидать, что я положу чтонибудь в сейф или чтони
                             будь возьму оттуда, когда дверь открыта, я не отметил это на диаграм
                             ме, поскольку контроллер об этом ничего сообщить не может.
                             Когда разработчики говорят об объектах, они часто ссылаются на со
                             стояние объектов, имея в виду комбинацию всех данных, содержа
                             щихся в полях объектов. Однако состояние на диаграмме конечного
                             автомата является более абстрактным понятием состояния; суть в том,
                             что различные  состояния предполагают различные  способы реакции
                             на события.

                        Внутренние активности

                             Состояния могут реагировать на события без совершения перехода, ис
                             пользуя  внутренние активности  (internal activities), и  в  этом случае
                             событие, защита и активность размещаются внутри прямоугольника
                             состояния.
                             На рис. 10.2 представлено состояние с  внутренними активностями
                             символов и событиями системы помощи, которые вы можете наблю
                             дать в текстовых полях редактора UI. Внутренняя активность подобна
                             самопереходу (selftransition) – переходу, который возвращает в то же
                             самое состояние. Синтаксис внутренних активностей построен по той
                             же логической схеме события, защиты и процедуры.
                             На рис. 10.2 показаны также специальные активности: входная и вы
                             ходная активности. Входная активность выполняется всякий раз, ко
                             гда вы входите в состояние; выходная активность  – всякий раз, когда
                             вы покидаете состояние. Однако внутренние активности не иницииру
                             ют входную и выходную активности; в этом состоит различие между
                             внутренними активностями и самопереходами.

                                          Typing
                              entry/ выделить все
                              exit/ обновить поле
                              character/ обработка символа
                              help [verbose]/ открыть страницу помощи
                              help [quiet]/ обновить панель статуса


                             Рис. 10.2. Внутренние события, показанные в состоянии
                                      набора текста в текстовом поле















                        Состояния активности                                                  133


                        Состояния активности

                             В состояниях, которые я описывал до сих пор, объект молчит и ожида
                             ет следующего события, прежде чем чтонибудь сделать. Однако воз
                             можны состояния, в которых объект проявляет некоторую активность.
                             Состояние Searching (Поиск) на рис. 10.3 является таким состоянием
                             активности (activity state): ведущаяся активность обозначается симво
                             лом do/; отсюда термин doactivity (проявлять активность). После того
                             как поиск завершен, выполняются переходы без активности, напри
                             мер показ нового оборудования (Display New Hardware). Если в процессе
                             активности происходит событие  отмены  (cancel), то  doактивность
                             просто прерывается и мы возвращаемся  в состояние  Update Hardware
                             Window (Обновление окна оборудования).


                                  Update     search                          Searching
                                 Hardware
                                  Window                               do/ search for new hardware
                                                          активность
                                                                     cancel

                                                                            Display New
                                                                             Hardware
                                                                              Window
                             Рис. 10.3. Состояние с активностью
                             И doактивности, и обычные активности представляют проявление не
                             которого поведения. Решающее различие между ними заключается
                             в том,  что обычные активности происходят  «мгновенно»  и не  могут
                             быть прерваны обычными событиями, тогда как doактивности могут
                             выполняться в  течение некоторого ограниченного времени и могут
                             прерываться,  как показано  на рис. 10.3. Мгновенность для разных
                             систем трактуется поразному; для систем реального времени это мо
                             жет занимать несколько  машинных  инструкций, а  для настольного
                             программного обеспечения может составить несколько секунд.
                             В UML 1 обычные активности обозначались термином action (действие),
                             а термин activity (активность) применялся только для doактивностей.

                        Суперсостояния


                             Часто бывает, что несколько состояний имеют общие переходы и внут
                             ренние активности. В таких случаях можно их превратить в подсо
                             стояния (substates), а общее поведение перенести в суперсостояние (su
                             perstate), как показано на рис. 10.4. Без суперсостояния пришлось бы
                             рисовать переход cancel (отмена) для всех трех состояний внутри со
                             стояния Enter Connection Details (Dвод подробностей соединения).















                        134                                            Глава 10. Диаграммы состояний



                                                    Show Connections

                                                    new
                                                                                          save
                                                                cancel
                                                      Enter Connection Details
                                                     next                   next
                                       Enter Phone           Choose Shared           Enter Name
                                         Number                or Solo
                                                     back                   back

                             Рис. 10.4. Суперсостояние с вложенными подсостояниями

                        Параллельные состояния

                             Состояния могут быть разбиты на  несколько  параллельных состоя
                             ний,  запускаемых одновременно. На  рис. 10.5 показан  трогательно
                             простой будильник, который может включать либо CD, либо радио и
                             показывать либо текущее время, либо время сигнала.
                             Опции CD/радио и текущее время/время сигнала являются параллель
                             ными. Если бы вы захотели представить это с помощью диаграммы
                             непараллельных состояний, то получилась бы беспорядочная диаграм
                             ма при необходимости добавить состояния. Разделение двух областей
                             поведения на две диаграммы состояний делает ее значительно яснее.
                                                       On

                                  time
                                           Display Current    Display Alarm
                                               Time              Time       alarm


                                        граница параллельных состояний


                                            Playing Radio      Playing CD
                                 H
                                            Radio               CD

                               псевдосостояние    on        off
                               предыстории

                                                       Off
                             Рис. 10.5. Параллельные состояния















                        Реализация диаграмм состояний                                         135


                             Рис. 10.5 включает  также  состояние предыстории  (history pseudo
                             state). Это означает, что когда включены часы, опция радио/CD пере
                             ходит в состояние, в котором находились часы, когда они  были вы
                             ключены. Стрелка, выходящая из предыстории, показывает, какое со
                             стояние существовало изначально, когда отсутствовала предыстория.


                        Реализация диаграмм состояний
                             Диаграмму состояний можно реализовать тремя основными способа
                             ми: с помощью вложенного оператора switch, паттерна State и табли
                             цы состояний. Самый прямой подход в работе с диаграммами состоя
                             ний – это вложенный оператор switch, такой как на рис. 10.6.

                                public void HandleEvent (PanelEvent anEvent) {
                                   switch (CurrentState) {
                                      case PanelState.Open :
                                         switch (anEvent) {
                                            case PanelEvent.SafeClosed :
                                               CurrentState = PanelState.Wait;
                                               break;
                                         }
                                         break;
                                      case PanelState.Wait :
                                         switch (anEvent) {
                                            case PanelEvent.CandleRemoved :
                                               if (isDoorOpen) {
                                                  RevealLock();
                                                  CurrentState = PanelState.Lock;
                                               }
                                              break;
                                         }
                                         break;
                                      case PanelState.Lock :
                                         switch (anEvent) {
                                            case PanelEvent.KeyTurned :
                                               if (isCandleIn) {
                                                  OpenSafe();
                                                  CurrentState = PanelState.Open;
                                               } else {
                                                  ReleaseKillerRabbit();
                                                  CurrentState = PanelState.Final;
                                               }
                                               break;
                                         }
                                         break;
                                     }
                                  }
                                }

                             Рис. 10.6. Вложенный оператор switch на языке C# для обработки
                                      перехода состояний, представленного на рис. 10.1















                        136                                            Глава 10. Диаграммы состояний


                             Хотя этот способ и прямой, но очень длинный даже для этого простого
                             случая. Кроме того, при данном подходе очень легко потерять контроль,
                             поэтому я не люблю применять его даже в элементарных ситуациях.
                             Паттерн «Состояние» (State pattern) [21] представляет иерархию клас
                             сов состояний для обработки поведения состояний. Каждое состояние
                             на диаграмме имеет свой подкласс состояния. Контроллер имеет мето
                             ды для каждого события, которые просто перенаправляют к классу со
                             стояния. Диаграмма  состояний, показанная на рис. 10.1,  могла  бы
                             быть реализована с помощью классов, представленных на рис. 10.7.


                                   Secret Panel Controller
                                                                      Secret Panel State
                                                             state 1
                               changeStateTo (SecretPanelState)     handleCandleRemoved
                               handleCandleRemoved                  handleKeyTurned
                               handleKeyTurned                      handleSafeClosed
                               handleSafeClosed
                                                                                       do nothing


                               state.handleCandleRemoved

                                                        Wait State      Lock State    Open State
                               if (door open) {     handleCandleRemoved  handleKeyTurned  handleSafeClosed
                                revealLock()
                                changeStateTo (LockState)
                               }

                             Рис. 10.7. Паттерн «Состояние», реализующий диаграмму на рис. 10.1

                             Вершиной иерархии является абстрактный класс, который содержит
                             описание всех методов, обрабатывающих события, но без реализации.
                             Для каждого конкретного состояния достаточно переписать методобра
                             ботчик определенного события, инициирующего переход из состояния.
                             Таблица состояний представляет диаграмму состояний в виде данных.
                             Так, диаграмма на рис. 10.1 может быть представлена в виде табл. 10.1.
                             Затем мы строим интерпретатор, который использует таблицу состоя
                             ний  во время выполнения  программы, или генератор кода,  который
                             порождает классы на основе этой таблицы.
                             Очевидно, большая часть работы над таблицей состояний проводится
                             однажды, но затем ее можно использовать всякий раз, когда надо ре
                             шить проблему, связанную с состояниями. Таблица состояний време
                             ни выполнения  может быть  модифицирована без  перекомпиляции,
                             что в некотором смысле удобно. Шаблон состояний собрать легче, и хо
                             тя для каждого состояния требуется отдельный класс, но размер кода,
                             который при этом надо написать, совсем невелик.















                        Когда применяются диаграммы состояний                                 137


                             Таблица 10.1. Таблица состояний для диаграммы на рис. 10.1
                              Исходное   Целевое   Событие        Защита          Процедура
                              состояние  состояние
                              Wait       Lock      Candle removed  Door open      Reveal lock
                                                   (свеча удалена)  (дверца открыта) (показать замок)

                              Lock       Open      Key turned     Candle in       Open safe
                                                   (ключ повернут) (свеча на месте)  (открыть сейф)
                              Lock       Final     Key turned     Candle out      Release killer rab
                                                   (ключ повернут) (свеча удалена)  bit (освободить
                                                                                  убийцукролика)
                              Open       Wait      Safe closed
                                                   (сейф закрыт)


                             Приведенные реализации практически минимальные, но они  дают
                             представление о том, как применять диаграммы состояний. В каждом
                             случае реализация моделей состояний приводит к довольно стереотип
                             ной  программе, поэтому  обычно  для этого  лучше прибегнуть к тому
                             или иному способу генерации кода.


                        Когда применяются диаграммы состояний

                             Диаграммы состояний хороши для описания поведения одного объек
                             та в нескольких прецедентах. Но они не очень подходят для описания
                             поведения, характеризующегося  взаимодействием множества объек
                             тов. Поэтому имеет смысл совместно с диаграммами состояний приме
                             нять другие технологии. Например, диаграммы взаимодействия (гла
                             ва 4)  прекрасно описывают поведение нескольких объектов  в одном
                             прецеденте, а диаграммы деятельности (глава 11) хороши для показа
                             основной последовательности действий нескольких объектов в не
                             скольких прецедентах.
                             Не все считают диаграммы состояний естественными. Понаблюдайте,
                             как специалисты работают с ними. Вполне возможно, что члены ва
                             шей команды не думают, что диаграммы состояний подходят для их
                             стиля работы. Это не самая большая трудность; вы должны не забы
                             вать совместно использовать различные приемы работы.
                             Если вы применяете диаграммы состояний, то не старайтесь нарисо
                             вать их для каждого класса системы. Такой подход часто применяется
                             в целях формально строгой полноты, но почти всегда это напрасная
                             трата сил. Применяйте диаграммы состояний только для тех классов,
                             которые проявляют интересное поведение, когда построение диаграм
                             мы состояний помогает понять, как все происходит. Многие специали
                             сты считают, что редактор UI и управляющие объекты имеют функ
                             циональные средства, полезные при отображении с помощью диаграм
                             мы состояний.















                        138                                            Глава 10. Диаграммы состояний


                        Где найти дополнительную информацию

                             И руководство пользователя по UML  [6], и справочное руководство
                             [40] содержат более подробную информацию о диаграммах состояний.
                             Проектировщики систем реального времени предпочитают интенсив
                             но применять модели состояний, поэтому неудивительно, что в книге
                             Дугласа [15] много говорится о диаграммах состояний, включая ин
                             формацию об их реализации. В книге Мартина [30] есть хорошая глава
                             о различных способах реализации диаграмм состояний.






















                                                                                 11









                                                     Диаграммы деятельности




                             Диаграммы деятельности – это технология, позволяющая описывать
                             логику процедур, бизнеспроцессы и потоки работ. Во многих случаях
                             они напоминают блоксхемы, но принципиальная разница между диа
                             граммами деятельности и нотацией блоксхем заключается в том, что
                             первые поддерживают параллельное процессы.
                             Диаграммы деятельности подвергались самым большим изменениям
                             при смене версий языка UML, поэтому неудивительно, что они были
                             снова изменены и существенно расширены в UML 2. В UML 1 диаграм
                             мы  деятельности рассматривались как особый случай диаграмм со
                             стояний. Это вызвало немало трудностей у специалистов, моделирую
                             щих потоки работ, для которых хорошо подходят диаграммы деятель
                             ности. В UML 2 это ограничение было ликвидировано.
                             На рис. 11.1 показан  пример простой диаграммы деятельности.  Мы
                             стартуем с начального  узла  (initial node),  а  затем выполняем опера
                             цию Receive Order (Принять заказ). Затем идет ветвление (fork), кото
                             рое имеет один входной поток и несколько выходных параллельных
                             потоков.
                             Из рис. 11.1 видно, что операции Fill Order (Заполнить заявку), Send
                             Invoice (Послать счет) и следующие за ними выполняются параллель
                             но. По  существу, в  данном случае  это означает, что последователь
                             ность операций не имеет значения. Я могу заполнить заявку, послать
                             счет, доставить товар (Delivery), а затем получить оплату (Receive Pay
                             ment); или  я  могу послать счет, получить  оплату, заполнить заявку,
                             а затем доставить товар. Посмотрите на рисунок.
                             Я могу также выполнять операции поочередно. Я беру со склада пер
                             вую позицию заказа, печатаю счет, беру вторую позицию заказа, кладу
                             счет в конверт и т. д. Или я могу чтото делать одновременно: печатать
                             счет одной рукой, а другой рукой брать чтонибудь со склада. Согласно
                             диаграмме, любая из этих последовательностей действий допустима.
                             Диаграмма  деятельности  позволяет любому, кто выполняет данный
                             процесс, выбирать порядок действий. Другими  словами, диаграмма















                        140                                          Глава 11. Диаграммы деятельности






                                                             начальный узел
                                                    Receive
                                                     Order

                                         ветвление
                                                                       операция




                                      Fill Order
                                                              Send Invoice
                                              решение
                              [priority order]                          поток/ребро
                                            [else]


                              Overnight      Regular
                               Delivery      Delivery          Receive
                                                               Payment






                                  слияние
                                                                  объединение
                                                     Close
                                                     Order

                                      конец деятельности



                             Рис. 11.1. Простая диаграмма деятельности
                             только устанавливает правила обязательной последовательности дей
                             ствий, которым я должен следовать. Это важно для моделирования
                             бизнеспроцессов, поскольку эти процессы часто выполняются парал
                             лельно. Такие диаграммы также полезны при разработке параллель
                             ных алгоритмов, в которых независимые потоки могут выполнять ра
                             боту параллельно.
                             При наличии параллелизма необходима синхронизация. Мы не закры
                             ваем заказ, пока он не оплачен и не доставлен. Это показывается с по
                             мощью  объединения  (join) перед  операцией  Close Order (Закрыть за
                             каз). Исходящий из объединения поток выполняется только в том слу















                        Декомпозиция операции                                                 141


                             чае, когда все входящие потоки достигли объединения. Поэтому вы мо
                             жете закрыть заказ, только когда принята оплата и заказ доставлен.
                             В UML 1 действовали определенные правила для балансировки ветвле
                             ний и объединений, так  как  диаграммы деятельности  представляли
                             особый случай диаграмм состояний. В UML 2 в такой балансировке уже
                             нет необходимости.
                             Заметьте, что узлы на диаграмме деятельности называются операция
                             ми (actions), а  не активностями  (activities). Строго говоря, деятель
                             ность относится к последовательности действий, поэтому диаграмма
                             представляет деятельность, состоящую из операций.
                             Условное поведение схематически обозначается с помощью решений
                             (decisions) и слияний (merges). Решение, которое в UML 1 называлось
                             ветвью, имеет один входящий поток и несколько защищенных выход
                             ных потоков. Каждый выходной поток имеет защиту – условное выра
                             жение, помещенное в квадратные скобки. Каждый раз при достиже
                             нии решения выбирается только один из выходных потоков, поэтому
                             защиты должны быть взаимно исключающими. Применение [else] в
                             качестве защиты означает, что поток [else] используется в том случае,
                             когда другие защиты данного решения принимают ложное значение.
                             На рис. 11.1 решение располагается после операции заполнения заяв
                             ки. Если у вас срочный заказ, то он выполняется в течение суток (Over
                             night Delivery); в противном случае  производится обычная  доставка
                             (Regular Delivery).
                             Слияние (merge) имеет несколько входных потоков и один выходной.
                             Слияние обозначает завершение условного поведения, которое было
                             начато решением.
                             На моей диаграмме каждая операция имеет один входящий в нее по
                             ток и один выходящий. В UML 1 подразумевалось, что несколько вхо
                             дящих потоков имеют слияние. Другими словами, операция выполня
                             лась, если запускался любой поток. В UML 2 это было изменено, так
                             что вместо слияния предполагается объединение; таким образом, опе
                             рация выполняется, только если все потоки пройдены. Поэтому я ре
                             комендую применять операции с  единственным входным  потоком
                             и единственным выходным, а также явно показывать все объединения
                             и слияния; это избавит вас от путаницы.

                        Декомпозиция операции

                             Операции могут быть разбиты на вложенные деятельности (subactivi
                             ties). Я могу взять алгоритм доставки, показанный на рис. 11.1, и опре
                             делить его как самостоятельную деятельность (рис. 11.2), а затем вы
                             звать его как операцию (рис. 11.3).
                             Операции могут быть реализованы или как вложенные деятельности
                             или как методы классов. Вложенную деятельность можно обозначить















                        142                                          Глава 11. Диаграммы деятельности


                                      имя деятельности



                                        Deliver Order
                                                            Regular Delivery

                                                     [else]
                                   Order                                        Order
                                                     [Rush Order]
                                                              Overnight
                                                              Delivery
                              входной                                             выходной
                             параметр                                             параметр


                             Рис. 11.2. Дополнительная диаграмма деятельности






                                                   Receive
                                                    Order




                                                                      вызов метода
                                                           Send Invoice
                                             Fill Order
                                                         (Order::sendInvoice)
                             «грабли» означают
                                диаграмму
                                 вложенной
                                деятельности   Deliver       Receive
                                               Order        Payment






                                                     Close
                                                    Order





                             Рис. 11.3. Деятельность из рис. 11.1 модифицирована для вызова
                                      деятельности из рис. 11.2















                        Разделы                                                               143


                             с помощью символа «граблей». Вызов метода отображается с помощью
                             синтаксиса  имякласса::имяметода. Можно также вставить в символ
                             операции фрагмент кода, если поведение представлено не единствен
                             ным вызовом метода.

                        Разделы

                             Диаграммы деятельности рассказывают о том, что происходит, но ни
                             чего не говорят о том, кто какие действия выполняет. В программиро
                             вании это означает, что диаграмма не отражает, какой класс является
                             ответственным за ту  или иную  операцию. В  моделировании бизнес
                             процессов это означает, что не отражено распределение обязанностей
                             между подразделениями фирмы. Это  не всегда представляет  собой
                             трудность; часто имеет смысл сконцентрироваться на том, что проис
                             ходит, а не на том, кто какую роль играет в данном сценарии.
                             Можно разбить диаграмму деятельности на разделы (partitions), что
                             бы показать, кто что  делает, то  есть какие  операции выполняет  тот
                             или иной класс или подразделение предприятия. На рис. 11.4 приве
                             ден простой пример, показывающий, как операции по обработке зака
                             за могут быть распределены между различными подразделениями.

                                Fulfillment               Customer Service     Finance
                               (исполнение)            (обслуживание клиента) (финансовые операции)


                                                   Receive
                                                    Order






                              Fill Order                      Send
                                                              Invoice


                               Deliver                                        Receive
                                Order                                         Payment






                                                    Close
                                                    Order





                             Рис. 11.4. Разбиение диаграммы деятельности на разделы















                        144                                          Глава 11. Диаграммы деятельности


                             На рис. 11.4 представлено простое одномерное разбиение. Этот способ
                             по понятным причинам часто называют  плавательными дорожками
                             (swim lanes), и такая форма была единственной в UML1. В UML2 сет
                             ка может быть двумерной, поэтому «плавательная» метафора больше
                             не содержит воды. Кроме того, можно взять каждое измерение и раз
                             делить строчки на столбцы, создавая тем самым иерархическую
                             структуру.

                        Сигналы


                             В простом примере на рис. 11.1 диаграммы деятельности имеют четко
                             определенную стартовую точку, соответствующую вызову программы
                             или процедуры. Кроме того, операции могут отвечать на сигналы.
                             Временной сигнал (time signal) приходит по прошествии времени. Та
                             кие  сигналы могут означать конец  месяца в отчетном  периоде или
                             приходить каждую секунду в контроллере реального времени.
                             На рис. 11.5 показана деятельность, в которой ожидаются два сигна
                             ла. Сигнал показывает, что данная деятельность  принимает сообще
                             ние о событии от внешнего процесса. Это означает, что деятельность
                             постоянно прослушивает эти  сигналы, а  диаграмма определяет,  как
                             деятельность на них реагирует.

                                          временной сигнал



                                                 Pack Bags

                              Two hours                                     Leave for Airport
                              before flight


                                                    Taxi
                                                   Arrives
                                                                принятие сигнала
                             Рис. 11.5. Сигналы в диаграмме деятельности

                             В случае, показанном на рис. 11.5, до моего отлета остается два часа
                             (Two hours before flight), и мне пора собирать багаж. Если я упакую его
                             раньше времени, то все равно не смогу уехать, пока не прибудет такси.
                             Если такси приходит (Taxi Arrives) до того, как я успею собрать багаж
                             (Pack Bags), то оно должно ждать меня, пока я не закончу.
                             Мы можем как принимать сигналы, так и посылать их. Это полезно,
                             когда мы посылаем сообщение, а затем должны ожидать ответа, перед
                             тем как продолжить. На рис. 11.6 показан хороший пример этого про
                             цесса,  основанный на общей  идиоме таймаутов. Заметим,  что в этой















                        Маркеры                                                               145



                              Зарезервировать
                                 маршрут                        прием сигнала



                                                                Маршрут      Покупка билетов
                              Послать маршрут                 подтвержден



                                                                            Отменить маршрут
                                     посылка сигнала
                                                           ожидать 48 часов
                             Рис. 11.6. Отправка и прием сигналов

                             гонке  участвует два потока: первый,  достигший финального состоя
                             ния, выигрывает и прерывает выполнение другого потока.
                             Хотя блоки приема сигналов только ожидают внешнего события, мы
                             можем также показать входящий в него поток. Это означает, что мы
                             не начинаем прослушивание  до тех  пор, пока поток не  инициирует
                             прием.

                        Маркеры

                             Смельчаки, рискнувшие погрузиться в дьявольскую глубину специ
                             фикаций  UML, обнаружат, что в разделе, посвященном активности,
                             много говорится о маркерах (tokens), их создании и  использовании.
                             Начальный узел создает маркер, который затем  передается  следую
                             щей процедуре, которая выполняется  и  передает маркер  следующей
                             процедуре. В точку ветвления приходит один маркер, а ветвление по
                             рождает маркер  для каждого  исходящего потока. Наоборот, в точке
                             объединения при появлении отдельного маркера ничего  не происхо
                             дит до тех пор, пока не соберутся все маркеры, затем порождается мар
                             кер для исходящего потока.
                             Можно визуализировать маркеры с помощью монеток или счетчиков,
                             перемещающихся по диаграмме.  В  случае более сложных  диаграмм
                             деятельности маркеры часто облегчают визуализацию.

                        Потоки и ребра

                             В UML 2 параллельно употребляются  термины  поток  (flow) и  ребро
                             (edge) для обозначения связи между двумя операциями. Самый про
                             стой вид ребра – это обычная стрелка между двумя операциями. Если
                             хотите, можете присвоить ей имя, но в большинстве случаев простой
                             стрелки будет достаточно.















                        146                                          Глава 11. Диаграммы деятельности


                             При возникновении трудностей с разводкой линий можно воспользо
                             ваться разъемами (connectors), которые позволят вам не рисовать ли
                             нии на всем их протяжении. Разъемы изображаются парами: один для
                             входного и один для выходного потоков, при этом они должны иметь
                             одну и ту же метку. Я предпочитаю без необходимости не применять
                             разъемы, поскольку они нарушают визуализацию потока управления.
                             Простейшие ребра передают  маркер, имеющий значение только для
                             управления  потоком. Однако по  ребрам можно  передавать объекты;
                             тогда объекты будут играть роль маркеров как передатчиков данных.
                             Передачу объекта вдоль ребра можно показать, помещая на ребро пря
                             моугольник класса. Можно также изображать контакты (pins) на опе
                             рациях, хотя использование контактов имеет некоторые хитрости, о ко
                             торых я кратко расскажу.
                             Все способы, показанные на рис. 11.7, эквивалентны. Вы вправе вы
                             брать тот способ, который лучше всего отражает то, что вы хотите со
                             общить. В большинстве случаев вполне достаточно простой стрелки.

                               Получить                         Произвести
                                 счет                             оплату
                                                 разъем
                               Получить      A        A         Произвести
                                 счет                             оплату
                                                узел объекта

                               Получить          Заказ          Произвести
                                 счет                             оплату
                                           контакт       Заказ
                               Получить                         Произвести
                                 счет                             оплату
                                         Заказ
                             Рис. 11.7. Четыре способа представления ребер


                        Контакты и преобразования

                             Процедуры, как и методы, могут иметь параметры. Показывать на диа
                             грамме деятельности информацию о параметрах не обязательно, но при
                             желании можно отобразить параметры с помощью  контактов  (pins).
                             Если процедура разбивается на части, то контакты должны соответст
                             вовать прямоугольникам параметров на разделенной диаграмме.
                             Если требуется нарисовать точную диаграмму деятельности, то необ
                             ходимо обеспечить соответствие выходных параметров одной процеду
                             ры входным параметрам другой. Если они не совпадают, то можно ука
                             зать  преобразование  (transformation) (рис. 11.8) для перехода от од
                             ной процедуры к другой. Преобразование должно представлять собой















                        Области расширения                                                    147



                                                             Отмена приема

                                                      Время приема
                                                                         контакт для параметра

                               «transformation»                               «transformation»
                               appointment.cancellationNotice
                                                                              appointment.patient
                                                     Сообщение        Пациент

                                                          Уведомить пациента     выражение
                                                                                преобразования
                             Рис. 11.8. Преобразование потока

                             выражение, свободное от сторонних эффектов: главное, чтобы запрос с
                             выходного контакта предоставлял тип объекта,  соответствующий
                             входному контакту.
                             Показывать контакты на диаграмме деятельности не обязательно.
                             Контакты удобны,  когда требуется увидеть  данные, принимаемые
                             и передаваемые  различными процедурами. При  моделировании биз
                             неспроцессов посредством контактов можно отображать ресурсы, ко
                             торые потребляются и производятся различными процедурами.
                             С помощью контактов можно без опаски показать несколько потоков,
                             входящих в одну и ту же  операцию. Нотация контактов усиливает
                             предположение о наличии последующего объединения, а в UML 1 во
                             обще нет контактов, поэтому не возникает путаницы с более ранними
                             допущениями.

                        Области расширения

                             При работе с диаграммами деятельности часто сталкиваешься с ситуа
                             циями, когда выход одной операции инициирует многочисленные вы
                             зовы другой операции. Есть несколько способов показать это, но луч
                             ше всего подходит область расширения. Область расширения (expan
                             sion region) отмечает область диаграммы деятельности, где операции
                             выполняются один раз для каждого элемента коллекции.
                             На рис. 11.9 процедура Choose Topics (Выбрать темы) генерирует спи
                             сок тем. Затем каждый элемент этого списка становится маркером для
                             входа процедуры Write Article (Написать статью). Подобным образом
                             каждая операция  Review Article (Рецензировать  статью) генерирует
                             единственную статью, которая добавляется к выходному списку об
                             ласти расширения. Когда все маркеры в области расширения достига
                             ют выходной коллекции, область расширения генерирует единствен
                             ный маркер для списка, который передается процедуре Publish News
                             letter (Опубликовать информационный бюллетень).















                        148                                          Глава 11. Диаграммы деятельности



                                     Choose Topics
                                                            область расширения
                             ключевое слово
                                            список тем

                                «concurrent»

                                                                                Publish
                                      Write Article    Review Article          Newsletter

                                                                       выходной список
                                                                         контактов
                             Рис. 11.9. Область расширения

                             В данном случае в выходной и входной коллекциях одинаковое коли
                             чество элементов. Однако  в выходной коллекции  может оказаться
                             меньше элементов, чем во входной; в таком случае область расшире
                             ния действует как фильтр.
                             На рис. 11.9 все статьи пишутся и рецензируются параллельно, что от
                             мечено ключевым словом «concurrent». Область расширения также мо
                             жет быть итеративной. Итеративные области должны полностью обра
                             батывать каждый входной элемент за один раз.
                             Если есть  только одна операция,  которую надо вызывать несколько
                             раз, то применяется нотация, показанная на рис. 11.10. Такой способ
                             записи предполагает параллельное расширение, поскольку оно наибо
                             лее общее.  Эта нотация  соответствует концепции динамического па
                             раллелизма, принятой в UML 1.

                                  Choose              Prepare             Publish
                                  Topics              Article            Newsletter


                             Рис. 11.10. Нотация для единственной процедуры в области расширения


                        Окончание потока

                             При получении нескольких маркеров, как в случае с областью расши
                             рения, поток часто останавливается, даже если вся активность в целом
                             не завершена. Окончание потока (flow final) означает завершение кон
                             кретного потока без завершения всей активности.
                             На рис. 11.11 показана модифицированная версия  рис. 11.9,  в кото
                             рой статьи могут быть отвергнуты. Если статья отклонена, то маркер
                             ликвидируется окончанием потока. В отличие от окончания активно















                        Описания объединений                                                  149


                             сти, в данном случае остальная активность может продолжаться. Этот
                             подход позволяет областям расширения действовать в качестве фильт
                             ров, в результате чего выходная коллекция будет меньше входной.


                                   Choose Topics



                                           список тем
                               «concurrent»



                                    Write Article     Review Article



                                                              [принять]        Publish
                                                                              Newsletter
                                                            [отклонить]
                                           окончание потока




                             Рис. 11.11. Окончание потока в активности

                        Описания объединений


                             По умолчанию объединение разрешает выполнение выходного потока,
                             когда все входные потоки достигли объединения. (Или, говоря более
                             формальным языком, оно порождает маркер выходного потока, когда
                             приходят маркеры всех входных потоков.) В некоторых случаях, в ча
                             стности, когда  есть поток с  несколькими маркерами,  полезно иметь
                             более сложное правило.

                             Описание объединения (join specification) – это логическое выражение,
                             присоединенное к объединению.  Каждый раз, когда в  объединение
                             прибывает маркер, вычисляется описание объединения, и если его зна
                             чение истинное, то порождается маркер. Поэтому на рис. 11.12, неза
                             висимо от того, выбираю ли я напиток (Select Drink) или кидаю монет
                             ку (Insert Coin),  автомат оценивает определение объединения.  Авто
                             мат утоляет мою жажду, только если я кинул достаточное количество
                             денег. Если, как в данном случае, вы хотите показать, что вы приняли
                             маркер в каждом входном потоке,  то необходимо именовать потоки
                             и включить их в описание объединения.















                        150                                          Глава 11. Диаграммы деятельности




                              Select Drink
                                              A
                                                               Dispense
                                                                Drink
                              Insert Coin     B
                                           {joinSpec = A и B и
                                           внесенная сумма >= цена выбранного напитка}

                               описание объединения

                             Рис. 11.12. Описание объединения

                        И еще немного

                             Я должен подчеркнуть, что эта глава лишь слегка затронула диаграм
                             мы деятельности. Учитывая объем языка UML, можно написать целую
                             книгу только об одной этой технологии. На самом деле я думаю, что
                             диаграммы деятельности могли бы стать отличной темой для книги,
                             посвященной пристальному рассмотрению нотаций и их применению.
                             Жизненно важный вопрос заключается в том, как широко они приме
                             няются. В настоящий момент диаграммы деятельности не относятся
                             к наиболее распространенным технологиям языка UML, и все их пред
                             шественники в области  моделирования потоков также  не пользова
                             лись  успехом. Технология диаграмм  еще не достигла необходимого
                             уровня для  описания поведения  таким  способом. С другой стороны,
                             в многочисленных сообществах есть проявления скрытой потребно
                             сти, которую могли бы удовлетворить стандартные приемы.

                        Когда применяются диаграммы деятельности

                             Самое большое достоинство диаграмм деятельности заключается в том,
                             что они поддерживают и стимулируют применение параллельных про
                             цессов. Именно благодаря этому они представляют собой мощное сред
                             ство моделирования потоков работ. Множество импульсов к развитию
                             UML 2 пришло от людей, вовлеченных в эти потоки работ.
                             Можно также применять диаграмму деятельности в качестве совмес
                             тимой с языком UML блоксхемы. Хотя это позволяет разрабатывать
                             блоксхемы, близкие к UML, но вряд ли это очень захватывающий
                             процесс. В принципе, можно воспользоваться преимуществами, пре
                             доставляемыми ветвлением и объединением, для описания параллель
                             ных алгоритмов одновременно выполняющихся программ. Хотя сам я
                             не очень активно применял параллельные циклы, но у меня также нет
                             достаточного количества подтверждений этого от людей, имеющих
                             большой опыт их применения. Я думаю, причина в том, что сложность















                        Где найти дополнительную информацию                                   151


                             параллельного программирования состоит в противостоянии данных
                             параллельных процессов, а диаграммы деятельности не могут оказать
                             большой помощи в этом вопросе.
                             В наибольшей степени их мощь может проявиться в случае примене
                             ния UML как языка программирования. Здесь диаграммы деятельно
                             сти являются ценным инструментом для представления логики пове
                             дения систем.
                             Мне часто приходилось видеть, как диаграммы деятельности приме
                             нялись для описания прецедентов. Опасность такого подхода в том,
                             что часто эксперты в предметной области с трудом могут им следовать.
                             Если дело обстоит так, то лучше обойтись обычной текстовой формой.

                        Где найти дополнительную информацию

                             Хотя  диаграммы деятельности всегда были довольно  сложным ин
                             струментом, а в UML 2 они стали еще сложнее, тем не менее не сущест
                             вует хорошей книги, в которой бы они описывались достаточно глубо
                             ко. Я надеюсь, что этот пробел когданибудь будет восполнен.
                             Различные ориентированные на потоки технологии по своему стилю
                             напоминают диаграммы деятельности.  Одна из лучших (но едва ли
                             широко  известная) – это Petri Nets, информацию  о которой  можно
                             найти на вебсайте http://www.daimi.au.dk/PetriNets/.






















                             12









                             Коммуникационные диаграммы





                             Коммуникационные диаграммы (communication diagrams) – это осо
                             бый вид диаграмм взаимодействия, акцентированных на обмене дан
                             ными между различными участниками взаимодействия. Вместо того
                             чтобы рисовать каждого участника в виде линии жизни и показывать
                             последовательность сообщений, располагая их по вертикали, как это
                             делается в диаграммах последовательности, коммуникационные диа
                             граммы допускают произвольное размещение участников, позволяя
                             рисовать  связи, показывающие  отношения участников, и  использо
                             вать нумерацию для представления последовательности сообщений.

                             В UML 1.x эти диаграммы назывались диаграммами кооперации (col
                             laboration diagrams).  Это подходящее название, и я подозреваю, что
                             оно будет существовать, пока люди не привыкнут к новому названию.
                             (Между этим понятием и кооперацией есть различие (стр. 161); отсю
                             да изменение названия.)

                             На рис. 12.1 приведена коммуникационная диаграмма для централи
                             зованного управления, показанного на рис. 4.2. С помощью коммуни
                             кационной диаграммы можно увидеть, как участники связаны друг
                             сдругом.
                             Кроме отображения связей, которые представляют собой экземпляры
                             ассоциаций, можно также  показать  временные связи, возникающие
                             только в контексте взаимодействия. В данном случае связь «local» (ло
                             кальная) от объекта Order (Заказ) к объекту Product (Продукт) – это ло
                             кальная переменная, а другими временными связями являются «para
                             meter» (параметр) и  «global» (глобальная). Эти ключевые  слова  упо
                             треблялись в UML 1, но пропали из UML 2. Они полезны, поэтому я на
                             деюсь, что разработчики от них не откажутся.
                             Стиль нумерации  на рис. 12.1 простой и общеупотребительный, но
                             в языке UML он не разрешен. В соответствии с правилами UML необ
                             ходимо придерживаться вложенной десятичной нумерации, как пока
                             зано на рис. 12.2.















                                                                                              153



                                                                                 !
                                 самовызов
                                                                              ненор
                                                         1: calculatePrice   мативный
                                                                  7: getDiscountInfo
                             5: calculateBasePrice ()
                             6: calculateDiscounts()  an Order                        a Customer

                                                                4: getPricingDetails
                                                                                     тип временной
                                         2: getQuantity()
                                         3: getProduct ()                                связи
                                                                             «local»


                                                  an Order Line                       a Product


                             Рис. 12.1. Коммуникационная диаграмма системы централизованного
                                      управления



                                                           1: calculatePrice

                                                                  1.5.1: getDiscountInfo
                             1.4: calculateBasePrice ()
                             1.5: calculateDiscounts()  an Order                      a Customer
                                                                 1.3: getPricingDetails

                                        1.1: getQuantity()
                                        1.2: getProduct ()




                                                   an Order Line                       a Product


                             Рис. 12.2. Коммуникационная диаграмма с вложенной десятичной нумерацией
                             Вложенная десятичная нумерация нужна, потому  что требуется ис
                             ключить неопределенность при самовызовах. На рис. 4.2 четко пока
                             зано, что метод getDiscountInfo вызывается из метода calculateDiscount.
                             Однако в случае применения линейной нумерации, как на рис. 12.1,
                             нельзя будет сказать, вызывается ли метод getDiscountInfo из метода
                             calculateDiscount или из более общего метода calculatePrice. Схема вло
                             женной нумерации позволяет обойти эту трудность.
                             Несмотря на ее неправомерность, многие специалисты предпочитают
                             линейную схему нумерации. Вложенная нумерация может быть очень















                        154                                    Глава 12. Коммуникационные диаграммы


                             сложной, в частности потому, что вызовы могут иметь большой уро
                             вень вложенности, что приводит к такой последовательности номеров,
                             как 1.1.1.2.1.1. В таких случаях лекарство от неопределенности хуже
                             болезни.
                             Кроме чисел в сообщениях можно увидеть и буквы. Эти символы обо
                             значают различные потоки управления. Так, A5 и B2 могут быть раз
                             личными потоками; сообщения 1a1 и 1b1 могут быть различными по
                             токами, параллельно вложенными в сообщение 1. Буквы, обозначаю
                             щие потоки, можно увидеть также и на диаграммах последовательно
                             сти, хотя это и не дает визуального представления о параллельности.
                             Коммуникационные диаграммы не имеют точно определенных нота
                             ций для управляющей логики. Они допускают применение маркеров
                             итерации и защиты (стр. 86), но не позволяют полностью определить
                             алгоритм управления.  Не существует  также специальных обозначе
                             ний для создания и  удаления  объектов, но ключевые слова  «create»
                             и «delete» соответствуют общепринятым соглашениям.

                        Когда применяются коммуникационные
                        диаграммы

                             Основной вопрос, связанный с коммуникационными диаграммами,
                             заключается в том, в каких случаях надо предпочесть их, а не более
                             общие диаграммы последовательности. Ведущую роль в принятии та
                             кого решения играют личные предпочтения: у людей разные вкусы.
                             Чаще всего именно это определяет тот или иной выбор. В целом, боль
                             шинство специалистов, повидимому, предпочитает диаграммы после
                             довательности, а что касается меня, то я поддерживаю большинство.
                             Более рациональный подход утверждает, что диаграммы последова
                             тельности удобнее,  если  вы хотите подчеркнуть последовательность
                             вызовов, а коммуникационные диаграммы лучше выбрать, когда надо
                             акцентировать внимание на связях. Многие специалисты считают, что
                             коммуникационные диаграммы проще модифицировать на доске, по
                             этому они хорошо подходят для рассмотрения вариантов, хотя я в та
                             ких случаях обычно предпочитаю CRCкарточки.






















                                                                                 13









                                                             Составные структуры





                             Одной из наиболее значимых новых черт языка UML 2 является воз
                             можность превращать класс в иерархию внутренних структур. Это по
                             зволяет разбить сложный объект на составляющие.
                             На рис. 13.1 показан класс TV Viewer (Телевизор) вместе с интерфейса
                             ми, которые он предоставляет и которые требует (стр. 96). Я показал
                             его двумя способами: с помощью шаровогнездовой нотации и с помо
                             щью перечисления внутри объекта.

                              TV control UI  TV control API

                                                                     TV Viewer

                                                               «предоставляемый интерфейс»
                                                               TV control UI
                                    TV Viewer                  TV control API
                                                     display   «требуемый интерфейс»
                                                               tuning
                                                               display
                             tuning          picture stream    picture stream

                             Рис. 13.1. Два способа представления объекта TV Viewer и его интерфейсов

                             На рис. 13.2 показан этот же класс, разбитый внутри на две части, ко
                             торые предоставляют и требуют различные интерфейсы. Каждая часть
                             имеет имя в виде имя:класс, в котором каждый из составляющих его
                             элементов может отсутствовать.  Составляющие части не  являются
                             описанием экземпляров, поэтому они выделены жирным шрифтом, а
                             не подчеркнуты.
                             Можно также указать количество экземпляров конкретной части. На
                             рис. 13.2 показано, что каждый объект TV Viewer содержит один гене
                             ратор (Generator) и один блок управления (controls).















                        156                                             Глава 13. Составные структуры


                                      TV control UI

                                                       кратность

                                   TV Viewer

                             часть                    1
                                             controls :
                                            TVPresenter
                                                         предоставляющий разъем
                                      разъем

                                                                    display
                                           :Generator [1]
                                                                    TV control API


                                        tuning       picture stream





                             Рис. 13.2. Внутренний вид компонента (пример, предложенный
                                      Джимом Рамбо)

                             Чтобы обозначить часть,  реализующую интерфейс, надо нарисовать
                             разъем, предоставляемый этим интерфейсом. Аналогично, чтобы пока
                             зать часть, нуждающуюся в интерфейсе, надо нарисовать разъем, пре
                             доставляемый этому интерфейсу. Кроме того, разъемы между частями
                             можно показать или с помощью простой линии, как сделано в данном
                             случае, или с помощью шаровогнездовой нотации (стр. 98).
                             К внешней структуре можно добавить порты (рис. 13.3). Порты позво
                             ляют группировать требуемые и предоставляемые интерфейсы в логи

                             TV control UI   display

                                           windowing
                                                         tuning
                                                   tuner
                                      TV Viewer
                                                         picture stream

                                      API
                                                      порт
                                       TV control API
                             Рис. 13.3. Компонент с несколькими портами















                        Когда применяются составные структуры                                 157


                             ческие взаимодействия, которые компонент имеет с объектами внеш
                             него мира.

                        Когда применяются составные структуры

                             Составные структуры являются нововведением в UML 2, хотя некото
                             рые прежние методы реализовывали подобные идеи. Правильный под
                             ход к различию между пакетами и составными структурами заключает
                             ся в том, что пакеты представляют группы времени компиляции, а со
                             ставные структуры представляют группы времени выполнения. А раз
                             так, то они лучше подходят для показа компонентов и способов их раз
                             биения на части; следовательно, множество этих нотаций применяется
                             в диаграммах компонентов.
                             Поскольку составные  структуры  –  новый элемент языка UML 2,  то
                             слишком рано говорить об эффективности их практического примене
                             ния; многие члены сообщества UML думают, что эти диаграммы ста
                             нут весьма ценным дополнением.






















                             14









                             Диаграммы компонентов





                             В объектноориентированном сообществе идут дебаты о том, в чем со
                             стоит различие между компонентом и обычным классом. Я не хочу об
                             суждать здесь этот спорный вопрос, но могу показать нотацию языка
                             UML, используемую, чтобы отличить их друг от друга.
                             В UML 1 был отдельный символ для компонента (рис. 14.1). В UML 2
                             этого значка нет, но можно обозначить прямоугольник класса похо
                             жим значком. Или можно воспользоваться ключевым словом «compo
                             nent» (компонент).



                                     Widget                    Widget



                              нотация UML 1              нотация UML 2
                             Рис. 14.1. Нотация для компонентов

                             Кроме этого значка компоненты не принесли с собой никаких новых
                             обозначений. Компоненты связываются между собой с помощью пре
                             доставляемых или требуемых интерфейсов, при этом шаровогнездо
                             вая нотация  (стр. 98) обычно применяется  только на диаграммах
                             классов. Можно также  разбивать компоненты на  части с  помощью
                             диаграмм составных структур.

                             На рис. 14.2 показан пример простой диаграммы компонентов. В этом
                             примере компонент Till (Касса) может взаимодействовать с компонен
                             том Sales Server (Сервер продаж) с помощью интерфейса sales message
                             (Сообщение о  продажах).  Поскольку сеть ненадежна, то компонент
                             Message Queue (Очередь сообщений) установлен так, чтобы касса могла
                             общаться с сервером, когда сеть работает, и разговаривать с очередью
                             сообщений, когда сеть отключена. Тогда очередь сообщений сможет
                             поговорить с сервером, когда сеть снова станет доступной. В результате















                                                                                              159




                                    Till
                                                                    Sales Server
                                         sales
                                        message
                                                             Transaction          Accounting
                                                             Processor              Driver


                                  Message Queue





                                                                                  Accounting
                                                                                    System

                             Рис. 14.2. Пример диаграммы компонентов

                             очередь сообщений предоставляет интерфейс для разговора с кассой, и
                             требует такой же интерфейс для разговора с сервером. Сервер разделен
                             на два основных компонента: Transaction Processor (Процессор транз
                             акций) реализует интерфейс сообщений, а Accounting Driver (Драйвер
                             счетов) общается с Accounting System (Система ведения счетов).
                             Как я уже говорил, вопрос о сущности компонента является предме
                             том бесконечных споров. Вот одно из наиболее продуманных сужде
                             ний, обнаруженных мною:
                                Компоненты – это не технология. Технические специалисты считают их
                                трудными для понимания. Компоненты –  это скорее стиль отношения
                                клиентов к программному обеспечению. Они хотят иметь возможность
                                покупать  необходимое  им  программное обеспечение частями,  а также
                                иметь возможность обновлять его, как они обновляют свою стереосис
                                тему. Они хотят, чтобы новые компоненты работали так же, как и
                                прежние, и обновлять их согласно своим планам, а не по указанию произво
                                дителей. Они хотят, чтобы системы различных производителей могли
                                работать вместе и были взаимозаменяемыми. Это очень разумные требо
                                вания. Одна загвоздка: их трудно выполнить.
                                                                    Ральф Джонсон (Ralph Johnson),
                                                        http://www.c2.com/cgi/wiki?DoComponentsExist
                             Важно то, что компоненты  представляют элементы,  которые можно
                             независимо друг от друга купить и обновить. В результате разделение
                             системы на компоненты является в большей мере маркетинговым ре
                             шением, чем техническим.  Прекрасное руководство по данному  во
                             просу представляет книга Хохмана [23]. Она также напоминает о том,















                        160                                          Глава 14. Диаграммы компонентов


                             что следует остерегаться разделения системы на слишком мелкие ком
                             поненты, поскольку очень большим количеством компонентов трудно
                             управлять, особенно когда производство версий поднимает свою урод
                             ливую голову; отсюда пошло выражение «ад DLL». В ранних версиях
                             языка UML компоненты применялись для представления физических
                             структур, таких как DLL. Теперь это не актуально; в настоящее время
                             эта задача решается при помощи артефактов (artifacts) (стр. 121).

                        Когда применяются диаграммы компонентов

                             Диаграммы компонентов следует применять, когда система разделя
                             ется на компоненты и надо показать их взаимоотношения посредством
                             интерфейсов или схему компонентов в низкоуровневой структуре сис
                             темы.






















                                                                                 15









                                                                            Кооперации





                             В отличие от других глав этой книги, в данной не обсуждаются фор
                             мальные диаграммы UML 2. В стандарте UML кооперации рассматри
                             ваются как часть  составных  структур, но диаграмма коопераций
                             в действительности совершенно отличается от  составных структур
                             и применялась в UML 1 без всякой связи с составными структурами.
                             Поэтому я счел, что лучше обсудить кооперации в отдельной главе.

                             Рассмотрим систему обозначений аукциона. В любом аукционе (Auc
                             tion) могут участвовать продавец (seller), покупатели (buyer), множест
                             во вещей (lot) и какиелибо предложения о покупке (offer). Мы можем
                             описать эти элементы в терминах диаграммы классов (рис. 15.1) и, воз
                             можно, посредством нескольких диаграмм взаимодействий (рис. 15.2).


                                                         Auction




                                                      1
                                           buyer                 *      offer


                                                                        *
                                   кооперация          роль
                                                                        1
                                                      1         1
                                           seller                        lot








                             Рис. 15.1. Кооперация вместе с ее классами и ролями















                        162                                                     Глава 15. Кооперации




                                   /seller            b1/ buyer           b2/ buyer



                                          объявление лота


                                       предложение о покупке

                                                           предложение о покупке

                                        принять предложение



                                       отклонить предложение





                             Рис. 15.2. Диаграмма последовательности для аукционной кооперации

                             На рис. 15.1 представлена не совсем обычная диаграмма классов. Во
                             первых, она обведена  пунктирным  эллипсом, который представляет
                             аукционную кооперацию. Вовторых, так называемые классы в коопе
                             рации – это не классы, а роли (roles), которые реализовываются в про
                             цессе выполнения кооперации, поэтому их  имена начинаются  с ма
                             ленькой буквы. Сопоставление фактических интерфейсов или классов
                             ролям кооперации не является чемто необычным, но тем не менее вы
                             не обязаны это делать.
                             Как видите, на диаграмме взаимодействий участники именуются не
                             много необычно. В кооперации схема именования выглядит следующим
                             образом: имяучастника / имяроли : имякласса. Как всегда, все эти эле
                             менты необязательны.
                             Применение  кооперации можно обозначить, отмечая  ее наличие на
                             диаграмме классов, как показано на рис. 15.3, где представлены неко
                             торые классы приложения. Связи, идущие от кооперации к этим клас
                             сам, показывают, как классы играют различные роли, определенные
                             в кооперации.
                             В языке UML предполагается, что  можно  показать применение пат
                             тернов, но вряд ли автор какихлибо паттернов будет это делать. Эрих
                             Гамма (Erich  Gamma)  разработал прекрасную альтернативную нота
                             цию (рис. 15.4). Элементы диаграммы обозначаются либо именем пат
                             терна, либо комбинацией паттерн:роль.















                        Когда применяются кооперации                                          163



                                                        *       Bid       Offer
                                                             (предложение
                                                                цены)

                                                               *
                                                                                  назначение роли
                                buyer  1                           1
                                             seller
                                   Party                       House
                                             *          *
                                      buyer, seller             lot


                                                                                 Auction

                                                            наличие кооперации
                             Рис. 15.3. Наличие кооперации


                                      Composite: Component       Test        tests
                                                             run(TestResult)
                                                                            *






                                      Command        TestCase            TestSuite

                               Pluggable Selector  name
                                                                      run(TestResult)  Composite
                                Template Method  run(TestResult)
                                                 runTest()
                                                 setUp()                    !
                                                 tearDown()               ненор
                                                                         мативный
                                           Composite: Leaf

                             Рис. 15.4. Необычный способ показа применения паттерна в JUnit (junit.org)

                        Когда применяются кооперации

                             Кооперации существуют со времен UML 1, но я признаю, что вряд ли
                             применял их даже для разработки паттернов. Кооперации предостав
                             ляют способ группирования элементов взаимодействия, когда роли ис
                             полняются различными классами. Однако на практике я не встречал,
                             чтобы этот тип диаграмм когото покорил.






















                             16









                             Диаграммы обзора взаимодействия




                             Диаграммы обзора  взаимодействия – это  комбинация диаграмм  дея
                             тельности и диаграмм последовательности. Можно считать диаграммы
                             обзора взаимодействия диаграммами  деятельности, в которых дея
                             тельности заменены  небольшими  диаграммами последовательности,
                             или диаграммами последовательности, разбитыми с помощью нотации
                             диаграмм деятельности для отображения потока управления. В любом
                             случае они представляют довольно необычную смесь.
                             На рис. 16.1 показан пример простой диаграммы такого типа; нотация
                             нам уже знакома по главам, посвященным диаграммам деятельности
                             и диаграммам последовательности. В этой диаграмме мы хотим соста
                             вить и отформатировать отчетный  доклад  о заказах. Если клиент
                             внешний, то информацию поставляет XML, а если внутренний, то ин
                             формация берется из базы данных. Небольшие диаграммы последова
                             тельности  показывают две альтернативы. После  получения данных
                             мы форматируем отчет; в этом случае мы не представляем диаграмму
                             последовательности, а просто ссылаемся на нее.

                             Когда применяются диаграммы обзора

                             взаимодействия

                             Этот тип диаграмм  появился в UML 2, поэтому еще трудно понять, на
                             сколько успешно они решают практические задачи. Я от них не в вос
                             торге, поскольку они сочетают два разных стиля, и я считаю, что соче
                             тание это не очень удачное. На какой диаграмме остановиться – на диа
                             грамме деятельности или на диаграмме последовательности – нужно
                             решать на основании того, какая из них вам лучше подходит.















                        Когда применяются диаграммы обзора взаимодействия                     165






                                         [внешние данные]       [внутренние данные]




                           sd                                   sd



                           :Customer    :XMLParser                 :Customer   :Database

                                                                        выбор среди клиентов и заказов
                                   load

                                                                           new
                                                 parse                                 :Order
                                                                                      Summary
                                 getName


                                 getOrders

                                   new
                                               :Order
                                              Summary








                                            ref
                                                 Format Order Summary Report







                        Рис. 16.1. Диаграмма обзора взаимодействий






















                             17









                             Временные диаграммы





                             После окончания средней школы и до того как начать свою компью
                             терную карьеру, я работал инженеромэлектронщиком. Поэтому я ис
                             пытываю щемящее чувство узнавания,  когда  вижу, как язык UML
                             определяет временные диаграммы в качестве своих стандартных диа
                             грамм. Временные диаграммы существовали в электронной промыш
                             ленности испокон веков, и никто не мог подумать, что потребуется по
                             мощь UML, чтобы  понять их назначение.  Но уж раз  они появились
                             в UML, то заслужили краткого упоминания.
                             Временные диаграммы – это еще одна форма диаграмм взаимодейст
                             вия, которая акцентирована на временных ограничениях: либо для
                             одиночного объекта, либо,  что более полезно,  для группы объектов.
                             Давайте рассмотрим простой сценарий, основанный на использовании
                             насоса (Pump) и нагревательного элемента (Hotplate) в кофеварке (coffee
                             pot). Представим себе правило, которое гласит, что между включени
                             ем насоса и включением нагревательного элемента должно пройти по
                             крайней мере  10 секунд. Когда  емкость с водой  становится пустой
                             (waterEmpty), насос выключается, а нагревательный элемент не может
                             оставаться включенным более 15 минут.
                             На рис. 17.1 и 17.2 показаны альтернативные способы представления
                             таких временных ограничений. Главное различие состоит в том, что
                             на рис. 17.1  изменения  состояния обозначаются переходом от одной
                             горизонтальной линии к другой, а на рис. 17.2 горизонтальное распо
                             ложение остается таким же, а изменения состояния обозначаются пе
                             рекрещиванием горизонтальных линий. Стиль, представленный на
                             рис. 17.1, следует предпочесть, когда состояний немного, а стиль, по
                             казанный на рис. 17.2, лучше подходит, когда имеешь дело с большим
                             количеством состояний.
                             Пунктирные линии, при помощи которых я обозначил временные гра
                             ницы {>10s}, не обязательны. Если вы считаете, что они помогут точно
                             определить, какие события вызывают временные ограничения, то на
                             рисуйте их.















                        Когда применяются временные диаграммы                                 167


                                         состояние
                                                                  событие
                                                  waterEmpty
                                Pump  On
                                     Off
                                                                             изменение
                                Hotplate  On
                                                                             состояния
                                     Off
                                                            {<15m}
                                              {>10s}
                                   объект
                                                               временное ограничение
                             Рис. 17.1. Временная диаграмма, на которой состояния
                                      представлены в виде линий


                                           изменение
                                 состояние  состояния
                                                             событие
                                             waterEmpty
                               Pump  Off    On         Off



                               Hotplate  Off        On {<15m}    Off




                                        {>10s}

                                   объект                временное ограничение
                             Рис. 17.2. Временная диаграмма, на которой состояния
                                      представлены в виде областей


                        Когда применяются временные диаграммы

                             Временные диаграммы полезны для обозначения временных интерва
                             лов между изменениями состояний различных объектов. Кроме того,
                             эти диаграммы знакомы инженерам по оборудованию.






















                             A









                             Отличия версий языка UML




                             Когда вышло в свет первое издание этой книги, язык UML имел еще
                             версию 1.0.  С ее  появлением термины для многих  элементов языка
                             UML устоялись, а консорциум OMG получил официальное признание.
                             С тех пор версии языка UML пересматривались несколько раз. В этом
                             приложении описываются все существенные изменения языка UML с
                             момента появления версии 1.0 и то, как эти изменения повлияли на
                             материал данной книги. Эволюция языка UML потребовала обновле
                             ния книги, и третье издание содержит материал, отражающий ситуа
                             цию на момент написания.

                             Эволюция языка UML

                             Первой общедоступной версией  языка UML  был Унифицированный
                             метод версии 0.8, который был представлен на конференции OOPSLA,
                             состоявшейся в октябре 1995 года. Унифицированный метод был раз
                             работан Г. Бучем и Д. Рамбо (к этому  моменту А. Джекобсон еще не
                             был сотрудником компании Rational). В 1996 году компания Rational
                             выпустила версии 0.9 и 0.91, в работе над которыми принимал участие
                             Джекобсон. После выхода этой последней версии метод стал называть
                             ся UML.
                             В январе 1997 года компания Rational вместе с группой партнеров пред
                             ставила на рассмотрение инициативной группы анализа и проектирова
                             ния из OMG версию 1.0 языка UML. В дальнейшем компания Rational
                             и другие участники объединили свои усилия и  в  сентябре 1997  года
                             предложили в качестве стандарта версию 1.1. В конце 1997 года вер
                             сия была одобрена консорциумом OMG. Однако при невыясненных об
                             стоятельствах консорциум OMG назвал этот стандарт языка UML вер
                             сией 1.0. Таким образом, в то время существовали две версии языка
                             UML: версия 1.0 консорциума OMG и версия 1.1 компании Rational,
                             которые не следует путать с версией 1.0 компании Rational. На прак
                             тике же все разработчики называли этот стандарт версией 1.1.















                        Отличия версий языка UML                                              169


                             Затем последовала  целая серия  переработок языка UML. Версия  1.1
                             появилась в 1998 году, версия 1.3 в 1999, 1.4 в 2001 и 1.5 в 2002. Боль
                             шинство изменений в версиях 1.x в основном были скрыты в глубине
                             UML, за исключением версии 1.3, изменения в которой были явно
                             видны, особенно это касается прецедентов и диаграмм деятельности.
                             Хотя выпуск версий UML 1 продолжался, разработчики UML основное
                             внимание стали уделять UML 2. Первый RFP (Request for Proposals –
                             запрос на предложение) был объявлен в 2000, но UML 2 не был доста
                             точно стабилен вплоть до 2003 года.
                             Разработка UML почти наверняка будет продолжаться и впредь. До
                             полнительные сведения можно почерпнуть на форуме по языку UML
                             (http://uml'forum.com). Кроме того, некоторую информацию можно
                             найти на моем сайте (http://martinfowler.com).

                        Изменения в первом издании книги

                             В процессе эволюции языка UML я пытался учесть его изменения, что
                             привело к появлению нескольких вариантов книги «UML. Основы».
                             При этом я  пользовался хорошей  возможностью исправить ошибки
                             и сделать изложение более ясным.
                             Наиболее динамичным периодом внесения изменений было время пе
                             чати первого издания, когда нам часто приходилось обновлять книгу
                             от выпуска к выпуску, чтобы сохранять соответствие с появляющими
                             ся стандартами UML. Выпуски с первого по пятый были основаны на
                             версии UML 1.0. Изменения между этими выпусками были минималь
                             ными. В шестой выпуск вошла версия 1.1.
                             Выпуски с седьмого по десятый в основе имели версию UML 1.2; вер
                             сия UML 1.3 впервые была использована в одиннадцатом выпуске. На
                             обложках выпусков, базировавшихся на версиях UML после 1.0, ста
                             вился номер выпуска.
                             С первого по шестой выпуски второго издания были основаны на вер
                             сии UML 1.3. Небольшие изменения, появившиеся в версии UML 1.4,
                             впервые были учтены в седьмом выпуске.
                             Целью третьего издания было обновление книги до UML 2 (см. табл. A.1).
                             Далее в этом приложении внимание сосредоточено на основных отли
                             чиях в языке UML, имевших место при изменениях версий с 1.0 на 1.1,
                             с 1.2 на 1.3. и с 1.x на 2.0. Мне бы не хотелось подробно обсуждать все
                             изменения, поэтому остановлюсь лишь на тех из них, которые каким
                             то образом затрагивают материал книги «UML. Основы» или относятся
                             к важным свойствам языка UML, рассмотренным в первом издании.
                             Продолжая придерживаться стиля первого издания, я рассмотрю ос
                             новные элементы языка UML и особенности применения языка UML
                             при разработке реальных проектов. Как и ранее, выбор материала
                             и соответствующие рекомендации основаны на моем собственном опы















                        170                                                          Приложение A


                             те. Если обнаружится противоречие между моим изложением и офи
                             циальной документацией по языку UML, следует придерживаться
                             официальной документации. (Однако мне бы хотелось об этом знать,
                             чтобы впоследствии внести соответствующие исправления.)
                             Я также воспользуюсь представленной возможностью отметить те или
                             иные важные ошибки или погрешности предыдущих вариантов кни
                             ги. Спасибо читателям, которые сообщили мне о них.
                             Таблица A.1. Книга «UML. Основы» и соответствующие версии языка
                              «UML. Основы»                     Версии UML
                              1е издание                       UML 1.0–1.3
                              2е издание                       UML 1.3–1.4
                              3е издание                       UML 2.0 и далее

                        Отличия версий языка UML 1.0 и 1.1

                        Тип и класс реализации

                             В первом издании книги «UML. Основы» я рассмотрел различные точ
                             ки зрения на разработку и те возможные изменения, которые произой
                             дут в результате совершенствования способов изображения и интер
                             претации моделей, в частности это касается диаграмм классов. Эти об
                             стоятельства нашли отражение в языке UML, поскольку теперь утвер
                             ждается, что все классы на диаграмме классов могут быть определены
                             либо как типы, либо как классы реализации.
                             Класс реализации  (implementation class)  соответствует некоторому
                             классу в контексте разрабатываемой программы. Тип (type) является бо
                             лее расплывчатым понятием; он представляет некоторую абстракцию,
                             которая в меньшей степени касается реализации. Это может быть тип
                             CORBA, описание класса с точки зрения спецификации или некоторая
                             концептуальная модель. При необходимости можно определить допол
                             нительные стереотипы, чтобы в последующем различать эти понятия.
                             Можно установить, что для отдельной диаграммы все классы облада
                             ют некоторым особым стереотипом. Это может произойти в том слу
                             чае, когда диаграмма отражает  отдельную  точку зрения.  При этом
                             подход с точки зрения реализации предполагает использование клас
                             сов реализации, а концептуальная точка зрения и точка зрения специ
                             фикации предполагают использование типов.
                             Если некоторый класс реализации представляет один или несколько
                             типов, то это может быть показано с помощью отношения реализации.
                             Между типом и интерфейсом существует различие. Предполагается,
                             что некоторый интерфейс должен непосредственно соответствовать
                             интерфейсу в стиле Java или COM. В этом случае интерфейсы имеют
                             только операции и не имеют атрибутов.















                        Отличия версий языка UML                                               171


                             Для класса реализации может быть использована только однозначная
                             статическая классификация, однако в случае типов классификация мо
                             жет быть множественной и динамической. (Я думаю, дело тут в том, что
                             основные объектноориентированные языки поддерживают единичную
                             статическую классификацию. Если в один прекрасный день вы будете
                             пользоваться языком, который поддерживает множественную или ди
                             намическую классификацию, то это ограничение может быть снято.)

                        Полные и неполные ограничения классификатора

                             В предыдущих выпусках «UML. Основы» было отмечено, что ограниче
                             ние {complete} (полный) для некоторого обобщения устанавливает, что
                             все экземпляры супертипа должны быть также экземпляром некоторо
                             го подтипа в данном разбиении. Вместо этого в языке UML версии 1.1
                             определено ограничение {complete}, которое указывает лишь на то, что
                             соответствующее разбиение отражает все подтипы. А это совсем не то
                             же самое. Я обнаружил множество  несоответствий в  интерпретации
                             этого ограничения, поэтому вам следует обратить на это внимание. Ес
                             ли вы хотите показать, что все экземпляры супертипа должны быть
                             экземпляром одного из подтипов, то во избежание недоразумений я со
                             ветую использовать другое ограничение. В настоящее время я приме
                             няю ограничение {mandatory} (обязательный).

                        Композиция

                             Применение композиции в языке UML версии 1.0 означало, что эта
                             связь неизменна (immutable) или заморожена (frozen), по крайней ме
                             ре, для компонентов с одним значением. Это ограничение больше не
                             является частью определения композиции.

                        Неизменность и замороженность

                             Язык UML определяет ограничение {frozen} (замороженный) для ука
                             зания неизменяемости ролей ассоциации. Как определено в настоящее
                             время, это  ограничение не может быть применено к  атрибутам  или
                             классам. В своей текущей работе вместо неизменности я употребляю
                             термин frozen, тем самым я могу применять это ограничение к ролям
                             ассоциаций, классам и атрибутам.

                        Возвраты на диаграммах последовательности
                             В UML 1.0 обратное сообщение (или возврат) на диаграмме последова
                             тельности вместо  сплошной  стрелки  обозначалось обычной стрелкой
                             (см. предыдущее  издание).  Это привело к  некоторым трудностям, по
                             скольку данное различие трудно заметить, и оно легко приводит к недо
                             разумениям. В UML 1.1 возвраты изображаются пунктирной линией со
                             стрелкой, что мне нравится больше, поскольку делает возвраты намно
                             го более очевидными. (Именно поэтому в своей книге «Паттерны анали















                        172                                                          Приложение A


                             за» [16] я использовал пунктирные возвраты, что представляется мне
                             весьма важным.) Для последующего применения возвратов можно на
                             значить им имена вида enoughStock :=check().
                        Использование термина «Role»

                             В языке UML версии 1.0 термин роль (role) в основном указывал на
                             правление некоторой ассоциации (см. предыдущее издание). В языке
                             UML версии 1.1 данное определение рассматривается как  роль ассо
                             циации  (association role). Помимо нее существует  роль кооперации
                             (collaboration role), то есть  роль, исполняемая некоторым экземпля
                             ром класса в  кооперации. Версия UML 1.1 придает кооперации еще
                             большую выразительность, и похоже, что такое толкование понятия
                             «роль» может стать ведущим.

                        Отличия версий языка UML 1.2 (и 1.1) и 1.3 (и 1.5)

                        Прецеденты

                             В прецедентах появились новые отношения. В UML 1.1 имелись толь
                             ко два типа отношений между прецедентами:  «uses» (использует) и
                             «extends» (расширяет), каждое их которых является стереотипом обоб
                             щения. UML 1.3 предлагает три типа отношений:
                             •  Конструкция  «includes»  (включает) является стереотипом  зависи
                                мости. Она означает, что выполнение одного прецедента включает
                                в себя другой  прецедент. Обычно это отношение встречается в си
                                туации, когда несколько прецедентов имеют общие этапы или час
                                ти. Включаемый прецедент может предоставлять другим некоторое
                                общее поведение. В качестве примера можно рассмотреть банкомат
                                (ATM), в контексте которого  оба  прецедента  Withdraw Money (Полу
                                чить деньги) и  Make Transfer  (Сделать перевод) используют  преце
                                дент Validate Customer (Проверить подлинность клиента). Это отно
                                шение в общем случае заменяет применение стереотипа «uses».
                             •  Обобщение (generalization) прецедента  означает,  что один  преце
                                дент представляет собой вариацию другого. Таким образом, можно
                                иметь один прецедент  для сценария «Получить деньги» (базовый
                                вариант использования) и другой прецедент для ситуации, когда
                                выдача денег невозможна по причине отсутствия средств на счету
                                клиента. Отказ от выплаты денег можно представить в виде отдель
                                ного прецедента, который уточняет базовый прецедент. (Кроме то
                                го, можно определить еще и дополнительный сценарий для преце
                                дента «Получить деньги».) В этом случае специальный прецедент,
                                подобно рассмотренному выше, может изменить какойлибо аспект
                                базового прецедента.
                             •  Конструкция  «extends»  (расширяет) является стереотипом  зависи
                                мости. Она обеспечивает более управляемую форму расширения по















                        Отличия версий языка UML                                              173


                                сравнению с отношением обобщения. В этом случае в базовом пре
                                цеденте задается несколько точек расширения. Включающий пре
                                цедент может  вносить изменения  в свое поведение только в этих
                                точках расширения. К примеру, при рассмотрении покупки товара
                                через Интернет можно определить один прецедент для покупки то
                                вара с точками расширения для ввода информации о доставке това
                                ра и ввода информации об оплате товара. После чего этот прецедент
                                может быть расширен для постоянных клиентов, для которых по
                                добная информация может быть получена другим способом.
                             Существует некоторая путаница насчет старой и новой интерпретаций
                             указанных отношений. Большинство разработчиков применяют  сте
                             реотип  «uses» в ситуациях, когда  версия  1.3 рекомендует указывать
                             стереотип  «includes», поскольку  для  многих из них  стереотип  «in
                             cludes» может быть заменен стереотипом «uses». И большинство разра
                             ботчиков применяют стереотип «extends» из версии 1.1 в более широ
                             ком смысле, предполагая не только отношение «extends» из версии 1.3,
                             но также и важнейшую составляющую отношения обобщения в вер
                             сии 1.3. Поэтому можно считать, что отношение со стереотипом «ex
                             tends» расщепляется  в  версии  1.3 на  два отношения: со стереотипом
                             «extends» и обобщение (generalization).
                             Хотя это объяснение охватывает большую часть известных мне прило
                             жений языка UML, в настоящее время мне неизвестен строгий и пра
                             вильный способ применения  в них  старых отношений. Однако  боль
                             шинство разработчиков вовсе не пользуются этим строгим определени
                             ем отношений, поэтому мне не хотелось бы развивать эту тему дальше.

                        Диаграммы деятельности
                             С появлением версии 1.2 языка UML осталось лишь несколько откры
                             тых вопросов относительно семантики диаграмм деятельности. В вер
                             сии 1.3 на большинство из этих вопросов были даны ответы, которые
                             были закреплены в семантике языка UML.
                             При разработке условного поведения теперь можно обозначать приня
                             тие решения в форме ромба – как для слияния (merge), так и для ветв
                             ления (branch). Хотя для описания условного поведения ни ветвления,
                             ни слияния не являются необходимыми, все более общепринятым ста
                             новится способ изображения, заключающий условное поведение в
                             скобки.
                             Символ синхронизации в форме черты теперь относится как к ветвле
                             нию  (когда управление расщепляется), так и к  объединению  (когда
                             синхронизируемое управление объединяется снова). Однако теперь ни
                             каких дополнительных условий на объединение не накладывается. Не
                             обходимо лишь придерживаться правил, гарантирующих соответствие
                             ветвлений и объединений. По существу это означает, что каждое ветв
                             ление должно иметь соответствующее объединение, которое соединяет
                             все параллельные нити процесса, берущие начало в исходном ветвле















                        174                                                          Приложение A


                             нии. Хотя ветвления и объединения могут быть вложенными, их мож
                             но удалить с диаграммы, если потоки соединяют ветвления (или объе
                             динения) напрямую.
                             Объединения вступают в силу только тогда, когда все входящие в них
                             потоки завершены. Однако можно определить некоторое условие для
                             исходящего из ветвления потока. Если это условие не выполняется, то
                             соответствующий поток считается завершенным и может участвовать
                             в объединении остальных потоков.
                             Свойство множественной инициализации больше не поддерживается.
                             Вместо него можно определить динамическую параллельность в неко
                             торой деятельности с  помощью символа «*» внутри прямоугольника
                             деятельности. Такая деятельность может выполняться параллельно не
                             сколько раз; все ее вызовы должны быть завершены, прежде чем смо
                             жет быть выполнен какойлибо выходящий из нее переход. Это в неко
                             торой степени эквивалентно множественной инициализации и сответ
                             ствующему условию синхронизации, хотя такой способ и менее гибок.
                             Эти правила  в какойто степени уменьшают  гибкость диаграмм дея
                             тельности, однако они гарантируют, что диаграммы деятельности яв
                             ляются на самом деле частными случаями конечных автоматов. Отно
                             шение между диаграммами деятельности и конечными автоматами
                             стало предметом дискуссии инициативной группы RTF. Последующие
                             версии языка UML (после 1.4)  вполне могут определить  диаграммы
                             деятельности как диаграммы совершенно другой формы.

                        Отличия версий языка UML 1.3 и 1.4

                             Наиболее значимым отличием версии 1.4 являются  профили (pro
                             files), которые позволяют группировать расширения в единое, логиче
                             ски связанное множество. В документацию по языку UML включена
                             пара примеров профилей. Вместе с тем, определение стереотипов ста
                             ло более формальным, а элементы модели теперь могут иметь несколь
                             ко стереотипов; в версии UML 1.3 они были ограничены одним стерео
                             типом.
                             В язык UML были добавлены  артефакты (artifacts). Артефакт – это
                             физическое олицетворение  компонента, так, например, Xerces – это
                             компонент, а все копии файла Xerces.jar на моем жестком диске – это
                             артефакты, которые реализуют компонент Xerces.
                             До версии 1.3 в метамодели UML не было инструмента для работы с об
                             ластью видимости пакетов (package visibility). Теперь в вашем распо
                             ряжении символ «~».
                             Кроме того, в версии UML 1.4 обычная стрелка обозначает асинхрон
                             ность на диаграммах взаимодействия – скорее всего, для обратной со
                             вместимости. Это затрагивает немногих специалистов, включая меня.















                        Отличия версий языка UML                                              175


                        Отличия версий языка UML 1.4. и 1.5

                             Принципиальным отличием  стало  введение  в язык UML семантики
                             операций – необходимый шаг для превращения UML в язык програм
                             мирования. Это было сделано, чтобы позволить специалистам рабо
                             тать, не дожидаясь окончания разработки полной версии UML 2.

                        От UML 1.x к UML 2.0

                             UML 2 представляет наибольшие изменения, произошедшие в языке.
                             В этой версии изменилось все, и многие изменения коснулись книги
                             «UML. Основы».
                             Глубокие изменения произошли в метамодели языка UML. И хотя эти
                             изменения не повлияли на книгу, они очень важны для определенных
                             групп специалистов.
                             Одним из наиболее очевидных изменений стало введение новых типов
                             диаграмм. Диаграммы объектов и диаграммы пакетов широко исполь
                             зовались и прежде, но не были официальными типами диаграмм; те
                             перь это так. В UML 2 диаграммы кооперации теперь называются ком
                             муникационными диаграммами. Кроме того, появились новые виды
                             диаграмм: диаграммы обзора взаимодействия, временные диаграммы
                             и диаграммы составных структур.
                             Значительное количество изменений не отражено в книге. Я не вклю
                             чил в обсуждение такие конструкции, как расширения конечных авто
                             матов, шлюзы в диаграммах взаимодействия и типы мощности в диа
                             граммах классов.
                             Поэтому в данном разделе рассказывается только об изменениях, во
                             шедших  в книгу «UML. Основы».  Это либо изменения, о которых я
                             рассказывал в предыдущих изданиях, либо новые, которые рассмат
                             риваются в этой книге. Поскольку изменения столь обширные, я рас
                             положил их в соответствии с организацией глав данного издания.

                        Диаграммы классов: основы (глава 3)

                             Атрибуты и ненаправленные ассоциации теперь представляют просто
                             различные обозначения одного и того же базового понятия свойства.
                             Дискретные кратности, такие как [2, 4], были исключены. Свойство
                             frozen (замороженный)  также было  исключено. Я добавил перечень
                             ключевых слов для обозначения общей зависимости, некоторые из ко
                             торых появились только в UML 2. Ключевые слова «parameter» (пара
                             метр) и «local» (локальный) были выброшены.

                        Диаграммы последовательности (глава 4)
                             Значительно изменилась нотация фреймов взаимодействия, позволяя
                             реализовывать различные сценарии управления поведением системы,















                        176                                                          Приложение A


                             такие  как итеративный, условный и другие. Теперь с  помощью диа
                             граммы последовательности можно  довольно полно описать алгорит
                             мы, хотя я не уверен, что программный код менее понятен. Применяе
                             мые ранее маркеры итерации и защиты в сообщениях были исключе
                             ны из диаграммы последовательности. Заголовки линий жизни боль
                             ше не представляют экземпляры классов; я называю их участниками
                             (participants). Диаграммы, которые назывались в UML 1 диаграммами
                             кооперации, в UML 2 называются коммуникационными диаграммами.

                        Диаграммы классов: дополнительные понятия (глава 5)
                             Определение стереотипов теперь стало более строгим. В результате те
                             перь я рассматриваю слова в «кавычках» как ключевые слова, из ко
                             торых лишь некоторые представляют собой стереотипы. Экземпляры
                             на диаграммах объектов являются теперь спецификациями экземпля
                             ров. Классы теперь могут как требовать интерфейсы, так и предостав
                             лять их. В случае множественной классификации обобщающие мно
                             жества теперь служат для объединения обобщений в группы. Компо
                             ненты теперь не сопровождаются специальным символом. Активные
                             объекты вместо жирной  линии  теперь обозначаются  двойной верти
                             кальной линией.

                        Диаграммы состояний (глава 10)
                             В UML 1 различали короткоживущие операции и долгоживущие дея
                             тельности. В UML 2 и то и другое называется деятельностями, но для
                             долгоживущих деятельностей употребляется термин doдеятельность
                             (doactivity).
                        Диаграммы деятельности (глава 11)

                             В UML 1 диаграммы деятельности рассматривались как особый случай
                             диаграммы состояний. В UML 2 эта связь была разорвана, и в резуль
                             тате были исключены правила, согласно которым ветвления и объеди
                             нения в диаграммах деятельности должны были находиться в соответ
                             ствии. Поэтому они становятся  более понятными  при рассмотрении
                             маркеров потоков, а не переходов состояний. Появилась целая группа
                             новых нотаций, включая сигналы времени и приема, параметры, опи
                             сания объединений, контакты, преобразования потоков, символы под
                             диаграмм, области расширения и окончания потоков.
                             Простое, но неудобное изменение заключается в том, что в UML 1 счи
                             талось, что несколько входящих в активность потоков неявно имеют
                             слияние, в то время как в UML 2 предполагается, что они имеют объ
                             единение. По этой причине я рекомендую в диаграммах деятельности
                             указывать слияния или объединения явным образом.
                             «Плавательные дорожки» теперь могут быть многомерными и в боль
                             шинстве случаев называются разделами.



























                                                                        Библиография





                             1. Scott Ambler, Agile Modeling, Wiley, 2002.
                             2. Kent Beck, Extreme Programming Explained: Embrace Change, Addi
                                sonWesley, 2000.
                             3. Kent Beck and Martin Fowler, Planning Extreme Programming, Addi
                                sonWesley, 2000.
                             4. Kent Beck and Ward Cunningham, «A Laboratory for Teaching Object
                                Oriented Thinking», Proceedings of OOPSLA 89, 24 (10): 1–6. http://
                                c2.com/doc/oopsla89/paper.html
                             5. Grady Booch, Object'Oriented Analysis and Design with Applications,
                                Second Edition. AddisonWesley, 1994.
                             6. Grady Booch, Jim Rumbaugh, and Ivar Jacobson, UML User Guide,
                                AddisonWesley, 1999.
                             7. Peter Coad and Edward Yourdon, Object'Oriented Analysis, Yourdon
                                Press, 1991.
                             8. Peter  Coad and Edward  Yourdon,  Object'Oriented Design, Yourdon
                                Press, 1991.
                             9. Alistair Cockburn,  Agile Software Development, AddisonWesley,
                                2001.
                            10. Alistair Cockburn,  Writing Effective Use Cases, AddisonWesley,
                                2001.
                            11. Larry Constantine  and Lucy Lockwood,  Software for  Use,  Addison
                                Wesley, 2000.
                            12. Steve Cook and John Daniels,  Designing Object Systems: Object'Ori'
                                ented Modeling with Syntropy, PrenticeHall, 1994.
                            13. Deepak Alur, John Crupi, and Dan Malks, Core J2EE Patterns, Pren
                                ticeHall, 2001.
                            14. Ward Cunningham, «EPISODES: A Pattern Language of Competitive
                                Development.» In Pattern Languages of Program Design 2, Vlissides,
                                Coplien, and Kerth, AddisonWesley, 1996, pp. 371–388.
                            15. Bruce Powel Douglass, Real'Time UML, AddisonWesley, 1999.















                        178                                                          Библиография


                            16. Martin Fowler, Analysis Patterns: Reusable Object Models, Addison
                                Wesley, 1997.
                            17. Martin Fowler, «The New Methodology», http://martinfowler.com/ar'
                                ticles/newMethodology.html
                            18. Martin Fowler and Matthew Foemmel, «Continuous Integration», http:/
                                /martinfowler.com/articles/continuousIntegration.html
                            19. Martin Fowler, Patterns of Enterprise Application Architecture, Addi
                                sonWesley, 2003.
                            20. Martin Fowler,  Refactoring: Improving the Design of  Existing Pro'
                                grams, AddisonWesley, 1999. 1
                            21. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, De'
                                sign Patterns:Elements of  Reusable Object'Oriented Software, Addi
                                sonWesley, 1995.

                            22. Jim Highsmith,  Agile  Software Development Ecosystems, Addison
                                Wesley, 2002.
                            23. Luke Hohmann,  Beyond Software Architecture, AddisonWesley,
                                2003.

                            24. Ivar Jacobson, Magnus Christerson, Patrik Jonsson, and  Gunnar
                                Overgaard, Object'Oriented Software Engineering: A Use Case Driven
                                Approach, AddisonWesley, 1992.
                            25. Ivar Jacobson, Maria Ericsson, and Agneta Jacobson, The Object Ad'
                                vantage: Business Process Reengineering with Object Technology, Ad
                                disonWesley, 1995.

                            26. Norm Kerth, Project Retrospectives, Dorset House, 2001
                            27. Anneke Kleppe, Jos Warmer, and Wim Bast, MDA Explained, Addi
                                sonWesley, 2003.
                            28. Philippe Kruchten,  The Rational Unified Process: An Introduction,
                                AddisonWesley, 1999.
                            29. Craig Larman,  Applying UML and Patterns, 2d ed., PrenticeHall,
                                2001.

                            30. Robert Cecil Martin, The Principles, Patterns, and Practices of Agile
                                Software Development, PrenticeHall, 2003.
                            31. Steve McConnell, Rapid Development: Taming Wild Software Sched'
                                ules, Microsoft Press, 1996.
                            32. Steve Mellor and Marc Balcer,  Executable UML, AddisonWesley,
                                2002.

                             1  Мартин Фаулер «Рефакторинг: улучшение существующего кода». – Пер. с
                                англ. – СПб: СимволПлюс, 2002.















                        Библиография                                                          179


                            33. Bertrand Meyer,  Object'Oriented Software Construction. Prentice
                                Hall, 2000.
                            34. James Martin and James J. Odell, Object'Oriented Methods: A Founda'
                                tion (UML Edition), Prentice Hall, 1998.
                            35. Michael Pont, Patterns for Time'Triggered Embedded Systems, Addi
                                sonWesley, 2001.
                            36. Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad,
                                and Michael Stal, Pattern'Oriented Software Architecture: A System of
                                Patterns, Wiley, 1996.
                            37. Douglas Schmidt, Michael Stal, Hans Rohnert, and Frank Buschmann,
                                Pattern'Oriented Software Archtecture Volume 2: Patterns for Concur'
                                rent and Networked Objects, Wiley, 2000.
                            38. James Rumbaugh, OMT Insights, SIGS Books, 1996.
                            39. James Rumbaugh, Michael Blaha, William Premerlani, Frederick Ed
                                dy, and William  Lorenzen,  Object'Oriented Modeling and Design,
                                PrenticeHall, 1991.
                            40. James Rumbaugh, Ivar Jacobson, and Grady Booch, The Unified Mod'
                                eling Language Reference Manual, AddisonWesley, 1999.
                            41. Sally Shlaer and Stephen J. Mellor, Object'Oriented Systems Analysis:
                                Modeling the World in Data, Yourdon Press, 1989.
                            42. Sally Shlaer and Stephen J. Mellor,  Object Lifecycles: Modeling the
                                World in States. Yourdon Press, 1991.
                            43. Jos Warmer  and Anneke Kleppe,  The Object  Constraint Language:
                                Precise Modeling with UML, AddisonWesley, 1998.
                            44. Rebecca WirfsBrock and Alan McKean, Object Design: Roles Respon'
                                sibilities and Collaborations. PrenticeHall, 2003.



























                        Алфавитный указатель





                        C                                      PIM, модель, не зависящая от
                                                                 платформы, 31
                        CASEсредства (автоматизированная      PSM, модель, зависящая от
                         разработка программного                 платформы), 31
                         обеспечения), 29
                          история UML, 35                      R
                        CORBA, общая архитектура
                         посредников запросов к объектам, 27   RUP, унифицированный процесс
                        CRCкарточки (классответственность     от Rational
                         кооперация), 89                          фазы, 53

                        D                                      S
                        doактивности, 133                     Scrum, процесс разработки, 51
                        DSDM, метод разработки динамичес      Smalltalk, язык, 32
                         ких систем, 51
                                                               U
                        F
                                                               UML
                        FDD, разработка, управляемая              история, 34, 35
                         свойствами, 51                           определение, 27
                                                                  ресурсы, 43
                        M                                         с точки зрения программного
                                                                    обеспечения и с концептуальной
                        MDA, архитектура на основе моделей,         точки зрения, 30
                         31                                       смысл, 41
                        Mеллор, Стив                           UML как средство планирования
                          история UML, 34
                                                                  прямая разработка, 29
                                                               UML как средство проектирования
                        O                                         обратная разработка, 33
                                                                  прямая разработка, 33
                        OMG, группа управления объектами
                          MDA, архитектура на основе           UML как средство эскизирования, 33
                            моделей, 31                           обратная разработка, 28
                          история UML, 35                         прямая разработка, 28
                          управление UML, 27                   UML как язык моделирования
                                                                  MDA, архитектура на основе
                        P                                           моделей, 31
                                                               UML как язык программирования, 30,
                        Petri Nets, ориентированные на потоки    32
                         технологии, 151                          значение, 32
                                                                  обратная разработка, 30















                        Алфавитный указатель                                                  181


                          прямая разработка, 30                      диаграммы последовательности,
                        UML, определенный в соответствии               80
                          допустимый UML, 39                         когда применяются, 164
                          определение, 41                            основы, 164
                        «UML. основы», издания книги и соот         синхронные и асинхронные
                         ветствующие версии языка UML, 170             сообщения, 88
                        UP, унифицированный процесс, 52              циклы и условия, 85
                                                                  временные, 38
                        X                                            когда применяются, 167
                                                                     основы, 166
                        XP, экстремальное программирование        деятельности, 38
                          ресурсы, 61                                анализ требований, 56
                          скоростной процесс разработки, 51
                                                                     декомпозиция операций, 141
                                                                     когда применяются, 150
                        А
                                                                     операции, области расширения,
                        абстрактные классы, взаимосвязь                147
                         классов и интерфейсов, 96                   основы, 139
                        активные классы, 110                         отличия в версиях UML, 176
                        анализ требований, 56                        потоки, Petri Nets, 151
                        ассоциации, свойства классов, 64             разделы, 143
                          двунаправленные, 68                        ресурсы, 151
                          неизменность в сравнении                   сигналы, 144
                            с замороженностью, 171                классов, 38
                          однонаправленные, 68                       абстрактные классы, 96
                        атрибуты классов, 93                         агрегация и композиция, 94
                                                                     активные классы, 110
                        Б                                            видимость, 110
                                                                     дизайн, 57
                        Банда четырех, 55                            зависимости, 74
                        Бек, Кент, CRCкарточки, 91                  и диаграммы объектов, 113
                        Буч, Гради, история UML, 34
                                                                     классификации
                                                                        динамические и множествен
                        В                                                 ные, 103
                        версии, 47                                   классыассоциации, 105
                        внутренние активности, входные               ключевые слова, 92
                         и выходные, 132                             когда применяются, 77
                        временные диаграммы, 38                      обобщения, 72
                          основы, 166                                объектызначения, 100
                                                                     объектыссылки, 100
                        Г                                            ответственности, 93
                                                                     отличия в версиях UML, 176
                        гарантии, 126                                правила ограничений, 76
                                                                     ресурсы, 79
                        Д                                            свойства, 62
                                                                     статические операции и атрибу
                        двунаправленные ассоциации, 68
                        деятельности начального узла, 139              ты, 93
                        диаграммы                                    шаблоны классов (параметризо
                          UML, 38                                      ванные классы), 108
                          взаимодействий                          коммуникационные, 38
                             CRCкарточки, 89                     компонентов, 38, 158
                                                                     когда применяются, 160















                        182                                                   Алфавитный указатель


                             основы, 158                       З
                          конечных автоматов, 38
                             внутренние активности, 132        зависимости
                             основы, 130                          отличия в версиях UML, 172
                             отличия в версиях UML, 176           пакеты, 116
                             параллельные состояния, 134       закрытые элементы, 110
                             состояния активности, 133         замещаемость, 72
                             суперсостояния, 133               защищенные элементы, 110
                          кооперации, 161
                          недостаточность, 41                  И
                          обзора взаимодействий, 38            инварианты, 78
                          объектов, 38                         инкрементный процесс разработки, см.
                             когда применяются, 112, 113         итеративный процесс разработки
                             основы, 38                        исполняемый UML, 31
                          пакетов, 38                          итеративный процесс разработки, 46
                             дизайн, 57
                             когда применяются, 120            К
                             основы, 114
                             ресурсы, 120                      квалифицированные ассоциации, 101
                          последовательности, 38               классификации
                             CRCкарточки, 89                     динамическая и множественная,
                             возвраты, 171                          103
                             диаграммы взаимодействий, 80         против обобщения, 102
                             когда применяются, 89                типы данных, 170
                             основы, 80                        классы, 92
                             отличия в версиях UML, 175           абстрактные, 96
                             с чего начать, 43                    атрибуты, 93
                             синхронные и асинхронные             динамические типы данных, 171
                               сообщения, 88                      классответственностькооперация
                             циклы и условия, 85                    (CRCкарточки), 89
                          прецедентов, 38                         обобщения, 62
                             анализ требований, 56                образование производных, 108
                             основы, 126                          определение подклассов, 79
                          развертывания, 38                       реализации, типы данных, 170
                             дизайн, 57                           статические типы данных, 171
                             когда применяются, 122            клиенты/серверы, 74
                             с чего начать, 43                 ключевые слова, диаграммы классов,
                             узлы, 121                           92
                                                               Кокборн, Алистер (Cockburn, Alister),
                          составных структур, 38
                             когда применяются, 157              прецеденты, 129
                             основы, 155                       коммуникационные диаграммы, 38
                          состояний, 130                          когда применяются, 154
                             когда применяются, 137            композиция, 94
                             реализация, 135                      отличия в версиях UML, 171
                             ресурсы, 138                      кооперации
                          типы, отличия в версиях UML, 175        когда применяются, 163
                          точки зрения, 30
                        документация, 58                       М
                                                               маркеры, 145
                                                               Меллор, Стив (Mellorn, Steve)
                                                                  исполняемый UML, 31















                        Алфавитный указатель                                                  183


                        метамодели, определения, 36               зависимости, 116
                        множественные классификации               полностью определенные имена,
                          типы данных, 170                          114
                        модель, зависящая от платформы            пространства имен, 114
                         (PSM), 31                             параллельные состояния, 134
                        модификаторы, 71                       паттерны
                                                                  Separated Interface, разделенный
                        Н                                           интерфейс, 120
                                                                  применение, 162
                        нотация                                   состояние, 136
                          леденцы на палочках, 98              переходы, 131
                          шаровогнездовая, 98                    состояние, 136
                                                               перечисления, 109
                        О                                      планирование, адаптивное
                        области расширения, 147                  и прогнозирующее, 50
                        обобщения, 62                          планы, UML как инструмент
                          множества, 104                          обратной разработки, 33
                        обратная разработка,                      прямой разработки, 33
                         UML как                               повторно используемые прототипы, 32
                          средство проектирования, 33          подтипы, 73
                          средство эскизирования, 28           полностью определенные имена, 114
                          язык программирования, 30            потоки, 145
                        объекты предметной области, 74            Petri Nets, 151
                        объектыссылки, 100                       окончание потока, 148
                        ограничения                            прецеденты
                          полные/неполные, 171                    когда применяются, 128
                          правила, 76                             отличия в версиях UML, 172
                        Оделл, Джим (Odell, Jim), история         ресурсы, 129
                         UML, 34                                  свойства, 128
                        однозначная классификация                 уровень воздушного змея, 128
                          классы реализации, 171                  уровень моря, 128
                        однонаправленные ассоциации, 68           уровень рыб, 128
                        ООП, объектноориентированное          принцип ацикличности зависимостей,
                         программирование, 27                    117
                        операции                               принцип стабильных абстракций, 117
                          области расширения, 147              принцип стабильных зависимостей,
                          отличия в версиях UML, 175             117
                        открытые элементы, 110                 прогнозирующее планирование и
                        отличия версий UML                       адаптивное планирование, 49
                          от 0.8 до 2.0, основная история, 168  проектирование, 57
                          от 1.0 до 1.1, 170                   пространства имен, 114
                          от 1.2 до 1.3, 172                   процессы разработки программного
                          от 1.3 до 1.4, 174                     обеспечения, 45
                          от 1.4 до 1.5, 175                      DSDM, метод разработки
                          от 1.x до 2.0, 175                        динамических систем, 51
                        отношения абстрактных классов             FDD, разработка, управляемая
                         и интерфейсов, 96                          свойствами, 51
                                                                  водопадные, 46
                        П                                         выбор, 60
                                                                  итеративные, 46
                        пакеты                                    настройка процессов под проекты,
                          аспекты, 118                              53, 55















                        184                                                   Алфавитный указатель


                          ресурсы, 61                          Т
                          скоростные, 51
                          унифицированный процесс              таблицы состояний, 135
                            от Rational (RUP), 52              типы данных, 101, 170
                          экстремальное программирование          динамические и множественные
                            (XP), 51, 61                            классификации, 171
                        прямая разработка,                     «Трое друзей», 36
                         UML как
                          средство планирования, 29            У
                          средство проектирования, 33          узлы, 121
                          средство эскизирования, 28           унаследованный код, 60
                          язык программирования, 30
                                                               унифицированный процесс от Rational
                                                                 (RUP)
                        Р                                         фазы, 53
                                                               унифицированный язык
                        разделы, диаграммы деятельности, 143
                        разработка, см. прямая и обратная        моделирования (UML), 27
                         разработка                            условия, 85
                        Ребекка ВирфсБрок (Rebecca Wirfs        решения и слияния, 141
                         Brock), история UML, 34               условное использование, 39
                        решения, 141                           утверждения
                        руководство пользователя, 138             определение подклассов, 79
                        С                                      Ф
                        свойства классов, 62                   фасады, 116
                          frozen, 100
                          readonly, 100                       Ш
                          ассоциации, двунаправленные, 68      шаровогнездовая нотация, 98
                          ассоциации, неизменность против
                            замороженности, 171                Э
                          квалифицированные, 101
                          основы, 62                           эволюционный процесс разработки, 46
                        свойства прецедентов, 128              экстремальное программирование,
                        серверы/клиенты, 74                      см. XP
                        сигналы, 144                              ресурсы, 61
                        скоростные процессы разработки, 51        скоростной процесс разработки, 51
                          ресурсы, 61                          эскизы, UML как, 33
                        словари, 101
                        совмещение имен, 101                   Я
                        создание подклассов
                          утверждения, 79                      языки программирования
                        сообщения, 111                            Eiffel, 78
                          диаграммы классов, 111                  Smalltalk, 32
                          синхронные и асинхронные, 88            UML как, 30
                        состояние активности, 133                    MDA, архитектура на основе
                        спиральный процесс разработки, 46              моделей, 31
                        статические операции классов, 93             значение, 32
                        стереотипы, 93
                        суперсостояния, 133























                             По договору между издательством «СимволПлюс» и Интернетмага
                             зином «Books.Ru  Книги  России» единственный легальный способ
                             получения данного файла с книгой ISBN 593286060X, название
                             «UML. Основы, 3е издание» – покупка в Интернетмагазине «Books.Ru
                              Книги России». Если Вы получили данный файл какимлибо другим
                             образом, Вы нарушили международное законодательство и законода
                             тельство Российской Федерации об охране авторского права. Вам необ
                             ходимо удалить данный файл, а также сообщить издательству «Сим
                             волПлюс» (piracy@symbol.ru), где именно Вы получили данный файл.
